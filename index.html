<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HM Trading Dashboard</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js" crossorigin="anonymous"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html {
            overflow-x: hidden;
            max-width: 100vw;
        }
        body {
            font-family: 'Roboto Mono', -apple-system, BlinkMacSystemFont, monospace;
            background: #0d1117;
            color: #c9d1d9;
            min-height: 100vh;
            font-size: 12px;
            -webkit-tap-highlight-color: transparent;
            overflow-x: hidden;
            max-width: 100vw;
            width: 100%;
        }

        /* === BITMEX-STYLE HEADER === */
        .trading-header {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            background: #161b22;
            border-bottom: 1px solid #30363d;
            gap: 16px;
            flex-wrap: wrap;
            max-width: 100vw;
            overflow-x: hidden;
        }
        .instrument-dropdown {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .instrument-dropdown:hover { background: rgba(255,255,255,0.05); }
        .instrument-name {
            font-size: 15px;
            font-weight: 700;
            color: #fff;
        }
        .instrument-type {
            font-size: 12px;
            color: #8b949e;
            margin-left: 4px;
        }
        .instrument-badges {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }
        .badge-sm {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 2px;
            font-weight: 600;
        }
        .badge-btc { background: #f7931a; color: #000; }
        .badge-leverage { background: #3fb950; color: #000; }
        .price-section {
            display: flex;
            flex-direction: column;
            margin-left: 16px;
        }
        .price-main {
            font-size: 22px;
            font-weight: 700;
            color: #3fb950;
            display: flex;
            align-items: center;
            gap: 4px;
            min-width: 140px; /* Fixed width prevents jumping on price changes */
        }
        .price-main.down { color: #f85149; }
        .price-arrow { font-size: 14px; }
        .price-change {
            font-size: 12px;
            color: #f85149;
        }
        .price-change.positive { color: #3fb950; }
        .header-stats {
            display: flex;
            gap: 20px;
            margin-left: auto;
            font-size: 11px;
        }
        .header-stat {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }
        .header-stat-label {
            color: #8b949e;
            font-size: 10px;
        }
        .header-stat-value {
            color: #c9d1d9;
            font-weight: 500;
        }
        .header-stat-value.positive { color: #3fb950; }
        .header-stat-value.negative { color: #f85149; }

        /* === MAIN TRADING LAYOUT === */
        .trading-main {
            display: grid;
            grid-template-columns: 1fr 300px;
            height: 55vh; /* Fixed height so bots section is visible below */
            min-height: 400px;
            max-height: 550px;
            gap: 1px;
            background: #30363d;
        }
        /* Mobile: Stack chart and panel vertically */
        @media (max-width: 768px) {
            .trading-main {
                grid-template-columns: 1fr;
                grid-template-rows: 350px auto;
                height: auto;
                min-height: 400px;
                max-height: none;
            }
        }
        .chart-section {
            background: #0d1117;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            position: relative;
        }
        /* Mobile: Ensure chart section has explicit height */
        @media (max-width: 768px) {
            .chart-section {
                min-height: 300px;
                height: 350px;
            }
        }
        .chart-toolbar {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 8px; /* Tighter padding */
            background: #161b22;
            border-bottom: 1px solid #30363d;
        }
        .period-dropdown {
            position: relative;
        }
        .period-btn {
            background: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .period-btn:hover { background: #30363d; }
        .period-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 4px;
            z-index: 1000;
            display: none;
            min-width: 100px;
        }
        .period-menu.show { display: block; }
        .period-option {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
        }
        .period-option:hover { background: #21262d; }
        .period-option.active { color: #00d4ff; }

        /* === OHLC DISPLAY === */
        .ohlc-display {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 2px 8px; /* Tighter */
            background: #0d1117;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
        }
        .ohlc-item {
            display: flex;
            align-items: center;
            gap: 2px;
        }
        .ohlc-label {
            color: #8b949e;
        }
        .ohlc-value {
            color: #c9d1d9;
        }
        .ohlc-value.up { color: #3fb950; }
        .ohlc-value.down { color: #f85149; }

        /* === BOTTOM PERIOD SELECTOR === */
        .chart-period-bar {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 3px;
            padding: 3px 8px; /* Tighter */
            background: #161b22;
            border-top: 1px solid #30363d;
            position: relative;
            z-index: 50;
        }
        .chart-period-btn {
            padding: 2px 8px; /* Tighter */
            background: transparent;
            border: 1px solid #30363d;
            border-radius: 3px;
            color: #8b949e;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .chart-period-btn:hover {
            background: #21262d;
            color: #c9d1d9;
        }
        .chart-period-btn.active {
            background: #238636;
            border-color: #238636;
            color: #ffffff;
        }

        .chart-container-pro {
            flex: 1 1 auto;
            min-height: 0;
            position: relative;
        }
        #live-price-chart-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
        }

        /* === RIGHT PANEL (ORDERBOOK + TRADES) === */
        .right-panel {
            background: #0d1117;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        /* ORDERBOOK section - fixed height with scrollable content */
        .panel-section.orderbook-section {
            flex: 0 0 auto; /* Fixed size, doesn't shrink */
            display: flex;
            flex-direction: column;
            min-height: 280px; /* Enough for ~15 rows each side */
            max-height: 350px;
            border-bottom: 1px solid #30363d;
            overflow: hidden;
        }
        /* TRADES section - fills remaining space, has scrollbar */
        .panel-section.trades-section {
            flex: 1 1 auto; /* Fills remaining space */
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        .panel-header {
            flex-shrink: 0;
            padding: 4px 8px; /* Tighter padding */
            background: #161b22;
            font-size: 10px;
            font-weight: 600;
            color: #8b949e;
            text-transform: uppercase;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        /* Orderbook content - scrollable to show all rows */
        .orderbook-section .panel-content {
            flex: 1 1 auto;
            overflow-y: auto; /* Allow scroll if needed */
            overflow-x: hidden;
            padding: 2px;
            min-height: 0;
        }
        /* Trades content - overflow auto, HAS scrollbar */
        .trades-section .panel-content {
            flex: 1 1 auto;
            overflow-y: auto; /* HAS scrollbar */
            overflow-x: hidden;
            padding: 2px;
            min-height: 0;
        }

        /* === ORDERBOOK STYLES === */
        .orderbook-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 1px 4px; /* Tighter */
            font-size: 10px;
            position: relative;
        }
        .orderbook-row.header {
            color: #8b949e;
            font-weight: 500;
            padding: 2px 4px; /* Tighter */
            border-bottom: 1px solid #30363d;
        }
        .orderbook-row.bid .ob-price { color: #3fb950; }
        .orderbook-row.ask .ob-price { color: #f85149; }
        .ob-price { text-align: left; }
        .ob-size { text-align: right; }
        .ob-total { text-align: right; color: #8b949e; }
        .orderbook-row .depth-bar {
            position: absolute;
            top: 0;
            bottom: 0;
            right: 0;
            opacity: 0.15;
        }
        .orderbook-row.bid .depth-bar { background: #3fb950; }
        .orderbook-row.ask .depth-bar { background: #f85149; }
        .spread-row {
            text-align: center;
            padding: 3px; /* Tighter */
            background: #161b22;
            font-size: 10px;
            color: #8b949e;
        }

        /* === RECENT TRADES STYLES === */
        .trade-row {
            display: grid;
            grid-template-columns: 55px 40px 1fr 60px;
            padding: 1px 4px; /* Tighter */
            font-size: 10px;
        }
        .trade-row.header {
            color: #8b949e;
            font-weight: 500;
            padding: 2px 4px; /* Tighter */
            border-bottom: 1px solid #30363d;
        }
        .trade-row.buy .trade-side { color: #3fb950; }
        .trade-row.sell .trade-side { color: #f85149; }
        .trade-time { color: #8b949e; }
        .trade-price { text-align: right; }
        .trade-size { text-align: right; }

        /* === BOTTOM TAB BAR === */
        .tab-bar {
            display: flex;
            background: #161b22;
            border-top: 1px solid #30363d;
            border-bottom: 1px solid #30363d;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            position: relative;
            z-index: 100; /* Ensure tab bar is above chart canvas */
            margin: 0;
            padding: 0;
        }
        .tab-bar::-webkit-scrollbar { height: 0; }
        .tab-item {
            padding: 10px 16px;
            color: #8b949e;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tab-item:hover { color: #c9d1d9; background: rgba(255,255,255,0.05); }
        .tab-item.active { color: #00d4ff; border-bottom-color: #00d4ff; }
        .tab-count { opacity: 0.7; }
        .tab-content { display: none; background: #0d1117; min-height: 200px; margin: 0; padding: 0; }
        .tab-content.active { display: block; }

        /* === YOUR BOTS TAB === */
        .bots-container { padding: 0; display: flex; flex-direction: column; gap: 0; }
        .bots-table { width: 100%; }
        .bots-table-header {
            display: grid;
            grid-template-columns: 120px 1fr 150px 120px 100px;
            padding: 10px 16px;
            background: #161b22;
            border-bottom: 1px solid #30363d;
            font-size: 12px;
            color: #8b949e;
        }
        .bots-table-body { min-height: 100px; }
        .bot-row {
            display: grid;
            grid-template-columns: 120px 1fr 150px 120px 100px;
            padding: 12px 16px;
            border-bottom: 1px solid #21262d;
            font-size: 13px;
            align-items: center;
        }
        .bot-row:hover { background: rgba(255,255,255,0.02); }
        .bot-status { display: flex; align-items: center; gap: 6px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-dot.running { background: #3fb950; animation: pulse 1.5s infinite; }
        .status-dot.stopped { background: #8b949e; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .add-bot-row {
            display: flex;
            gap: 12px;
            padding: 12px 16px;
            background: #161b22;
            border-top: 1px solid #30363d;
        }
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
        .running-bot-stats {
            display: flex;
            gap: 24px;
            padding: 12px 16px;
            background: rgba(63,185,80,0.1);
            border: 1px solid #3fb950;
            border-radius: 4px;
            margin: 12px 16px;
            align-items: center;
        }
        .bot-controls-card {
            display: flex; gap: 16px; align-items: flex-end; flex-wrap: wrap;
            padding: 16px; background: #161b22; border-radius: 8px; border: 1px solid #30363d;
        }
        .control-item { display: flex; flex-direction: column; gap: 6px; }
        .control-item label { font-size: 11px; color: #8b949e; text-transform: uppercase; }
        .pro-select {
            background: #21262d; border: 1px solid #30363d; color: #c9d1d9;
            padding: 8px 12px; border-radius: 4px; font-size: 13px; min-width: 180px;
            cursor: pointer;
            -webkit-appearance: menulist;
            -moz-appearance: menulist;
            appearance: menulist;
        }
        .pro-select:focus {
            outline: 2px solid #00d4ff;
            outline-offset: 1px;
        }
        .button-group { display: flex; gap: 8px; }
        .btn-pro {
            padding: 8px 16px; border-radius: 4px; font-size: 12px; font-weight: 500;
            cursor: pointer; border: none; transition: all 0.2s;
        }
        .btn-start-pro { background: #238636; color: #fff; }
        .btn-start-pro:hover:not(:disabled) { background: #2ea043; }
        .btn-start-pro:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-stop-pro { background: #da3633; color: #fff; }
        .btn-stop-pro:hover:not(:disabled) { background: #f85149; }
        .btn-stop-pro:disabled { opacity: 0.5; cursor: not-allowed; }
        .test-stats-row { display: flex; gap: 24px; margin-left: auto; }
        .test-stat { display: flex; flex-direction: column; align-items: center; }
        .test-stat .stat-label { font-size: 10px; color: #8b949e; text-transform: uppercase; }
        .test-stat .stat-value { font-size: 16px; font-weight: 600; color: #c9d1d9; }
        .test-stat .stat-value.positive { color: #3fb950; }
        .test-stat .stat-value.negative { color: #f85149; }

        /* Metrics + Equity Row */
        .metrics-equity-row { display: grid; grid-template-columns: 1fr 2fr; gap: 16px; }
        @media (max-width: 900px) { .metrics-equity-row { grid-template-columns: 1fr; } }
        .panel-card {
            background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 16px;
        }
        .panel-title {
            font-size: 13px; font-weight: 600; color: #c9d1d9; margin-bottom: 12px;
            display: flex; align-items: center; gap: 8px;
        }
        .metrics-grid-pro { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
        .metric-item { display: flex; flex-direction: column; gap: 4px; }
        .metric-label { font-size: 11px; color: #8b949e; }
        .metric-value { font-size: 16px; font-weight: 600; color: #c9d1d9; }
        .metric-value.positive { color: #3fb950; }
        .metric-value.negative { color: #f85149; }
        .equity-chart-pro { height: 200px; background: #0d1117; border-radius: 4px; }

        /* Trade Logs */
        .logs-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        @media (max-width: 768px) { .logs-row { grid-template-columns: 1fr; } }
        .log-column { background: #161b22; border: 1px solid #30363d; border-radius: 8px; overflow: hidden; }
        .log-header {
            padding: 10px 12px; display: flex; justify-content: space-between;
            align-items: center; font-size: 12px; border-bottom: 1px solid #30363d;
        }
        .log-header.test { background: rgba(0,212,255,0.1); }
        .log-header.backtest { background: rgba(138,43,226,0.1); }
        .log-badge { padding: 2px 8px; border-radius: 3px; font-size: 10px; font-weight: 600; }
        .log-header.test .log-badge { background: #00d4ff; color: #000; }
        .log-header.backtest .log-badge { background: #8b5cf6; color: #fff; }
        .log-list { max-height: 250px; overflow-y: auto; padding: 8px; }
        .log-item { padding: 8px; border-bottom: 1px solid #21262d; font-size: 12px; }
        .log-item:last-child { border-bottom: none; }
        .log-item.divergent { background: rgba(248,81,73,0.1); }
        .no-data { color: #8b949e; text-align: center; padding: 20px; font-size: 12px; }

        /* Legacy container styles for compatibility */
        .container { max-width: 100%; margin: 0; padding: 0; }
        header { display: none; } /* Hide old header */
        .subtitle { color: #8b949e; font-size: 11px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 24px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 40px rgba(0,212,255,0.1);
        }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            flex-wrap: wrap;
            gap: 10px;
        }
        .card-title { font-size: 1.3rem; font-weight: 600; }
        .badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .badge-success { background: rgba(0,200,83,0.2); color: #00c853; }
        .badge-warning { background: rgba(255,193,7,0.2); color: #ffc107; }
        .badge-info { background: rgba(0,212,255,0.2); color: #00d4ff; }
        .badge-real { background: rgba(123,44,191,0.3); color: #c77dff; }
        .stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .stat-grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
        .stat-grid-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; }
        .stat {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
        }
        .stat-sm { padding: 12px; }
        .stat-label { color: #8892b0; font-size: 0.85rem; margin-bottom: 5px; }
        .stat-label-sm { font-size: 0.75rem; }
        .stat-value { font-size: 1.4rem; font-weight: 600; }
        .stat-value-sm { font-size: 1.1rem; }
        .stat-value.positive { color: #00c853; }
        .stat-value.negative { color: #ff5252; }
        .test-list { list-style: none; }
        .test-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .test-item:last-child { border-bottom: none; }
        .test-name { display: flex; align-items: center; gap: 10px; }
        .test-icon { font-size: 1.2rem; }
        .test-status { font-size: 0.85rem; font-weight: 500; }
        .passed { color: #00c853; }
        .failed { color: #ff5252; }
        .skipped { color: #ffc107; }
        .bot-card { margin-bottom: 15px; cursor: pointer; padding: 10px; border-radius: 8px; transition: background 0.2s; }
        .bot-card:hover { background: rgba(255,255,255,0.05); }
        .bot-card.active { background: rgba(0,212,255,0.15); border: 1px solid rgba(0,212,255,0.3); }
        .bot-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }
        .bot-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
        }
        .bot-icon.pair { background: rgba(123,44,191,0.3); }
        .bot-icon.saz { background: rgba(0,212,255,0.3); }
        .bot-icon.sd { background: rgba(255,193,7,0.3); }
        .bot-icon.diverge { background: rgba(0,200,83,0.3); }
        .bot-desc { color: #8892b0; font-size: 0.9rem; margin-top: 5px; }
        .progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s;
        }
        .timestamp {
            color: #8892b0;
            font-size: 0.85rem;
            text-align: center;
            margin-top: 30px;
        }
        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #00d4ff;
        }
        .full-width { grid-column: 1 / -1; }
        #chart-container, #equity-chart-container {
            width: 100%;
            height: 400px;
            border-radius: 8px;
            overflow: hidden;
            touch-action: pan-x pan-y;
        }
        #equity-chart-container { height: 250px; }
        .chart-legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }
        .trade-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .trade-table th, .trade-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .trade-table th {
            color: #8892b0;
            font-weight: 500;
            font-size: 0.85rem;
        }
        .trade-table tr:hover {
            background: rgba(255,255,255,0.05);
        }
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #8892b0;
        }
        .error-message {
            background: rgba(255,82,82,0.2);
            border: 1px solid rgba(255,82,82,0.5);
            padding: 20px;
            border-radius: 8px;
            color: #ff5252;
            text-align: center;
        }
        /* Error Toast for API failures */
        .error-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,82,82,0.95);
            border: 1px solid #ff5252;
            border-radius: 8px;
            padding: 16px 20px;
            color: #fff;
            font-size: 0.95rem;
            max-width: 400px;
            z-index: 10000;
            box-shadow: 0 4px 20px rgba(255,82,82,0.4);
            display: none;
            animation: slideIn 0.3s ease-out;
        }
        .error-toast.show { display: block; }
        .error-toast-title {
            font-weight: 600;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .error-toast-message { opacity: 0.9; font-size: 0.9rem; }
        .error-toast-close {
            position: absolute;
            top: 8px;
            right: 10px;
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 1.2rem;
            opacity: 0.7;
        }
        .error-toast-close:hover { opacity: 1; }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        /* JS Error Panel - persistent error log */
        .js-error-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(30, 30, 40, 0.98);
            border: 2px solid #ff5252;
            border-radius: 8px;
            padding: 0;
            max-width: 600px;
            max-height: 300px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            font-family: monospace;
            font-size: 12px;
        }
        .js-error-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #ff5252;
            color: #fff;
            font-weight: bold;
        }
        .js-error-header button {
            background: none;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
        }
        .js-error-list {
            max-height: 250px;
            overflow-y: auto;
            padding: 8px;
        }
        .js-error-entry {
            padding: 4px 0;
            border-bottom: 1px solid #333;
            color: #ff8a80;
        }
        .js-error-entry .error-time { color: #888; margin-right: 8px; }
        .js-error-entry .error-type { color: #ffab40; margin-right: 8px; font-weight: bold; }
        .js-error-entry .error-msg { color: #ff8a80; }
        .js-error-entry .error-loc { color: #666; margin-left: 8px; font-size: 10px; }
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .config-item {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
        }
        .config-label { color: #8892b0; font-size: 0.75rem; }
        .config-value { color: #fff; font-size: 0.9rem; margin-top: 3px; }

        /* Controls Bar */
        .controls-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-label {
            color: #8892b0;
            font-size: 0.85rem;
        }
        .control-select {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            padding: 10px 15px;
            font-size: 0.9rem;
            cursor: pointer;
            min-width: 160px;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%238892b0' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 35px;
        }
        .control-select:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .control-select option {
            background: #1a1a2e;
            color: #fff;
        }

        /* Export Buttons */
        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .btn {
            background: rgba(0,212,255,0.2);
            border: 1px solid rgba(0,212,255,0.4);
            border-radius: 8px;
            color: #00d4ff;
            padding: 10px 18px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            touch-action: manipulation;
        }
        .btn:hover {
            background: rgba(0,212,255,0.3);
            transform: translateY(-1px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-icon {
            font-size: 1rem;
        }

        /* Mobile Improvements */
        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .subtitle { font-size: 1rem; }
            .grid { grid-template-columns: 1fr; }
            .stat-grid { grid-template-columns: 1fr; }
            .stat-grid-3, .stat-grid-4 { grid-template-columns: repeat(2, 1fr); }
            #chart-container { height: 350px; }
            #equity-chart-container { height: 220px; }
            .card { padding: 18px; }
            .card-title { font-size: 1.1rem; }
            .trade-table { font-size: 0.85rem; }
            .trade-table th, .trade-table td { padding: 8px 5px; }
            .controls-bar { flex-direction: column; }
            .control-group { width: 100%; }
            .control-select { width: 100%; }
            .export-buttons { width: 100%; justify-content: center; }
            .btn { flex: 1; justify-content: center; min-width: 120px; }
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            h1 { font-size: 1.6rem; }
            header { padding: 20px 0; }
            #chart-container { height: 280px; }
            #equity-chart-container { height: 180px; }
            .stat-grid-3, .stat-grid-4 { grid-template-columns: 1fr; }
            .config-grid { grid-template-columns: repeat(2, 1fr); }
            .card-header { flex-direction: column; align-items: flex-start; }
            .chart-legend { justify-content: center; }
            .legend-item { font-size: 0.8rem; }
            .legend-color { width: 12px; height: 12px; }
        }

        /* Touch-friendly scrolling for trade table */
        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }
        .table-wrapper::-webkit-scrollbar {
            height: 6px;
        }
        .table-wrapper::-webkit-scrollbar-track {
            background: transparent;
        }
        .table-wrapper::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }

        /* Session Comparison Styles */
        .comparison-container {
            display: none;
        }
        .comparison-container.active {
            display: block;
        }
        .comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0,212,255,0.1);
            border-radius: 8px;
            border: 1px solid rgba(0,212,255,0.3);
        }
        .comparison-title {
            font-size: 1.2rem;
            color: #00d4ff;
        }
        .parity-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .parity-badge.match {
            background: rgba(0,200,83,0.2);
            color: #00c853;
            border: 1px solid rgba(0,200,83,0.3);
        }
        .parity-badge.mismatch {
            background: rgba(255,82,82,0.2);
            color: #ff5252;
            border: 1px solid rgba(255,82,82,0.3);
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        .session-column {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
        }
        .session-column.test {
            border-color: rgba(0,212,255,0.3);
        }
        .session-column.backtest {
            border-color: rgba(123,44,191,0.3);
        }
        .session-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .session-label .badge {
            font-size: 0.9rem;
            padding: 6px 14px;
        }
        .session-label .session-name {
            font-size: 1.1rem;
            font-weight: 600;
        }
        .comparison-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .comparison-metric:last-child {
            margin-bottom: 0;
        }
        .comparison-metric .label {
            color: #8892b0;
            font-size: 0.9rem;
        }
        .comparison-metric .value {
            font-weight: 600;
            font-size: 1.1rem;
        }
        .comparison-metric .value.match {
            color: #00c853;
        }
        .comparison-metric .value.mismatch {
            color: #ff5252;
        }
        .match-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            margin-left: 10px;
        }
        .match-indicator.match {
            background: rgba(0,200,83,0.2);
            color: #00c853;
        }
        .match-indicator.mismatch {
            background: rgba(255,82,82,0.2);
            color: #ff5252;
        }
        .comparison-summary {
            margin-top: 20px;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
        }
        .summary-title {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #00d4ff;
        }
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        .summary-item {
            text-align: center;
            padding: 15px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
        }
        .summary-item .number {
            font-size: 2rem;
            font-weight: 700;
        }
        .summary-item .number.positive {
            color: #00c853;
        }
        .summary-item .number.negative {
            color: #ff5252;
        }
        .summary-item .label {
            color: #8892b0;
            font-size: 0.85rem;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .comparison-grid {
                grid-template-columns: 1fr;
            }
            .summary-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Trade Logs Comparison Styles */
        .trade-logs-comparison {
            margin-top: 30px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 20px;
        }
        .trade-logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .trade-logs-title {
            font-size: 1.2rem;
            color: #00d4ff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .trade-logs-filters {
            display: flex;
            gap: 10px;
        }
        .filter-btn {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.2);
            background: transparent;
            color: #8892b0;
            transition: all 0.2s;
        }
        .filter-btn:hover {
            background: rgba(255,255,255,0.1);
        }
        .filter-btn.active {
            background: rgba(0,212,255,0.2);
            border-color: rgba(0,212,255,0.5);
            color: #00d4ff;
        }
        .trade-logs-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .trade-log-column {
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        .trade-log-column.test {
            border-color: rgba(0,212,255,0.3);
        }
        .trade-log-column.backtest {
            border-color: rgba(123,44,191,0.3);
        }
        .trade-log-header {
            padding: 12px 15px;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .trade-log-header .badge {
            font-size: 0.75rem;
            padding: 4px 10px;
        }
        .trade-log-header .count {
            margin-left: auto;
            color: #8892b0;
            font-size: 0.85rem;
        }
        .trade-log-list {
            max-height: 500px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }
        .trade-log-list::-webkit-scrollbar {
            width: 6px;
        }
        .trade-log-list::-webkit-scrollbar-track {
            background: transparent;
        }
        .trade-log-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
        .trade-log-item {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .trade-log-item:last-child {
            border-bottom: none;
        }
        .trade-log-item.divergent {
            background: rgba(255,82,82,0.1);
            border-left: 3px solid #ff5252;
        }
        .trade-log-item.matching {
            background: rgba(0,200,83,0.05);
            border-left: 3px solid rgba(0,200,83,0.3);
        }
        .trade-log-time {
            font-size: 0.8rem;
            color: #8892b0;
        }
        .trade-log-action {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .trade-log-action .side-long {
            color: #2196F3;
        }
        .trade-log-action .side-short {
            color: #FF9800;
        }
        .trade-log-action .exit {
            color: #8892b0;
        }
        .trade-log-details {
            display: flex;
            gap: 15px;
            font-size: 0.85rem;
            color: #8892b0;
        }
        .trade-log-details .pnl-positive {
            color: #00c853;
        }
        .trade-log-details .pnl-negative {
            color: #ff5252;
        }
        .divergence-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            background: rgba(255,82,82,0.2);
            color: #ff5252;
        }
        .no-trades-msg {
            padding: 30px;
            text-align: center;
            color: #8892b0;
        }
        @media (max-width: 768px) {
            .trade-logs-container {
                grid-template-columns: 1fr;
            }
        }

        /* Live Test Control Panel Styles */
        .live-test-panel {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(0,212,255,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .live-test-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .live-test-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #00d4ff;
        }
        .live-test-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .live-test-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .live-test-select {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            padding: 12px 15px;
            font-size: 0.95rem;
            min-width: 180px;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%238892b0' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 35px;
        }
        .live-test-select:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .live-test-select option {
            background: #1a1a2e;
            color: #fff;
        }
        .strategy-description {
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: rgba(255,255,255,0.7);
            padding: 8px 12px;
            font-size: 0.8rem;
            line-height: 1.4;
            margin-top: 8px;
            max-width: 350px;
        }
        .btn-start {
            background: rgba(0,200,83,0.2);
            border: 1px solid rgba(0,200,83,0.4);
            color: #00c853;
            padding: 12px 24px;
            font-size: 0.95rem;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-start:hover:not(:disabled) {
            background: rgba(0,200,83,0.3);
            transform: translateY(-1px);
        }
        .btn-start:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-stop {
            background: rgba(255,82,82,0.2);
            border: 1px solid rgba(255,82,82,0.4);
            color: #ff5252;
            padding: 12px 24px;
            font-size: 0.95rem;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-stop:hover:not(:disabled) {
            background: rgba(255,82,82,0.3);
            transform: translateY(-1px);
        }
        .btn-stop:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .live-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            min-width: 200px;
        }
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: none;
        }
        .status-indicator.ready {
            background: #8892b0;
        }
        .status-indicator.running {
            background: #00c853;
            animation: pulse 1.5s infinite;
        }
        .status-indicator.backtesting {
            background: #ffc107;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .status-text {
            font-size: 0.9rem;
            color: #fff;
        }

        /* Real-time Stats Display */
        .live-stats {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,200,83,0.1);
            border: 1px solid rgba(0,200,83,0.3);
            border-radius: 8px;
        }
        .live-stats.active {
            display: block;
        }
        .live-stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }
        .live-stat-item {
            text-align: center;
        }
        .live-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #fff;
        }
        .live-stat-value.positive {
            color: #00c853;
        }
        .live-stat-value.negative {
            color: #ff5252;
        }
        .live-stat-label {
            font-size: 0.8rem;
            color: #8892b0;
            margin-top: 4px;
        }

        @media (max-width: 768px) {
            .live-test-controls {
                flex-direction: column;
                align-items: stretch;
            }
            .live-test-select {
                width: 100%;
            }
            .btn-start, .btn-stop {
                width: 100%;
                justify-content: center;
            }
            .live-status {
                justify-content: center;
            }
            .live-stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Live Trade Feed Styles */
        .live-trade-feed {
            display: none;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(123,44,191,0.4);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow: hidden;
        }
        .live-trade-feed.active {
            display: block;
        }
        .live-trade-feed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .live-trade-feed-title {
            font-size: 1rem;
            font-weight: 600;
            color: #c77dff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .ws-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: #8892b0;
        }
        .ws-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff5252;
        }
        .ws-dot.connected {
            background: #00c853;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .live-trade-list {
            max-height: 220px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }
        .live-trade-list::-webkit-scrollbar {
            width: 6px;
        }
        .live-trade-list::-webkit-scrollbar-track {
            background: transparent;
        }
        .live-trade-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
        .live-trade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            margin-bottom: 6px;
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        .live-trade-item.long {
            border-left: 3px solid #2196F3;
        }
        .live-trade-item.short {
            border-left: 3px solid #FF9800;
        }
        .live-trade-info {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .live-trade-side {
            font-weight: 600;
            font-size: 0.85rem;
        }
        .live-trade-side.long { color: #2196F3; }
        .live-trade-side.short { color: #FF9800; }
        .live-trade-price {
            color: #fff;
            font-size: 0.9rem;
        }
        .live-trade-time {
            color: #8892b0;
            font-size: 0.8rem;
        }
        .no-trades-message {
            text-align: center;
            color: #8892b0;
            padding: 30px;
            font-size: 0.9rem;
        }

        /* Live Market Data Section Styles */
        #live-market-content {
            display: none;
        }
        #live-market-content.active {
            display: block;
        }
        #dashboard-content.hidden {
            display: none !important;
        }
        .market-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .market-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .market-control-label {
            color: #8892b0;
            font-size: 0.9rem;
        }
        .market-select {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        .market-select:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .refresh-btn {
            padding: 8px 16px;
            background: rgba(0,212,255,0.2);
            border: 1px solid rgba(0,212,255,0.3);
            color: #00d4ff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .refresh-btn:hover {
            background: rgba(0,212,255,0.3);
        }
        .refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* REMOVED: Duplicate #live-price-chart-container with hardcoded height - use the one in main styles */
        .market-data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        @media (max-width: 900px) {
            .market-data-grid {
                grid-template-columns: 1fr;
            }
        }
        .orderbook-container {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
        }
        .orderbook-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .orderbook-title {
            font-weight: 600;
            color: #fff;
        }
        .orderbook-spread {
            color: #8892b0;
            font-size: 0.85rem;
        }
        .orderbook-sides {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .orderbook-side {
            font-size: 0.85rem;
        }
        .orderbook-side-header {
            display: flex;
            justify-content: space-between;
            color: #8892b0;
            padding-bottom: 5px;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .orderbook-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            position: relative;
        }
        .orderbook-row .price {
            font-weight: 500;
        }
        .orderbook-row .amount {
            color: #8892b0;
        }
        .orderbook-side.bids .price { color: #00c853; }
        .orderbook-side.asks .price { color: #ff5252; }
        .orderbook-row .bar {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            opacity: 0.15;
        }
        .orderbook-side.bids .bar { background: #00c853; }
        .orderbook-side.asks .bar { background: #ff5252; }
        .trades-container {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        .trades-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .trades-title {
            font-weight: 600;
            color: #fff;
        }
        .trades-table {
            width: 100%;
            font-size: 0.85rem;
        }
        .trades-table th {
            text-align: left;
            color: #8892b0;
            font-weight: 500;
            padding: 5px 0;
        }
        .trades-table td {
            padding: 4px 0;
        }
        .trades-table .side-buy { color: #00c853; }
        .trades-table .side-sell { color: #ff5252; }
        .market-price-display {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-left: auto;
        }
        .current-price {
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
        }
        .price-change {
            font-size: 0.9rem;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: help;
        }
        .price-change .change-label {
            opacity: 0.7;
            font-size: 0.8rem;
        }
        .price-change.positive {
            background: rgba(0,200,83,0.2);
            color: #00c853;
        }
        .price-change.negative {
            background: rgba(255,82,82,0.2);
            color: #ff5252;
        }

        /* === SESSION MANAGEMENT UI === */

        /* Sub-tabs within Your Bots */
        .session-sub-tabs {
            display: flex;
            gap: 0;
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 0 16px;
        }
        .session-sub-tab {
            padding: 12px 20px;
            color: #8b949e;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .session-sub-tab:hover {
            color: #c9d1d9;
            background: rgba(255,255,255,0.03);
        }
        .session-sub-tab.active {
            color: #00d4ff;
            border-bottom-color: #00d4ff;
        }
        .session-sub-tab .tab-count-badge {
            background: #30363d;
            color: #8b949e;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            min-width: 28px; /* Fixed width prevents jumping when count changes */
            text-align: center;
        }
        .session-sub-tab.active .tab-count-badge {
            background: rgba(0,212,255,0.2);
            color: #00d4ff;
        }

        /* Session content panels */
        .session-panel {
            display: none;
            padding: 16px;
            flex-direction: column;
            gap: 12px;
            min-height: 300px;
        }
        .session-panel.active {
            display: flex;
        }

        /* Session toolbar */
        .session-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        .session-filters {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .session-filter-select {
            background: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        .btn-new-session {
            background: #238636;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }
        .btn-new-session:hover {
            background: #2ea043;
        }

        /* Session cards/rows */
        .session-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 100px; /* Prevent collapse when empty/loading */
        }
        .session-card {
            display: grid;
            grid-template-columns: 1fr 120px 100px 100px 80px 140px;
            gap: 16px;
            align-items: center;
            padding: 12px 16px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            transition: background 0.2s, border-color 0.2s;
            min-height: 60px; /* Fixed height prevents layout jumps */
            contain: layout style; /* CSS containment for performance */
        }
        .session-card:hover {
            background: #1c2128;
            border-color: #444c56;
        }
        .session-card.stale-warning {
            border-color: #d29922;
            background: rgba(210,153,34,0.08);
        }
        .session-card.stale-danger {
            border-color: #f85149;
            background: rgba(248,81,73,0.08);
        }

        .session-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .session-name {
            font-size: 14px;
            font-weight: 600;
            color: #c9d1d9;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .session-meta {
            font-size: 11px;
            color: #8b949e;
            display: flex;
            gap: 12px;
        }
        .session-strategy {
            color: #8b949e;
            font-size: 12px;
        }
        .session-params {
            color: #58a6ff;
            font-size: 11px;
            font-weight: 500;
            background: rgba(88, 166, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }
        .session-market {
            font-size: 12px;
            color: #58a6ff;
        }
        .live-data-badge {
            font-size: 10px;
            background: rgba(56, 139, 253, 0.15);
            color: #58a6ff;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
            font-weight: 600;
            animation: pulse-live 2s infinite;
        }
        @keyframes pulse-live {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .session-runtime {
            font-size: 12px;
            color: #8b949e;
            font-family: 'JetBrains Mono', monospace;
        }

        /* Heartbeat indicator */
        .heartbeat-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #8b949e;
        }
        .heartbeat-icon {
            font-size: 12px;
            animation: heartbeat 1.5s ease-in-out infinite;
        }
        .heartbeat-indicator.healthy .heartbeat-icon {
            color: #3fb950;
        }
        .heartbeat-indicator.warning .heartbeat-icon {
            color: #d29922;
            animation: heartbeat-warning 0.8s ease-in-out infinite;
        }
        .heartbeat-indicator.stale .heartbeat-icon {
            color: #f85149;
            animation: heartbeat-danger 0.5s ease-in-out infinite;
        }
        .heartbeat-indicator.dead .heartbeat-icon {
            color: #484f58;
            animation: none;
        }
        /* Service active indicator for scrapers */
        .heartbeat-indicator.service-active .heartbeat-icon {
            color: #3fb950;
            animation: pulse-service 2s ease-in-out infinite;
        }
        .heartbeat-indicator.service-inactive .heartbeat-icon {
            color: #f85149;
            animation: none;
        }
        @keyframes pulse-service {
            0%, 100% { transform: scale(1); opacity: 1; box-shadow: 0 0 0 0 rgba(63, 185, 80, 0.4); }
            50% { transform: scale(1.15); opacity: 0.9; box-shadow: 0 0 8px 2px rgba(63, 185, 80, 0.3); }
        }
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        @keyframes heartbeat-warning {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.15); opacity: 0.7; }
        }
        @keyframes heartbeat-danger {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.6; }
        }

        /* Session status badge */
        .session-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 500;
        }
        .session-status.running {
            background: rgba(63,185,80,0.15);
            color: #3fb950;
        }
        .session-status.stopped {
            background: rgba(139,148,158,0.15);
            color: #8b949e;
        }
        .session-status.completed {
            background: rgba(88,166,255,0.15);
            color: #58a6ff;
        }
        .session-status.failed {
            background: rgba(248,81,73,0.15);
            color: #f85149;
        }
        .session-status.created {
            background: rgba(210,153,34,0.15);
            color: #d29922;
        }
        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
        }
        .session-status.running .status-dot {
            animation: pulse 1.5s infinite;
        }

        /* Session metrics */
        .session-metrics {
            display: flex;
            gap: 16px;
            font-size: 12px;
        }
        .session-metric {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .metric-label {
            color: #8b949e;
            font-size: 10px;
        }
        .metric-value {
            color: #c9d1d9;
            font-weight: 500;
        }
        .metric-value.positive { color: #3fb950; }
        .metric-value.negative { color: #f85149; }

        /* Session actions */
        .session-actions {
            display: flex;
            gap: 8px;
        }
        .btn-session-action {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid;
            transition: all 0.2s;
        }
        .btn-session-stop {
            background: transparent;
            border-color: #f85149;
            color: #f85149;
        }
        .btn-session-stop:hover {
            background: rgba(248,81,73,0.15);
        }
        .btn-session-restart {
            background: transparent;
            border-color: #f0883e;
            color: #f0883e;
        }
        .btn-session-restart:hover {
            background: rgba(240,136,62,0.15);
        }
        .btn-session-backtest {
            background: transparent;
            border-color: #8b5cf6;
            color: #8b5cf6;
        }
        .btn-session-backtest:hover {
            background: rgba(139,92,246,0.15);
        }
        .btn-session-view {
            background: transparent;
            border-color: #30363d;
            color: #8b949e;
        }
        .btn-session-view:hover {
            background: #21262d;
            color: #c9d1d9;
        }
        .btn-session-clone {
            background: transparent;
            border-color: #58a6ff;
            color: #58a6ff;
        }
        .btn-session-clone:hover {
            background: rgba(88,166,255,0.15);
        }
        .btn-session-start {
            background: transparent;
            border-color: #3fb950;
            color: #3fb950;
        }
        .btn-session-start:hover {
            background: rgba(63,185,80,0.15);
        }
        .btn-session-delete {
            background: transparent;
            border-color: #484f58;
            color: #8b949e;
        }
        .btn-session-delete:hover {
            background: rgba(248,81,73,0.15);
            border-color: #f85149;
            color: #f85149;
        }

        /* Empty state */
        .session-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: #8b949e;
            text-align: center;
        }
        .session-empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        .session-empty-text {
            font-size: 14px;
            margin-bottom: 16px;
        }

        /* History pagination */
        .history-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            padding: 16px;
            border-top: 1px solid #30363d;
            background: #161b22;
        }
        .history-pagination .pagination-btn {
            background: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        .history-pagination .pagination-btn:hover:not(:disabled) {
            background: #30363d;
        }
        .history-pagination .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .history-pagination .pagination-info {
            color: #8b949e;
            font-size: 13px;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        .modal-overlay.active {
            display: flex;
        }
        .modal-content {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #30363d;
        }
        .modal-title {
            font-size: 16px;
            font-weight: 600;
            color: #c9d1d9;
        }
        .modal-close {
            background: none;
            border: none;
            color: #8b949e;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .modal-close:hover {
            color: #c9d1d9;
        }
        .modal-body {
            padding: 20px;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid #30363d;
        }

        /* Form styles */
        .form-group {
            margin-bottom: 16px;
        }
        .form-label {
            display: block;
            font-size: 12px;
            color: #8b949e;
            margin-bottom: 6px;
            text-transform: uppercase;
        }
        .form-input, .form-select {
            width: 100%;
            background: #0d1117;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 14px;
        }
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #58a6ff;
        }
        .input-with-suffix {
            display: flex;
            align-items: center;
        }
        .input-with-suffix .form-input {
            border-radius: 6px 0 0 6px;
            border-right: none;
        }
        .input-suffix {
            background: #21262d;
            border: 1px solid #30363d;
            border-left: none;
            border-radius: 0 6px 6px 0;
            padding: 10px 12px;
            color: #8b949e;
            font-size: 14px;
        }
        .form-hint {
            font-size: 11px;
            color: #6e7681;
            margin-top: 4px;
        }
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        .form-hint {
            font-size: 11px;
            color: #8b949e;
            margin-top: 4px;
        }

        /* Strategy params container */
        .strategy-params {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 12px;
            margin-top: 8px;
        }
        .strategy-params-title {
            font-size: 11px;
            color: #8b949e;
            text-transform: uppercase;
            margin-bottom: 12px;
        }

        /* Button styles for modal */
        .btn-modal {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        .btn-modal-cancel {
            background: #21262d;
            color: #c9d1d9;
        }
        .btn-modal-cancel:hover {
            background: #30363d;
        }
        .btn-modal-create {
            background: #238636;
            color: #fff;
        }
        .btn-modal-create:hover {
            background: #2ea043;
        }
        .btn-modal-create:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Session Detail Modal Styles */
        .modal-large {
            max-width: 900px;
        }
        .modal-header-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .detail-session-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .detail-badge {
            background: #21262d;
            color: #8b949e;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            text-transform: uppercase;
        }
        .detail-status {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }
        .detail-status.running { background: rgba(63,185,80,0.2); color: #3fb950; }
        .detail-status.stopped { background: rgba(139,148,158,0.2); color: #8b949e; }
        .detail-status.completed { background: rgba(88,166,255,0.2); color: #58a6ff; }
        .detail-status.failed { background: rgba(248,81,73,0.2); color: #f85149; }
        .modal-tabs {
            display: flex;
            border-bottom: 1px solid #30363d;
            padding: 0 20px;
        }
        .modal-tab {
            background: none;
            border: none;
            color: #8b949e;
            padding: 12px 16px;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }
        .modal-tab:hover { color: #c9d1d9; }
        .modal-tab.active {
            color: #58a6ff;
            border-bottom-color: #58a6ff;
        }
        .modal-body-tabs {
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
        }
        .detail-tab-content {
            display: none;
        }
        .detail-tab-content.active {
            display: block;
        }
        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .detail-section {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 16px;
        }
        .detail-section-wide {
            grid-column: span 2;
        }
        .detail-section-title {
            font-size: 12px;
            color: #8b949e;
            text-transform: uppercase;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #30363d;
        }
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 13px;
        }
        .detail-label { color: #8b949e; }
        .detail-value { color: #c9d1d9; font-family: monospace; }
        .detail-params {
            background: #0d1117;
            color: #8b949e;
            padding: 8px;
            border-radius: 4px;
            font-size: 11px;
            overflow-x: auto;
            white-space: pre-wrap;
            margin: 0;
        }
        .detail-notes {
            width: 100%;
            background: #0d1117;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            min-height: 80px;
            resize: vertical;
        }
        .btn-save-notes {
            margin-top: 8px;
            background: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-save-notes:hover { background: #30363d; }

        /* Metrics grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        .metric-card-label {
            font-size: 11px;
            color: #8b949e;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .metric-card-value {
            font-size: 18px;
            font-weight: 600;
            color: #c9d1d9;
            font-family: monospace;
        }
        .metric-card-value.positive { color: #3fb950; }
        .metric-card-value.negative { color: #f85149; }
        .equity-chart-section {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 16px;
        }

        /* Trades table */
        .trades-table-container {
            max-height: 350px;
            overflow-y: auto;
        }
        .trades-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .trades-table th, .trades-table td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid #30363d;
        }
        .trades-table th {
            background: #161b22;
            color: #8b949e;
            text-transform: uppercase;
            font-weight: 500;
            position: sticky;
            top: 0;
        }
        .trades-table td { color: #c9d1d9; }
        .trades-table .no-data { text-align: center; color: #8b949e; padding: 30px; }
        .trades-table .buy { color: #3fb950; }
        .trades-table .sell { color: #f85149; }
        .trades-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            padding: 12px;
            border-top: 1px solid #30363d;
        }
        .pagination-btn {
            background: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .pagination-btn:hover { background: #30363d; }
        .pagination-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .pagination-info { color: #8b949e; font-size: 12px; }

        /* Logs viewer */
        .logs-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 1px solid #30363d;
            margin-bottom: 12px;
        }
        .logs-filter {
            background: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .logs-autoscroll {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #8b949e;
            font-size: 12px;
        }
        .btn-logs-stream {
            background: #238636;
            border: none;
            color: #fff;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: auto;
        }
        .btn-logs-stream.streaming { background: #f85149; }
        .logs-container {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            padding: 8px;
        }
        .log-line {
            padding: 2px 0;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .log-line.log-info { color: #8b949e; }
        .log-line.log-trade { color: #58a6ff; }
        .log-line.log-warn { color: #d29922; }
        .log-line.log-error { color: #f85149; }

        /* Modal action buttons */
        .btn-modal-action {
            background: #21262d;
            color: #c9d1d9;
        }
        .btn-modal-action:hover { background: #30363d; }
        .btn-modal-clone {
            background: #1f6feb;
            color: #fff;
        }
        .btn-modal-clone:hover { background: #388bfd; }

        /* Responsive adjustments for session cards */
        @media (max-width: 900px) {
            .session-card {
                grid-template-columns: 1fr 1fr;
                gap: 12px;
            }
            .session-actions {
                grid-column: span 2;
                justify-content: flex-end;
            }
        }
        @media (max-width: 600px) {
            .session-card {
                grid-template-columns: 1fr;
            }
            .session-actions {
                grid-column: span 1;
            }
        }

        /* === INLINE SESSION DETAIL VIEW === */
        .btn-back-to-list {
            background: transparent;
            border: 1px solid #30363d;
            color: #58a6ff;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }
        .btn-back-to-list:hover {
            background: #21262d;
        }
        .inline-detail-actions {
            display: flex;
            gap: 8px;
        }
        .inline-detail-content {
            padding: 12px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 12px;
        }
        .inline-detail-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        .inline-detail-header h3 {
            margin: 0;
            color: #f0f6fc;
            font-size: 16px;
        }
        .inline-session-status {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
        }
        .inline-session-status.running { background: #238636; color: #fff; }
        .inline-session-status.stopped { background: #6e7681; color: #fff; }
        .inline-session-status.completed { background: #1f6feb; color: #fff; }
        .inline-session-status.failed { background: #da3633; color: #fff; }
        .inline-detail-meta {
            display: flex;
            gap: 16px;
            color: #8b949e;
            font-size: 12px;
            margin-bottom: 16px;
        }
        .inline-metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }
        .inline-metric {
            background: #21262d;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        .inline-metric-label {
            display: block;
            color: #8b949e;
            font-size: 10px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .inline-metric-value {
            display: block;
            color: #f0f6fc;
            font-size: 14px;
            font-weight: 600;
        }
        .inline-metric-value.positive { color: #3fb950; }
        .inline-metric-value.negative { color: #f85149; }
        /* Two-column layout: Equity chart left (75%), Trades right (25%) */
        .inline-equity-trades-row {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }
        @media (max-width: 768px) {
            .inline-equity-trades-row {
                grid-template-columns: 1fr;
            }
        }
        .inline-equity-section {
            background: #161b22;
            border-radius: 8px;
            padding: 12px;
            min-height: 200px;
        }
        .inline-equity-section h4 {
            margin: 0 0 8px 0;
            color: #8b949e;
            font-size: 11px;
            text-transform: uppercase;
        }
        .inline-trades-section {
            background: #161b22;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            max-height: 250px;
        }
        .inline-trades-section h4 {
            margin: 0;
            padding: 10px 12px;
            color: #8b949e;
            font-size: 11px;
            text-transform: uppercase;
            border-bottom: 1px solid #30363d;
            flex-shrink: 0;
        }
        .inline-trades-list {
            font-family: monospace;
            font-size: 11px;
            overflow-y: auto;
            flex: 1;
        }
        .inline-trade-row {
            display: grid;
            grid-template-columns: 70px 45px 70px 50px 70px;
            gap: 6px;
            padding: 5px 10px;
            border-bottom: 1px solid #21262d;
        }
        .inline-trade-row:nth-child(even) { background: rgba(255,255,255,0.02); }
        .inline-trade-row.new-trade {
            animation: flash-new-trade 1s ease-out;
        }
        @keyframes flash-new-trade {
            0% { background: rgba(63, 185, 80, 0.4); }
            100% { background: transparent; }
        }

        /* Logs section - flex to fill remaining space */
        .inline-logs-section {
            background: #161b22;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 200px;
        }
        .inline-logs-section h4 {
            margin: 0;
            padding: 10px 12px;
            color: #8b949e;
            font-size: 11px;
            text-transform: uppercase;
            border-bottom: 1px solid #30363d;
            flex-shrink: 0;
        }
        .inline-logs-list {
            font-family: monospace;
            font-size: 11px;
            padding: 8px 12px;
            flex-grow: 1;
            /* No scrollbar - logs expand page downward */
        }
        .inline-log-row {
            padding: 4px 0;
            border-bottom: 1px solid #21262d;
            word-break: break-word;
        }
        .inline-log-row:last-child { border-bottom: none; }
        .inline-log-row.error { color: #f85149; }
        .inline-log-row.warn { color: #d29922; }
        .inline-log-row.info { color: #58a6ff; }
        .inline-log-row.new-log {
            animation: flash-new-log 1s ease-out;
        }
        @keyframes flash-new-log {
            0% { background: rgba(88, 166, 255, 0.3); }
            100% { background: transparent; }
        }
        .inline-empty {
            color: #6e7681;
            text-align: center;
            padding: 24px;
        }
        /* Make session cards clickable */
        .session-card.clickable {
            cursor: pointer;
        }
        .session-card.clickable:hover {
            border-color: #58a6ff;
        }

        /* === FOOTER === */
        .dashboard-footer {
            margin-top: 40px;
            padding: 24px 16px;
            background: #161b22;
            border-top: 1px solid #30363d;
            text-align: center;
            color: #8b949e;
            font-size: 12px;
        }
        .footer-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        .footer-logo {
            font-size: 16px;
            font-weight: 600;
            color: #c9d1d9;
        }
        .footer-links {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .footer-links a {
            color: #58a6ff;
            text-decoration: none;
        }
        .footer-links a:hover {
            text-decoration: underline;
        }
        .footer-copyright {
            margin-top: 8px;
            font-size: 11px;
            color: #6e7681;
        }
    </style>
</head>
<body>
    <!-- Error Toast for API failures -->
    <div id="error-toast" class="error-toast">
        <button class="error-toast-close" onclick="hideErrorToast()">&times;</button>
        <div class="error-toast-title"> <span id="error-toast-title">Error</span></div>
        <div class="error-toast-message" id="error-toast-message">An error occurred</div>
    </div>

    <!-- JS Error Panel - Shows caught JavaScript errors -->
    <div id="js-error-panel" class="js-error-panel" style="display: none;">
        <div class="js-error-header">
            <span> JavaScript Errors</span>
            <button onclick="document.getElementById('js-error-panel').style.display='none'; jsErrorLog.length=0;">&times;</button>
        </div>
        <div id="js-error-list" class="js-error-list"></div>
    </div>

    <!-- BitMEX-Style Header -->
    <div class="trading-header">
        <div class="instrument-dropdown" id="instrument-dropdown">
            <span class="instrument-name" id="header-instrument">BTCUSD</span>
            <span class="instrument-type">Perpetual</span>
            <span style="color: #8b949e;"></span>
        </div>
        <div class="instrument-badges">
            <span class="badge-sm badge-btc">BTC</span>
            <span class="badge-sm badge-leverage">100X</span>
        </div>
        <div class="price-section">
            <div class="price-main" id="header-price">
                <span id="price-value">--</span>
                <span class="price-arrow" id="price-arrow"></span>
            </div>
            <div class="price-change" id="header-change">-0.00%</div>
        </div>
        <div class="header-stats">
            <div class="header-stat">
                <span class="header-stat-label">Mark Price</span>
                <span class="header-stat-value" id="header-mark">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">24H Volume</span>
                <span class="header-stat-value" id="header-volume">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">Funding Rate</span>
                <span class="header-stat-value" id="header-funding">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">Next Funding</span>
                <span class="header-stat-value" id="header-next-funding">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">High Price</span>
                <span class="header-stat-value positive" id="header-high">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">Low Price</span>
                <span class="header-stat-value negative" id="header-low">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">Open Interest</span>
                <span class="header-stat-value" id="header-oi">--</span>
            </div>
        </div>
    </div>

    <!-- Main Trading Layout -->
    <div class="trading-main">
        <!-- Chart Section (Left ~70%) -->
        <div class="chart-section">
            <div class="chart-toolbar">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <select id="market-selector" class="period-btn" style="min-width: 140px;">
                        <option value="xbtusd">BTC/USD</option>
                        <option value="ethusd">ETH/USD</option>
                        <option value="solusd">SOL/USD</option>
                        <option value="xrpusd">XRP/USD</option>
                    </select>
                    <div class="period-dropdown">
                        <button class="period-btn" id="period-btn">
                            <span id="period-label">5m</span>
                            <span></span>
                        </button>
                        <div class="period-menu" id="period-menu">
                            <div class="period-option" data-period="1m">1m</div>
                            <div class="period-option active" data-period="5m">5m</div>
                            <div class="period-option" data-period="15m">15m</div>
                            <div class="period-option" data-period="1h">1h</div>
                            <div class="period-option" data-period="4h">4h</div>
                            <div class="period-option" data-period="1d">1D</div>
                        </div>
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="color: #8b949e; font-size: 11px;" id="candle-count">-- candles</span>
                    <span class="instrument-badge" id="live-indicator"> LIVE</span>
                </div>
            </div>
            <!-- OHLC Display -->
            <div class="ohlc-display">
                <div class="ohlc-item">
                    <span class="ohlc-label">O</span>
                    <span class="ohlc-value" id="ohlc-open">--</span>
                </div>
                <div class="ohlc-item">
                    <span class="ohlc-label">H</span>
                    <span class="ohlc-value" id="ohlc-high">--</span>
                </div>
                <div class="ohlc-item">
                    <span class="ohlc-label">L</span>
                    <span class="ohlc-value" id="ohlc-low">--</span>
                </div>
                <div class="ohlc-item">
                    <span class="ohlc-label">C</span>
                    <span class="ohlc-value" id="ohlc-close">--</span>
                </div>
                <div class="ohlc-item" style="margin-left: 12px;">
                    <span class="ohlc-label">Vol</span>
                    <span class="ohlc-value" id="ohlc-volume">--</span>
                </div>
            </div>
            <div class="chart-container-pro">
                <div id="live-price-chart-container"></div>
            </div>
            <!-- Bottom Period Selector -->
            <div class="chart-period-bar">
                <button class="chart-period-btn" data-range="1y">1y</button>
                <button class="chart-period-btn" data-range="1m">1m</button>
                <button class="chart-period-btn" data-range="5d">5d</button>
                <button class="chart-period-btn active" data-range="1d">1d</button>
                <button class="chart-period-btn" data-range="5h">5h</button>
            </div>
        </div>

        <!-- Right Panel (Orderbook + Trades) -->
        <div class="right-panel">
            <!-- Orderbook - shrinks to fit, never scrolls -->
            <div class="panel-section orderbook-section">
                <div class="panel-header">
                    <span>ORDER BOOK</span>
                    <span id="orderbook-spread-header">SPREAD: --</span>
                </div>
                <div class="panel-content" id="orderbook-panel">
                    <div class="orderbook-row header">
                        <span class="ob-price">Price</span>
                        <span class="ob-size">Size</span>
                        <span class="ob-total">Total</span>
                    </div>
                    <div id="orderbook-asks-pro"></div>
                    <div class="spread-row" id="spread-row">Spread: -- (0.00%)</div>
                    <div id="orderbook-bids-pro"></div>
                </div>
            </div>

            <!-- Recent Trades - fills remaining space, has scrollbar -->
            <div class="panel-section trades-section">
                <div class="panel-header">
                    <span>RECENT TRADES</span>
                    <span id="trades-count">0</span>
                </div>
                <div class="panel-content" id="trades-panel">
                    <div class="trade-row header">
                        <span class="trade-time">Time</span>
                        <span class="trade-side">Side</span>
                        <span class="trade-price">Price</span>
                        <span class="trade-size">Size</span>
                    </div>
                    <div id="recent-trades-pro"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Tab Bar -->
    <div class="tab-bar">
        <div class="tab-item active" data-tab="bots">Your Bots</div>
    </div>

    <!-- Tab Contents -->

    <!-- YOUR BOTS TAB -->
    <div id="tab-bots" class="tab-content active">
        <!-- Sub-tabs for Running Sessions / Scrapers / History -->
        <div class="session-sub-tabs">
            <div class="session-sub-tab active" data-panel="running">
                 Running Sessions
                <span class="tab-count-badge" id="running-count">0</span>
            </div>
            <div class="session-sub-tab" data-panel="scrapers">
                 Scrapers
                <span class="tab-count-badge" id="scrapers-count">0</span>
            </div>
            <div class="session-sub-tab" data-panel="history">
                 History
                <span class="tab-count-badge" id="history-count">0</span>
            </div>
        </div>

        <!-- RUNNING SESSIONS PANEL -->
        <div id="panel-running" class="session-panel active">
            <div class="session-toolbar">
                <div class="session-filters">
                    <select class="session-filter-select" id="filter-market-running">
                        <option value="">All Markets</option>
                        <option value="XBTUSD">XBTUSD</option>
                        <option value="ETHUSD">ETHUSD</option>
                        <option value="SOLUSD">SOLUSD</option>
                    </select>
                    <select class="session-filter-select" id="filter-strategy-running">
                        <option value="">All Strategies</option>
                    </select>
                </div>
                <button class="btn-new-session" id="btn-new-session">
                    + New Session
                </button>
            </div>

            <div class="session-list" id="running-sessions-list">
                <!-- Running sessions will be populated here -->
                <div class="session-empty" id="running-empty">
                    <div class="session-empty-icon"></div>
                    <div class="session-empty-text">No running sessions</div>
                    <button class="btn-new-session" onclick="openNewSessionModal()">+ Start a Session</button>
                </div>
            </div>
        </div>

        <!-- SCRAPERS PANEL -->
        <div id="panel-scrapers" class="session-panel">
            <div class="session-toolbar">
                <div class="session-filters">
                    <select class="session-filter-select" id="filter-market-scrapers">
                        <option value="">All Markets</option>
                        <option value="XBTUSD">XBTUSD</option>
                        <option value="ETHUSD">ETHUSD</option>
                        <option value="SOLUSD">SOLUSD</option>
                    </select>
                </div>
                <button class="btn-new-session" onclick="openNewSessionModal('scraper')">
                    + New Scraper
                </button>
            </div>

            <div class="session-list" id="scrapers-list">
                <!-- Scrapers will be populated here -->
                <div class="session-empty" id="scrapers-empty">
                    <div class="session-empty-icon"></div>
                    <div class="session-empty-text">No active scrapers</div>
                    <button class="btn-new-session" onclick="openNewSessionModal('scraper')">+ Start a Scraper</button>
                </div>
            </div>
        </div>

        <!-- HISTORY PANEL -->
        <div id="panel-history" class="session-panel">
            <div class="session-toolbar">
                <div class="session-filters">
                    <select class="session-filter-select" id="filter-type-history">
                        <option value="">All Types</option>
                        <option value="test">Test</option>
                        <option value="backtest">Backtest</option>
                        <option value="scraper">Scraper</option>
                    </select>
                    <select class="session-filter-select" id="filter-market-history">
                        <option value="">All Markets</option>
                        <option value="XBTUSD">XBTUSD</option>
                        <option value="ETHUSD">ETHUSD</option>
                        <option value="SOLUSD">SOLUSD</option>
                    </select>
                    <select class="session-filter-select" id="filter-status-history">
                        <option value="">All Statuses</option>
                        <option value="completed">Completed</option>
                        <option value="stopped">Stopped</option>
                        <option value="failed">Failed</option>
                    </select>
                </div>
            </div>

            <div class="session-list" id="history-list">
                <!-- History will be populated here -->
                <div class="session-empty" id="history-empty">
                    <div class="session-empty-icon"></div>
                    <div class="session-empty-text">No session history</div>
                </div>
            </div>
            <div class="history-pagination" id="history-pagination">
                <button class="pagination-btn" id="history-prev-btn" onclick="loadHistoryPage('prev')">&laquo; Previous</button>
                <span class="pagination-info" id="history-page-info">Page 1 of 1</span>
                <button class="pagination-btn" id="history-next-btn" onclick="loadHistoryPage('next')">Next &raquo;</button>
            </div>
        </div>

        <!-- INLINE SESSION DETAIL VIEW -->
        <div id="inline-session-detail" class="session-panel" style="display: none;">
            <div class="session-toolbar">
                <button class="btn-back-to-list" onclick="hideInlineDetail()">
                     Back to Sessions
                </button>
                <div class="inline-detail-actions">
                    <button class="btn-session-action btn-session-backtest" id="inline-backtest-btn" style="display: none;">Launch Backtest</button>
                    <button class="btn-session-action btn-session-restart" id="inline-restart-btn">Restart</button>
                    <button class="btn-session-action btn-session-stop" id="inline-stop-btn">Stop</button>
                </div>
            </div>
            <div class="inline-detail-content">
                <div class="inline-detail-header">
                    <h3 id="inline-session-name">Session Name</h3>
                    <span class="inline-session-status" id="inline-session-status">running</span>
                </div>
                <div class="inline-detail-meta">
                    <span id="inline-session-market">XBTUSD</span>
                    <span id="inline-session-strategy">TestBot</span>
                    <span id="inline-session-runtime">00:00:00</span>
                    <span id="inline-session-params" class="session-params" style="display: none;"></span>
                </div>

                <!-- Metrics Summary -->
                <div class="inline-metrics-grid">
                    <div class="inline-metric">
                        <span class="inline-metric-label">Trades</span>
                        <span class="inline-metric-value" id="inline-trades">0</span>
                    </div>
                    <div class="inline-metric">
                        <span class="inline-metric-label">P&L</span>
                        <span class="inline-metric-value" id="inline-pnl">$0.00</span>
                    </div>
                    <div class="inline-metric">
                        <span class="inline-metric-label">Win Rate</span>
                        <span class="inline-metric-value" id="inline-winrate">0%</span>
                    </div>
                    <div class="inline-metric">
                        <span class="inline-metric-label">Max DD</span>
                        <span class="inline-metric-value" id="inline-maxdd">$0</span>
                    </div>
                </div>

                <!-- Equity Chart (left) + Trades (right) -->
                <div class="inline-equity-trades-row">
                    <div class="inline-equity-section">
                        <h4>Equity Curve</h4>
                        <div id="inline-equity-chart" style="height: 180px; width: 100%;"></div>
                    </div>
                    <div class="inline-trades-section">
                        <h4>Recent Trades</h4>
                        <div class="inline-trades-list" id="inline-trades-list">
                            <div class="inline-empty">No trades yet</div>
                        </div>
                    </div>
                </div>

                <!-- Logs below (extends down, no inner scrollbar) -->
                <div class="inline-logs-section">
                    <h4>Session Logs</h4>
                    <div class="inline-logs-list" id="inline-logs-list">
                        <div class="inline-empty">No logs available</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Legacy compatibility: keep old elements hidden -->
        <div style="display: none;">
            <div class="running-bot-stats" id="test-stats-pro">
                <div class="test-stat">
                    <span class="stat-label">Duration</span>
                    <span class="stat-value" id="test-duration-pro">00:00:00</span>
                </div>
                <div class="test-stat">
                    <span class="stat-label">Trades</span>
                    <span class="stat-value" id="test-trades-pro">0</span>
                </div>
                <div class="test-stat">
                    <span class="stat-label">P&L</span>
                    <span class="stat-value" id="test-pnl-pro">$0.00</span>
                </div>
            </div>
            <select id="strategy-selector-pro">
                <option value="none">Select Strategy...</option>
            </select>
            <button id="btn-start-test-pro"></button>
            <button id="btn-stop-backtest-pro"></button>
            <div id="metric-winrate">--</div>
            <div id="metric-pf">--</div>
            <div id="metric-pnl">--</div>
            <div id="metric-trades">--</div>
            <div id="metric-avgtrade">--</div>
            <div id="metric-dd">--</div>
            <div id="equity-curve-pro"></div>
            <div id="divergence-badge-pro"></div>
            <div id="test-log-count">0 trades</div>
            <div id="test-log-list"></div>
            <div id="backtest-log-count">0 trades</div>
            <div id="backtest-log-list"></div>
        </div>
    </div>

    <!-- CREATE NEW SESSION MODAL -->
    <div class="modal-overlay" id="new-session-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Create New Session</h3>
                <button class="modal-close" onclick="closeNewSessionModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Session Type</label>
                    <select class="form-select" id="new-session-type">
                        <option value="test">Live Test</option>
                        <option value="backtest">Backtest</option>
                        <option value="scraper">Scraper</option>
                    </select>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Market</label>
                        <select class="form-select" id="new-session-market">
                            <option value="XBTUSD">XBTUSD</option>
                            <option value="ETHUSD">ETHUSD</option>
                            <option value="SOLUSD">SOLUSD</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Strategy</label>
                        <select class="form-select" id="new-session-strategy">
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Session Name (optional)</label>
                    <input type="text" class="form-input" id="new-session-name" placeholder="Auto-generated if empty">
                </div>

                <!-- Backtest date range (shown only for backtest type) -->
                <div class="form-row" id="backtest-range-fields" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">Start Date</label>
                        <input type="datetime-local" class="form-input" id="new-session-start">
                    </div>
                    <div class="form-group">
                        <label class="form-label">End Date</label>
                        <input type="datetime-local" class="form-input" id="new-session-end">
                    </div>
                </div>

                <!-- Fee configuration (shown for test/backtest, hidden for scraper) -->
                <div class="form-row" id="fee-config-fields">
                    <div class="form-group">
                        <label class="form-label">Maker Fee (rebate)</label>
                        <div class="input-with-suffix">
                            <input type="number" class="form-input" id="new-session-maker-fee" value="-0.025" step="0.001">
                            <span class="input-suffix">%</span>
                        </div>
                        <small class="form-hint">Negative = rebate for adding liquidity</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Taker Fee</label>
                        <div class="input-with-suffix">
                            <input type="number" class="form-input" id="new-session-taker-fee" value="0.075" step="0.001">
                            <span class="input-suffix">%</span>
                        </div>
                        <small class="form-hint">Fee for taking liquidity</small>
                    </div>
                </div>

                <!-- Strategy params (dynamic based on strategy) -->
                <div id="strategy-params-container" class="strategy-params" style="display: none;">
                    <div class="strategy-params-title">Strategy Parameters</div>
                    <div id="strategy-params-fields">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-modal btn-modal-cancel" onclick="closeNewSessionModal()">Cancel</button>
                <button class="btn-modal btn-modal-create" id="btn-create-session" onclick="createSession()">Create Session</button>
            </div>
        </div>
    </div>

    <!-- SESSION DETAIL MODAL -->
    <div class="modal-overlay" id="session-detail-modal">
        <div class="modal-content modal-large">
            <div class="modal-header">
                <div class="modal-header-info">
                    <h3 class="modal-title" id="detail-session-name">Session Details</h3>
                    <div class="detail-session-meta">
                        <span class="detail-badge" id="detail-session-type">test</span>
                        <span class="detail-badge" id="detail-session-market">XBTUSD</span>
                        <span class="detail-badge" id="detail-session-strategy">DivergeBot</span>
                        <span class="detail-status" id="detail-session-status">running</span>
                    </div>
                </div>
                <button class="modal-close" onclick="closeSessionDetailModal()">&times;</button>
            </div>
            <div class="modal-tabs">
                <button class="modal-tab active" data-tab="info" onclick="switchDetailTab('info')">Info</button>
                <button class="modal-tab" data-tab="metrics" onclick="switchDetailTab('metrics')">Metrics</button>
                <button class="modal-tab" data-tab="trades" onclick="switchDetailTab('trades')">Trades</button>
                <button class="modal-tab" data-tab="logs" onclick="switchDetailTab('logs')">Logs</button>
            </div>
            <div class="modal-body modal-body-tabs">
                <!-- INFO TAB -->
                <div class="detail-tab-content active" id="tab-info">
                    <div class="detail-grid">
                        <div class="detail-section">
                            <h4 class="detail-section-title">Session Information</h4>
                            <div class="detail-row"><span class="detail-label">ID:</span><span class="detail-value" id="detail-id">-</span></div>
                            <div class="detail-row"><span class="detail-label">Name:</span><span class="detail-value" id="detail-name">-</span></div>
                            <div class="detail-row"><span class="detail-label">Type:</span><span class="detail-value" id="detail-type">-</span></div>
                            <div class="detail-row"><span class="detail-label">Market:</span><span class="detail-value" id="detail-market">-</span></div>
                            <div class="detail-row"><span class="detail-label">Strategy:</span><span class="detail-value" id="detail-strategy">-</span></div>
                            <div class="detail-row"><span class="detail-label">Status:</span><span class="detail-value" id="detail-status">-</span></div>
                        </div>
                        <div class="detail-section">
                            <h4 class="detail-section-title">Timing</h4>
                            <div class="detail-row"><span class="detail-label">Created:</span><span class="detail-value" id="detail-created">-</span></div>
                            <div class="detail-row"><span class="detail-label">Started:</span><span class="detail-value" id="detail-started">-</span></div>
                            <div class="detail-row"><span class="detail-label">Completed:</span><span class="detail-value" id="detail-completed">-</span></div>
                            <div class="detail-row"><span class="detail-label">Duration:</span><span class="detail-value" id="detail-duration">-</span></div>
                        </div>
                        <div class="detail-section detail-section-wide">
                            <h4 class="detail-section-title">Strategy Parameters</h4>
                            <pre class="detail-params" id="detail-params">{}</pre>
                        </div>
                        <div class="detail-section detail-section-wide">
                            <h4 class="detail-section-title">Notes</h4>
                            <textarea class="detail-notes" id="detail-notes" placeholder="Add notes..."></textarea>
                            <button class="btn-save-notes" onclick="saveSessionNotes()">Save Notes</button>
                        </div>
                    </div>
                </div>
                <!-- METRICS TAB -->
                <div class="detail-tab-content" id="tab-metrics">
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-card-label">Total P&L</div>
                            <div class="metric-card-value" id="metric-pnl">$0.00</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-card-label">Total Trades</div>
                            <div class="metric-card-value" id="metric-trades">0</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-card-label">Win Rate</div>
                            <div class="metric-card-value" id="metric-winrate">0%</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-card-label">Avg Win</div>
                            <div class="metric-card-value" id="metric-avgwin">$0.00</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-card-label">Avg Loss</div>
                            <div class="metric-card-value" id="metric-avgloss">$0.00</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-card-label">Max Drawdown</div>
                            <div class="metric-card-value" id="metric-drawdown">$0.00</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-card-label">Profit Factor</div>
                            <div class="metric-card-value" id="metric-pf">0.00</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-card-label">Sharpe Ratio</div>
                            <div class="metric-card-value" id="metric-sharpe">0.00</div>
                        </div>
                    </div>
                    <div class="equity-chart-section">
                        <h4 class="detail-section-title">Equity Curve</h4>
                        <div id="detail-equity-chart" style="height: 250px;"></div>
                    </div>
                </div>
                <!-- TRADES TAB -->
                <div class="detail-tab-content" id="tab-trades">
                    <div class="trades-table-container">
                        <table class="trades-table">
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Action</th>
                                    <th>Side</th>
                                    <th>Price</th>
                                    <th>Size</th>
                                    <th>P&L</th>
                                    <th>Reason</th>
                                </tr>
                            </thead>
                            <tbody id="detail-trades-body">
                                <tr><td colspan="7" class="no-data">No trades yet</td></tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="trades-pagination" id="trades-pagination">
                        <button class="pagination-btn" onclick="loadTradesPage('prev')">&laquo; Prev</button>
                        <span class="pagination-info" id="trades-page-info">Page 1</span>
                        <button class="pagination-btn" onclick="loadTradesPage('next')">Next &raquo;</button>
                    </div>
                </div>
                <!-- LOGS TAB -->
                <div class="detail-tab-content" id="tab-logs">
                    <div class="logs-controls">
                        <select class="logs-filter" id="logs-level-filter" onchange="filterLogs()">
                            <option value="">All Levels</option>
                            <option value="INFO">INFO</option>
                            <option value="TRADE">TRADE</option>
                            <option value="WARN">WARN</option>
                            <option value="ERROR">ERROR</option>
                        </select>
                        <label class="logs-autoscroll">
                            <input type="checkbox" id="logs-autoscroll-check" checked> Auto-scroll
                        </label>
                        <button class="btn-logs-stream" id="btn-logs-stream" onclick="toggleLogStream()"> Start Stream</button>
                    </div>
                    <div class="logs-container" id="detail-logs-container">
                        <div class="log-line log-info">Logs will appear here...</div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-modal btn-modal-cancel" onclick="closeSessionDetailModal()">Close</button>
                <button class="btn-modal btn-modal-action" onclick="viewSessionOnChart()">View on Chart</button>
                <button class="btn-modal btn-modal-clone" onclick="cloneCurrentSession()">Clone Session</button>
            </div>
        </div>
    </div>

    <!-- Hidden legacy controls for JS compatibility -->
    <div style="display: none;">
        <select id="session-selector">
            <option value="backtest">Backtest</option>
            <option value="test">Test</option>
        </select>
        <select id="bot-selector">
            <option value="DivergeBot">DivergeBot</option>
        </select>
        <select id="date-selector">
            <option value="all">All</option>
        </select>
        <select id="candle-period-selector">
            <option value="5m">5m</option>
        </select>
        <select id="market-period-selector">
            <option value="5m">5m</option>
        </select>
    </div>

    <div class="container" style="display: none;">

        <!-- Live Test Control Panel -->
        <div class="live-test-panel" id="live-test-panel">
            <div class="live-test-header">
                <span class="live-test-title"> Live Test Control</span>
                <span class="live-test-badge badge-info" title="Backend API that manages bot processes and data collection">API Connected</span>
            </div>
            <div class="live-test-controls">
                <select id="strategy-selector" class="live-test-select">
                    <option value="none" selected> Live Market Only</option>
                    <option value="TestBot">TestBot</option>
                    <option value="DivergeBot">DivergeBot</option>
                    <option value="SazBot">SazBot</option>
                    <option value="SDBot">SDBot</option>
                    <option value="PairTradeBot">PairTradeBot</option>
                    <option value="DevDistStatBot">DevDistStatBot</option>
                </select>
                <div id="strategy-description" class="strategy-description" title="Strategy description">
                    Live market data only. Select a strategy to view trade overlays and backtest results.
                </div>
                <button id="btn-start-test" class="btn-start disabled" disabled>
                    <span></span> Start Live Test
                </button>
                <script>
                    // Immediately attach click handler after button is created
                    (function() {
                        var btn = document.getElementById('btn-start-test');
                        if (btn) {
                            btn.addEventListener('click', function() {
                                console.log('[BUTTON CLICK] Handler fired, calling startLiveTest()');
                                this.style.border = '3px solid lime';
                                this.innerHTML = '<span></span> Starting...';
                                // Call the actual function (defined later in script)
                                if (typeof startLiveTest === 'function') {
                                    startLiveTest();
                                } else {
                                    console.error('[BUTTON CLICK] startLiveTest not defined yet!');
                                }
                            });
                            console.log('[INIT] Button click handler attached immediately');
                        }
                    })();
                </script>
                <button id="btn-stop-backtest" class="btn-stop" disabled>
                    <span></span> Stop & Backtest
                </button>
                <div class="live-status">
                    <div id="status-indicator" class="status-indicator ready"></div>
                    <span id="status-text" class="status-text">Ready</span>
                </div>
            </div>
            <!-- Real-time stats (shown when test is running) -->
            <div id="live-stats" class="live-stats">
                <div class="live-stats-grid">
                    <div class="live-stat-item">
                        <div id="live-trades" class="live-stat-value">0</div>
                        <div class="live-stat-label">Trades</div>
                    </div>
                    <div class="live-stat-item">
                        <div id="live-pnl" class="live-stat-value">$0.00</div>
                        <div class="live-stat-label">Running P&L</div>
                    </div>
                    <div class="live-stat-item">
                        <div id="live-duration" class="live-stat-value">00:00</div>
                        <div class="live-stat-label">Duration</div>
                    </div>
                    <div class="live-stat-item">
                        <div id="live-strategy" class="live-stat-value">-</div>
                        <div class="live-stat-label">Strategy</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Live Trade Feed (WebSocket-powered) -->
        <div id="live-trade-feed" class="live-trade-feed">
            <div class="live-trade-feed-header">
                <span class="live-trade-feed-title">
                    <span></span> Live Trade Feed
                </span>
                <div class="ws-status">
                    <div id="ws-dot" class="ws-dot"></div>
                    <span id="ws-status-text">Disconnected</span>
                </div>
            </div>
            <div id="live-trade-list" class="live-trade-list">
                <div class="no-trades-message">Waiting for trades...</div>
            </div>
        </div>

        <!-- Loading/Error State -->
        <div id="loading-state" class="card full-width" style="margin-bottom: 20px;">
            <div class="loading">Loading backtest data...</div>
        </div>

        <!-- Session Comparison View -->
        <div id="comparison-container" class="comparison-container">
            <div class="comparison-header">
                <span class="comparison-title"> Session Comparison: TEST vs BACKTEST</span>
                <span id="parity-status" class="parity-badge match"> PARITY ACHIEVED</span>
            </div>

            <div class="comparison-grid">
                <!-- Test Session Column -->
                <div class="session-column test">
                    <div class="session-label">
                        <span class="badge badge-info">TEST</span>
                        <span class="session-name">Test Session</span>
                    </div>
                    <div id="test-metrics">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Backtest Session Column -->
                <div class="session-column backtest">
                    <div class="session-label">
                        <span class="badge badge-real">BACKTEST</span>
                        <span class="session-name">Backtest Session</span>
                    </div>
                    <div id="backtest-metrics">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>

            <div class="comparison-summary">
                <div class="summary-title">Comparison Summary</div>
                <div class="summary-grid">
                    <div class="summary-item">
                        <div id="matching-count" class="number positive">0</div>
                        <div class="label">Matching Metrics</div>
                    </div>
                    <div class="summary-item">
                        <div id="different-count" class="number negative">0</div>
                        <div class="label">Different Metrics</div>
                    </div>
                    <div class="summary-item">
                        <div id="parity-percent" class="number positive">0%</div>
                        <div class="label">Parity Rate</div>
                    </div>
                </div>
            </div>

            <!-- Side-by-Side Trade Logs Comparison -->
            <div class="trade-logs-comparison">
                <div class="trade-logs-header">
                    <div class="trade-logs-title">
                         Trade Decision Logs
                        <span id="divergence-count" class="divergence-indicator" style="display: none;">0 divergences</span>
                    </div>
                    <div class="trade-logs-filters">
                        <button class="filter-btn active" data-filter="all">All Trades</button>
                        <button class="filter-btn" data-filter="divergent">Divergences Only</button>
                        <button class="filter-btn" data-filter="matching">Matching Only</button>
                    </div>
                </div>
                <div class="trade-logs-container">
                    <!-- Test Trades Column -->
                    <div class="trade-log-column test">
                        <div class="trade-log-header">
                            <span class="badge badge-info">TEST</span>
                            <span>Live Test Trades</span>
                            <span id="test-trades-count" class="count">0 trades</span>
                        </div>
                        <div id="test-trades-log" class="trade-log-list">
                            <div class="no-trades-msg">No trades available</div>
                        </div>
                    </div>
                    <!-- Backtest Trades Column -->
                    <div class="trade-log-column backtest">
                        <div class="trade-log-header">
                            <span class="badge badge-real">BACKTEST</span>
                            <span>Backtest Trades</span>
                            <span id="backtest-trades-count" class="count">0 trades</span>
                        </div>
                        <div id="backtest-trades-log" class="trade-log-list">
                            <div class="no-trades-msg">No trades available</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Live Market Data Section -->
        <div id="live-market-content" class="active" style="display: block;">
            <div class="market-controls">
                <div class="market-control-group">
                    <span class="market-control-label">Market:</span>
                    <select id="market-selector-secondary" class="market-select">
                        <option value="xbtusd">BTC/USD (XBTUSD)</option>
                        <option value="ethusd">ETH/USD (ETHUSD)</option>
                        <option value="solusd">SOL/USD (SOLUSD)</option>
                        <option value="xrpusd">XRP/USD (XRPUSD)</option>
                        <option value="dogeusd">DOGE/USD (DOGEUSD)</option>
                    </select>
                </div>
                <div class="market-control-group">
                    <span class="market-control-label">Period:</span>
                    <select id="market-period-selector" class="market-select">
                        <option value="1m">1 Minute</option>
                        <option value="5m" selected>5 Minutes</option>
                        <option value="15m">15 Minutes</option>
                        <option value="1h">1 Hour</option>
                        <option value="4h">4 Hours</option>
                        <option value="1d">1 Day</option>
                        <option value="1w">1 Week</option>
                    </select>
                </div>
                <button id="refresh-market-btn" class="refresh-btn"> Refresh</button>
                <div class="market-price-display">
                    <span id="current-market-price" class="current-price">--</span>
                    <span id="price-change-badge" class="price-change" title="Price change from first to last candle in loaded data">
                        <span class="change-label">Period:</span> <span id="price-change-value">--</span>
                    </span>
                </div>
            </div>

            <!-- Live Price Chart -->
            <div class="card full-width" style="margin-bottom: 20px;">
                <div class="card-header">
                    <span class="card-title" id="live-chart-title">BTC/USD Live Price</span>
                    <span class="badge badge-info">LIVE DATA</span>
                </div>
                <div id="live-price-chart-container"></div>
                <div class="chart-legend" id="price-chart-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #26a69a;"></div>
                        <span>Price Candles</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2962FF;"></div>
                        <span>Volume</span>
                    </div>
                </div>
                <!-- Trade overlay legend (shown in strategy mode) -->
                <div class="chart-legend" id="trade-overlay-legend" style="display: none; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2196F3;"></div>
                        <span>Long Entry</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF9800;"></div>
                        <span>Short Entry</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00c853;"></div>
                        <span>Profit Exit</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff5252;"></div>
                        <span>Loss Exit</span>
                    </div>
                </div>
            </div>

            <!-- Equity Curve Chart (shown in strategy mode) -->
            <div id="equity-curve-container" class="card full-width" style="display: none; margin-bottom: 20px;">
                <div class="card-header">
                    <span class="card-title" id="equity-chart-title">Equity Curve</span>
                    <span class="badge badge-success" id="equity-badge">STRATEGY</span>
                </div>
                <div id="equity-curve-chart-container" style="height: 200px;"></div>
                <div class="chart-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4caf50;"></div>
                        <span>Equity</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff5252;"></div>
                        <span>Drawdown</span>
                    </div>
                </div>
            </div>

            <!-- Orderbook and Trades Grid -->
            <div class="market-data-grid">
                <div class="card">
                    <div class="orderbook-container">
                        <div class="orderbook-header">
                            <span class="orderbook-title"> Order Book</span>
                            <span id="orderbook-spread" class="orderbook-spread">Spread: --</span>
                        </div>
                        <div class="orderbook-sides">
                            <div class="orderbook-side bids">
                                <div class="orderbook-side-header">
                                    <span>Price</span>
                                    <span>Amount</span>
                                </div>
                                <div id="orderbook-bids"></div>
                            </div>
                            <div class="orderbook-side asks">
                                <div class="orderbook-side-header">
                                    <span>Price</span>
                                    <span>Amount</span>
                                </div>
                                <div id="orderbook-asks"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <div class="trades-container">
                        <div class="trades-header">
                            <span class="trades-title"> Recent Trades</span>
                            <span id="trades-count" style="color: #8892b0; font-size: 0.85rem;">0 trades</span>
                        </div>
                        <table class="trades-table">
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Side</th>
                                    <th>Price</th>
                                    <th>Amount</th>
                                </tr>
                            </thead>
                            <tbody id="trades-tbody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div id="dashboard-content" style="display: none;">
            <!-- TradingView Chart Section -->
            <div class="card full-width" style="margin-bottom: 20px;">
                <div class="card-header">
                    <span class="card-title" id="chart-title">BTC/USD Price & Bot P&L</span>
                    <span class="badge badge-real">C++ BACKTEST DATA</span>
                </div>
                <div id="chart-container"></div>
                <div class="chart-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #26a69a;"></div>
                        <span>BTC/USD Candles</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2196F3; clip-path: polygon(50% 0%, 0% 100%, 100% 100%);"></div>
                        <span>Long Entry</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF9800; clip-path: polygon(0% 0%, 100% 0%, 50% 100%);"></div>
                        <span>Short Entry</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00c853; border-radius: 50%;"></div>
                        <span>Exit (Profit)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff5252; border-radius: 50%;"></div>
                        <span>Exit (Loss)</span>
                    </div>
                </div>
            </div>

            <div class="grid">
                <!-- All 14 Performance Metrics -->
                <div class="card full-width">
                    <div class="card-header">
                        <span class="card-title">Performance Metrics</span>
                        <span class="badge badge-success" id="metrics-badge">14 Metrics</span>
                    </div>
                    <div class="stat-grid-4" id="metrics-grid">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <!-- Equity Curve with Drawdown -->
                <div class="card full-width">
                    <div class="card-header">
                        <span class="card-title">Equity Curve & Drawdown</span>
                        <span class="badge badge-info" id="equity-badge">Live</span>
                    </div>
                    <div id="equity-chart-container"></div>
                    <div class="chart-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #00d4ff;"></div>
                            <span>Equity (BTC)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff5252;"></div>
                            <span>Drawdown</span>
                        </div>
                    </div>
                </div>

                <!-- Bot Configuration -->
                <div class="card">
                    <div class="card-header">
                        <span class="card-title" id="bot-name-title">Bot Configuration</span>
                        <span class="badge badge-info" id="bot-badge">Config</span>
                    </div>
                    <div id="config-section">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <!-- Trading Bots Overview (Clickable) -->
                <div class="card">
                    <div class="card-header">
                        <span class="card-title">Trading Bots</span>
                        <span class="badge badge-info">Click to Switch</span>
                    </div>
                    <div class="bot-card active" data-bot="DivergeBot">
                        <div class="bot-header">
                            <div class="bot-icon diverge"></div>
                            <div>
                                <strong>DivergeBot</strong>
                                <div class="bot-desc">Price ratio divergence trading</div>
                            </div>
                        </div>
                    </div>
                    <div class="bot-card" data-bot="SazBot">
                        <div class="bot-header">
                            <div class="bot-icon saz"></div>
                            <div>
                                <strong>SazBot</strong>
                                <div class="bot-desc">Order book imbalance analysis</div>
                            </div>
                        </div>
                    </div>
                    <div class="bot-card" data-bot="SDBot">
                        <div class="bot-header">
                            <div class="bot-icon sd"></div>
                            <div>
                                <strong>SDBot</strong>
                                <div class="bot-desc">Standard deviation mean reversion</div>
                            </div>
                        </div>
                    </div>
                    <div class="bot-card" data-bot="PairTradeBot">
                        <div class="bot-header">
                            <div class="bot-icon pair"></div>
                            <div>
                                <strong>PairTradeBot</strong>
                                <div class="bot-desc">Statistical arbitrage using Bollinger Bands</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Unit Tests Results -->
                <div class="card">
                    <div class="card-header">
                        <span class="card-title">Unit Tests</span>
                        <span class="badge badge-success">15/15 Passed</span>
                    </div>
                    <ul class="test-list">
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> test_types</span>
                            <span class="test-status passed">4 tests passed</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> test_order_book</span>
                            <span class="test-status passed">3 tests passed</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> test_indicators</span>
                            <span class="test-status passed">4 tests passed</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> test_scheduler</span>
                            <span class="test-status passed">3 tests passed</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> test_bots</span>
                            <span class="test-status passed">9 tests passed</span>
                        </li>
                    </ul>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 100%; background: linear-gradient(90deg, #00c853, #00d4ff);"></div>
                    </div>
                </div>

                <!-- System Status -->
                <div class="card">
                    <div class="card-header">
                        <span class="card-title">System Status</span>
                        <span class="badge badge-success">Healthy</span>
                    </div>
                    <div class="stat-grid">
                        <div class="stat">
                            <div class="stat-label">Build Status</div>
                            <div class="stat-value passed"> Passing</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">C++ Standard</div>
                            <div class="stat-value">C++20</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">CMake Version</div>
                            <div class="stat-value">3.20+</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Data Source</div>
                            <div class="stat-value">JSON</div>
                        </div>
                    </div>
                </div>

                <!-- Recent Trades Table -->
                <div class="card full-width">
                    <div class="card-header">
                        <span class="card-title">Trade Activity</span>
                        <span class="badge badge-info" id="trades-badge">0 trades</span>
                    </div>
                    <div class="table-wrapper">
                        <table class="trade-table" id="trades-table">
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Type</th>
                                    <th>Price</th>
                                    <th>Qty</th>
                                    <th>P&L</th>
                                    <th>Cumulative</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Integration Tests -->
                <div class="card full-width">
                    <div class="card-header">
                        <span class="card-title">Integration & Backtest Tests</span>
                        <span class="badge badge-success">C++ JSON Output</span>
                    </div>
                    <ul class="test-list">
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> JSON Data Loader</span>
                            <span class="test-status passed" id="json-status">Loading...</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> TradingView Chart</span>
                            <span class="test-status passed">Lightweight Charts v4</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> Backtest Metrics</span>
                            <span class="test-status passed" id="metrics-status">Loading...</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> Equity Curve</span>
                            <span class="test-status passed" id="equity-status">Loading...</span>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <p class="timestamp" id="timestamp">Last updated: Loading...</p>
    </div>

    <!-- Footer -->
    <footer class="dashboard-footer">
        <div class="footer-content">
            <div class="footer-logo"> HM Trading Dashboard</div>
            <div class="footer-links">
                <span>High-frequency trading analytics</span>
            </div>
            <div class="footer-copyright">
                 2025 HM Trading Systems
            </div>
        </div>
    </footer>

    <script>
        // ==========================================
        // GLOBAL ERROR HANDLER - Captures JS errors for debugging
        // ==========================================
        const jsErrorLog = [];
        const MAX_ERROR_LOG = 50;

        function logJsError(type, message, source, line, col, stack) {
            const entry = {
                time: new Date().toLocaleTimeString(),
                type: type,
                message: String(message).substring(0, 200),
                source: source ? String(source).split('/').pop() : '',
                line: line || '',
                col: col || '',
                stack: stack || ''
            };
            jsErrorLog.unshift(entry);
            if (jsErrorLog.length > MAX_ERROR_LOG) jsErrorLog.pop();
            updateErrorPanel();
        }

        // Helper to wrap async functions with error catching
        function safeAsync(fn, fnName) {
            return async function(...args) {
                try {
                    return await fn.apply(this, args);
                } catch (err) {
                    const stack = err.stack || '';
                    const location = stack.split('\n')[1] || '';
                    logJsError('AsyncError', `${fnName}: ${err.message}`, location, '', '', stack);
                    throw err; // Re-throw so caller knows it failed
                }
            };
        }

        function updateErrorPanel() {
            const panel = document.getElementById('js-error-panel');
            const list = document.getElementById('js-error-list');
            if (!panel || !list) return;

            if (jsErrorLog.length > 0) {
                panel.style.display = 'block';
                panel.style.visibility = 'visible';
                panel.style.opacity = '1';
                list.innerHTML = jsErrorLog.map(e =>
                    `<div class="js-error-entry" title="${e.stack ? e.stack.replace(/"/g, '&quot;') : ''}">
                        <span class="error-time">[${e.time}]</span>
                        <span class="error-type">${e.type}</span>
                        <span class="error-msg">${e.message}</span>
                        <span class="error-loc">${e.source}${e.line ? ':'+e.line : ''}</span>
                    </div>`
                ).join('');
            } else {
                panel.style.display = 'none';
            }
        }

        // Catch synchronous errors
        window.onerror = function(message, source, line, col, error) {
            const stack = error?.stack || '';
            logJsError('Error', message, source, line, col, stack);
            return false; // Let error propagate to console too
        };

        // Catch unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            const reason = event.reason;
            const message = reason?.message || reason?.toString() || 'Unknown promise rejection';
            logJsError('Promise', message, reason?.stack?.split('\n')[1] || '', '', '');
        });

        // Safe wrapper for chart setData calls - logs errors with source identification
        function safeSetData(series, data, sourceName) {
            if (!series) {
                console.warn(`[Chart] safeSetData: series is null for ${sourceName}`);
                return false;
            }
            if (!data) {
                console.warn(`[Chart] safeSetData: data is null for ${sourceName}`);
                return false;
            }
            if (!Array.isArray(data)) {
                console.warn(`[Chart] safeSetData: data is not array for ${sourceName}`, typeof data);
                return false;
            }
            // Filter out any null/invalid data points
            const validData = data.filter(d => d && typeof d.time === 'number' && d.time > 0);
            if (validData.length === 0) {
                console.warn(`[Chart] safeSetData: no valid data points for ${sourceName}`);
                return false;
            }
            try {
                series.setData(validData);
                return true;
            } catch (err) {
                logJsError('ChartSetData', `${sourceName}: ${err.message}`, '', '', '', err.stack);
                console.error(`[Chart] setData failed for ${sourceName}:`, err);
                return false;
            }
        }

        // Safe wrapper for chart setMarkers calls
        function safeSetMarkers(series, markers, sourceName) {
            if (!series) {
                console.warn(`[Chart] safeSetMarkers: series is null for ${sourceName}`);
                return false;
            }
            try {
                series.setMarkers(markers || []);
                return true;
            } catch (err) {
                logJsError('ChartSetMarkers', `${sourceName}: ${err.message}`, '', '', '', err.stack);
                console.error(`[Chart] setMarkers failed for ${sourceName}:`, err);
                return false;
            }
        }

        // Global state
        let currentData = null;
        let testSessionData = null;
        let backtestSessionData = null;
        let mainChart = null;
        let equityChart = null;
        let currentBot = 'DivergeBot';
        let currentPeriod = 'all';
        let currentSession = 'backtest';
        let currentCandlePeriod = '1m';
        let rawCandles = null; // Store original 1m candles

        // Adaptive time formatter for equity charts
        // Adjusts time label format based on zoom level
        function setupAdaptiveTimeFormat(chart) {
            const timeScale = chart.timeScale();

            // Create adaptive tick formatter
            const adaptiveTickFormatter = (time, tickMarkType, locale) => {
                const date = new Date(time * 1000);

                // Get visible range to determine zoom level
                const visibleRange = timeScale.getVisibleLogicalRange();
                let barsVisible = 100; // default
                if (visibleRange) {
                    barsVisible = Math.abs(visibleRange.to - visibleRange.from);
                }

                // Also check visible time range
                const visibleTimeRange = timeScale.getVisibleRange();
                let timeSpanSeconds = 86400 * 7; // default 1 week
                if (visibleTimeRange && visibleTimeRange.from && visibleTimeRange.to) {
                    timeSpanSeconds = visibleTimeRange.to - visibleTimeRange.from;
                }

                const hours = timeSpanSeconds / 3600;
                const days = timeSpanSeconds / 86400;

                // Format based on zoom level
                if (days > 7) {
                    // Wide range (weeks+) - show date only
                    return date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short' });
                } else if (days > 1) {
                    // Medium-wide range (days) - show date
                    return date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short' });
                } else if (hours > 6) {
                    // Medium range (hours) - show date + hour
                    return date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short' }) +
                           ' ' + date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                } else if (hours > 1) {
                    // Narrow range (hours) - show hour:minute
                    return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                } else {
                    // Very narrow range (minutes) - show hour:minute:second
                    return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                }
            };

            // Apply the formatter
            timeScale.applyOptions({
                tickMarkFormatter: adaptiveTickFormatter
            });

            // Force re-render on visible range change to update labels
            timeScale.subscribeVisibleLogicalRangeChange(() => {
                // Trigger a re-render by slightly updating options
                // This ensures tick marks get recalculated with new zoom level
                chart.applyOptions({});
            });
        }

        // Live Test Control State
        const CONTROL_API_URL = 'https://agent-company.atamatch.com:8443';
        const CONTROL_WS_URL = 'wss://agent-company.atamatch.com:8443/trades/stream';
        const CONTROL_API_KEY = 'hm-trading-dev-key-2025';

        // ==========================================
        // SESSION DATA API HELPERS (Phase 3 Migration)
        // Try new DB endpoints first, fall back to file-based
        // ==========================================

        /**
         * Fetch session trades - tries DB endpoint first, falls back to file-based
         * @param {string} sessionId - Session UUID
         * @param {object} options - { limit, offset }
         * @returns {object} { success, trades, count, total, source }
         */
        async function fetchSessionTrades(sessionId, options = {}) {
            const { limit = 1000, offset = 0 } = options;
            const headers = { 'x-api-key': CONTROL_API_KEY };

            // Try new DB endpoint first
            try {
                const dbResponse = await fetch(
                    `${CONTROL_API_URL}/sessions/${sessionId}/trades/db?limit=${limit}&offset=${offset}`,
                    { headers }
                );
                if (dbResponse.ok) {
                    const data = await dbResponse.json();
                    // Check if DB has data
                    if (data.trades && data.trades.length > 0) {
                        // Map field names: direction->side, realized_pnl->pnl for compatibility
                        const mappedTrades = data.trades.map(t => ({
                            ...t,
                            side: t.direction,
                            pnl: t.realized_pnl
                        }));
                        return { success: true, trades: mappedTrades, count: data.count, total: data.total, source: 'db' };
                    }
                }
            } catch (e) {
                console.log('[fetchSessionTrades] DB endpoint failed, trying file-based:', e.message);
            }

            // Fall back to file-based endpoint
            try {
                const fileResponse = await fetch(
                    `${CONTROL_API_URL}/sessions/${sessionId}/trades?limit=${limit}&offset=${offset}`,
                    { headers }
                );
                if (fileResponse.ok) {
                    const data = await fileResponse.json();
                    return { success: true, trades: data.trades || [], count: data.count || 0, total: data.count || 0, source: 'file' };
                }
            } catch (e) {
                console.error('[fetchSessionTrades] File endpoint failed:', e.message);
            }

            return { success: false, trades: [], count: 0, total: 0, source: 'none' };
        }

        /**
         * Fetch session equity curve - tries DB endpoint first, falls back to file-based
         * @param {string} sessionId - Session UUID
         * @param {object} options - { limit }
         * @returns {object} { success, equity, count, final_equity, source }
         */
        async function fetchSessionEquity(sessionId, options = {}) {
            const { limit = 1000 } = options;
            const headers = { 'x-api-key': CONTROL_API_KEY };

            // Try new DB endpoint first
            try {
                const dbResponse = await fetch(
                    `${CONTROL_API_URL}/sessions/${sessionId}/equity-curve?limit=${limit}`,
                    { headers }
                );
                if (dbResponse.ok) {
                    const data = await dbResponse.json();
                    // Check if DB has data
                    if (data.equity_curve && data.equity_curve.length > 0) {
                        return {
                            success: true,
                            equity: data.equity_curve,
                            count: data.count,
                            final_equity: data.final_equity,
                            max_drawdown: data.max_drawdown,
                            source: 'db'
                        };
                    }
                }
            } catch (e) {
                console.log('[fetchSessionEquity] DB endpoint failed, trying file-based:', e.message);
            }

            // Fall back to file-based endpoint
            try {
                const fileResponse = await fetch(
                    `${CONTROL_API_URL}/sessions/${sessionId}/equity`,
                    { headers }
                );
                if (fileResponse.ok) {
                    const data = await fileResponse.json();
                    return {
                        success: true,
                        equity: data.equity || [],
                        count: data.count || 0,
                        final_equity: data.final_equity || 0,
                        source: 'file'
                    };
                }
            } catch (e) {
                console.error('[fetchSessionEquity] File endpoint failed:', e.message);
            }

            return { success: false, equity: [], count: 0, final_equity: 0, source: 'none' };
        }

        /**
         * Fetch session positions - new DB endpoint only
         * @param {string} sessionId - Session UUID
         * @returns {object} { success, positions, count }
         */
        async function fetchSessionPositions(sessionId) {
            const headers = { 'x-api-key': CONTROL_API_KEY };
            try {
                const response = await fetch(
                    `${CONTROL_API_URL}/sessions/${sessionId}/positions`,
                    { headers }
                );
                if (response.ok) {
                    const data = await response.json();
                    return { success: true, positions: data.positions || [], count: data.count || 0 };
                }
            } catch (e) {
                console.error('[fetchSessionPositions] Failed:', e.message);
            }
            return { success: false, positions: [], count: 0 };
        }

        /**
         * Fetch session trade summary - new DB endpoint only
         * @param {string} sessionId - Session UUID
         * @returns {object} { success, summary }
         */
        async function fetchSessionTradeSummary(sessionId) {
            const headers = { 'x-api-key': CONTROL_API_KEY };
            try {
                const response = await fetch(
                    `${CONTROL_API_URL}/sessions/${sessionId}/trades/summary`,
                    { headers }
                );
                if (response.ok) {
                    const data = await response.json();
                    return { success: true, summary: data.summary };
                }
            } catch (e) {
                console.error('[fetchSessionTradeSummary] Failed:', e.message);
            }
            return { success: false, summary: null };
        }

        // ==========================================
        // SESSION MANAGEMENT (Phase 2)
        // ==========================================

        // Session state
        let sessionsData = {
            running: [],
            scrapers: [],
            history: []
        };
        let strategiesData = [];
        let sessionPollingInterval = null;
        const SESSION_POLL_INTERVAL = 5000; // 5 seconds

        // Fetch strategies from API
        async function fetchStrategies() {
            try {
                const response = await fetch(`${CONTROL_API_URL}/strategies`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (response.ok) {
                    const data = await response.json();
                    strategiesData = data.strategies || [];
                    populateStrategyDropdowns();
                }
            } catch (error) {
                console.error('[Sessions] Failed to fetch strategies:', error);
            }
        }

        // Populate strategy dropdowns
        function populateStrategyDropdowns() {
            const dropdowns = [
                document.getElementById('new-session-strategy'),
                document.getElementById('filter-strategy-running')
            ];

            dropdowns.forEach(dropdown => {
                if (!dropdown) return;
                const isFilter = dropdown.id.includes('filter');
                dropdown.innerHTML = isFilter ? '<option value="">All Strategies</option>' : '';

                strategiesData.forEach(strategy => {
                    const option = document.createElement('option');
                    option.value = strategy.id;
                    option.textContent = strategy.name;
                    dropdown.appendChild(option);
                });
            });
        }

        // History pagination state
        let historyCurrentPage = 1;
        const HISTORY_PER_PAGE = 20;
        let historyTotalPages = 1;
        let historyTotal = 0;

        // Fetch all sessions from API
        async function fetchSessions() {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions?limit=100`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                const sessions = data.sessions || [];

                // Build a map of existing session trade_count and total_pnl (from WebSocket updates)
                const existingStats = {};
                ['running', 'scrapers', 'history'].forEach(category => {
                    (sessionsData[category] || []).forEach(s => {
                        if (s.trade_count !== undefined || s.total_pnl !== undefined) {
                            existingStats[s.id] = {
                                trade_count: s.trade_count,
                                total_pnl: s.total_pnl
                            };
                        }
                    });
                });

                // Merge existing stats into new sessions (preserve WebSocket updates if API doesn't provide)
                sessions.forEach(s => {
                    const existing = existingStats[s.id];
                    if (existing) {
                        // Only use existing if API didn't provide values
                        if (s.trade_count === undefined || s.trade_count === null) {
                            s.trade_count = existing.trade_count;
                        }
                        if (s.total_pnl === undefined || s.total_pnl === null) {
                            s.total_pnl = existing.total_pnl;
                        }
                    }
                });

                // Categorize sessions
                sessionsData.running = sessions.filter(s =>
                    s.status === 'running' && (s.type === 'test' || s.type === 'backtest')
                );
                // Only show running scrapers (stopped scrapers go to history)
                sessionsData.scrapers = sessions.filter(s =>
                    s.type === 'scraper' && s.status === 'running'
                );
                // History includes stopped scrapers
                sessionsData.history = sessions.filter(s =>
                    s.status !== 'running' && s.status !== 'created'
                );

                // Also fetch health status for running sessions
                await fetchSessionHealth();

                renderAllSessions();
                updateTabCounts();

                // Fetch history with pagination
                await fetchHistoryPage(1);
            } catch (error) {
                console.error('[Sessions] Failed to fetch sessions:', error);
            }
        }

        // Fetch history sessions with pagination
        async function fetchHistoryPage(page) {
            try {
                const offset = (page - 1) * HISTORY_PER_PAGE;
                const typeFilter = document.getElementById('filter-type-history')?.value || '';
                const marketFilter = document.getElementById('filter-market-history')?.value || '';
                const statusFilter = document.getElementById('filter-status-history')?.value || '';

                let url = `${CONTROL_API_URL}/sessions?status=completed,stopped,failed&limit=${HISTORY_PER_PAGE}&offset=${offset}`;
                if (typeFilter) url += `&type=${typeFilter}`;
                if (marketFilter) url += `&market=${marketFilter}`;
                if (statusFilter) url += `&status=${statusFilter}`;

                const response = await fetch(url, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                historyCurrentPage = page;
                historyTotal = data.total || 0;
                historyTotalPages = Math.ceil(historyTotal / HISTORY_PER_PAGE) || 1;

                // Update history list
                sessionsData.history = data.sessions || [];
                renderSessionList('history-list', sessionsData.history, 'history');
                updateHistoryPagination();

            } catch (error) {
                console.error('[Sessions] Failed to fetch history page:', error);
            }
        }

        // Update history pagination controls
        function updateHistoryPagination() {
            document.getElementById('history-page-info').textContent = `Page ${historyCurrentPage} of ${historyTotalPages}`;
            document.getElementById('history-prev-btn').disabled = historyCurrentPage <= 1;
            document.getElementById('history-next-btn').disabled = historyCurrentPage >= historyTotalPages;
            document.getElementById('history-count').textContent = historyTotal;
        }

        // Load history page (prev/next)
        function loadHistoryPage(direction) {
            const newPage = direction === 'next' ? historyCurrentPage + 1 : Math.max(1, historyCurrentPage - 1);
            if (newPage >= 1 && newPage <= historyTotalPages) {
                fetchHistoryPage(newPage);
            }
        }

        // History filter change handlers
        document.addEventListener('DOMContentLoaded', () => {
            ['filter-type-history', 'filter-market-history', 'filter-status-history'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', () => fetchHistoryPage(1));
                }
            });

            // Running sessions filter change handlers
            ['filter-market-running', 'filter-strategy-running'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', () => {
                        renderSessionList('running-sessions-list', filterRunningSessions(sessionsData.running), 'running');
                    });
                }
            });

            // Scrapers filter change handlers
            ['filter-market-scrapers'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', () => {
                        renderSessionList('scrapers-list', filterScraperSessions(sessionsData.scrapers), 'scrapers');
                    });
                }
            });
        });

        // Fetch session health status
        async function fetchSessionHealth() {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/health`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (response.ok) {
                    const data = await response.json();
                    const healthMap = {};
                    (data.sessions || []).forEach(s => {
                        healthMap[s.id] = {
                            health_status: s.health_status,
                            seconds_since_update: s.seconds_since_update
                        };
                    });

                    // Merge health data into running sessions
                    sessionsData.running.forEach(session => {
                        if (healthMap[session.id]) {
                            session.health_status = healthMap[session.id].health_status;
                            session.seconds_since_update = healthMap[session.id].seconds_since_update;
                        }
                    });
                    sessionsData.scrapers.forEach(session => {
                        if (healthMap[session.id]) {
                            session.health_status = healthMap[session.id].health_status;
                            session.seconds_since_update = healthMap[session.id].seconds_since_update;
                        }
                    });
                }
            } catch (error) {
                console.error('[Sessions] Failed to fetch health:', error);
            }
        }

        // Fetch detailed heartbeat for a specific scraper session
        async function fetchScraperHeartbeat(sessionId) {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/heartbeat`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.heartbeat) {
                        return data.heartbeat;
                    }
                }
            } catch (error) {
                console.error('[Sessions] Failed to fetch scraper heartbeat:', error);
            }
            return null;
        }

        // Poll heartbeats for all running scrapers
        async function pollScraperHeartbeats() {
            const runningScrapers = sessionsData.scrapers.filter(s => s.status === 'running');
            for (const scraper of runningScrapers) {
                const heartbeat = await fetchScraperHeartbeat(scraper.id);
                if (heartbeat) {
                    scraper.service_active = heartbeat.service_active;
                    scraper.service_status = heartbeat.service_status;
                    scraper.last_data_write = heartbeat.last_data_write;

                    // Calculate seconds since last data write (only if we have valid timestamp)
                    if (heartbeat.last_data_write) {
                        // last_data_write is ISO string (e.g., "2026-01-28T09:07:36.429Z")
                        const lastWriteMs = new Date(heartbeat.last_data_write).getTime();
                        const nowMs = Date.now();
                        const secondsAgo = Math.floor((nowMs - lastWriteMs) / 1000);
                        console.log('[Heartbeat DEBUG]', {
                            session_id: scraper.id,
                            last_data_write: heartbeat.last_data_write,
                            lastWriteMs,
                            nowMs,
                            secondsAgo,
                            service_active: heartbeat.service_active
                        });
                        // Use the calculated value (no limit - show actual staleness)
                        scraper.seconds_since_data = secondsAgo >= 0 ? secondsAgo : undefined;
                    } else {
                        console.log('[Heartbeat DEBUG] No last_data_write for', scraper.id);
                        // No data write timestamp - reset to undefined
                        scraper.seconds_since_data = undefined;
                    }

                    // Update health status based on service status (service_active is the reliable indicator)
                    if (!heartbeat.service_active) {
                        scraper.health_status = 'dead';
                    } else if (scraper.seconds_since_data !== undefined && scraper.seconds_since_data > 60) {
                        scraper.health_status = 'warning';
                    } else {
                        scraper.health_status = 'healthy';
                    }

                    // Update the card display
                    updateScraperCardHeartbeat(scraper);
                }
            }
        }

        // Update scraper card heartbeat display
        function updateScraperCardHeartbeat(scraper) {
            const card = document.querySelector(`.session-card[data-session-id="${scraper.id}"]`);
            if (!card) return;

            const heartbeatEl = card.querySelector('.heartbeat-indicator');
            if (heartbeatEl) {
                // service_active is the reliable health indicator
                const statusClass = scraper.service_active ? 'service-active' : 'service-inactive';

                // Determine display text
                let displayTime;
                if (!scraper.service_active) {
                    displayTime = 'stopped';
                } else if (scraper.seconds_since_data === undefined) {
                    // Service active but no data yet
                    displayTime = 'starting...';
                } else if (scraper.seconds_since_data > 300) {
                    // Data older than 5 minutes - show minutes/hours
                    const mins = Math.floor(scraper.seconds_since_data / 60);
                    displayTime = mins > 60 ? `${Math.floor(mins/60)}h ago` : `${mins}m ago`;
                } else {
                    displayTime = `${scraper.seconds_since_data}s ago`;
                }

                heartbeatEl.className = `heartbeat-indicator ${statusClass}`;
                heartbeatEl.innerHTML = `
                    <span class="heartbeat-icon"></span>
                    <span>${displayTime}</span>
                `;
            }
        }

        // Update tab count badges
        function updateTabCounts() {
            document.getElementById('running-count').textContent = sessionsData.running.length;
            document.getElementById('scrapers-count').textContent = sessionsData.scrapers.length;
            // Use historyTotal from API for consistent count (avoids flickering)
            // historyTotal is set by fetchHistoryPage(), don't override here
        }

        // Filter running sessions by market and strategy
        function filterRunningSessions(sessions) {
            const marketFilter = document.getElementById('filter-market-running')?.value || '';
            const strategyFilter = document.getElementById('filter-strategy-running')?.value || '';

            return sessions.filter(s => {
                if (marketFilter && s.market !== marketFilter) return false;
                if (strategyFilter && s.strategy_id !== strategyFilter) return false;
                return true;
            });
        }

        // Filter scrapers by market
        function filterScraperSessions(sessions) {
            const marketFilter = document.getElementById('filter-market-scrapers')?.value || '';

            return sessions.filter(s => {
                if (marketFilter && s.market !== marketFilter) return false;
                return true;
            });
        }

        // Render all session lists
        function renderAllSessions() {
            renderSessionList('running-sessions-list', filterRunningSessions(sessionsData.running), 'running');
            renderSessionList('scrapers-list', filterScraperSessions(sessionsData.scrapers), 'scrapers');
            renderSessionList('history-list', sessionsData.history, 'history');
        }

        // Track previous session data for smart updates
        const previousSessionData = {};

        // Render a session list with smart DOM updates (prevents layout jumps)
        function renderSessionList(containerId, sessions, panelType) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const emptyId = containerId.replace('-list', '-empty').replace('-sessions', '');
            const emptyEl = document.getElementById(emptyId);

            if (sessions.length === 0) {
                container.innerHTML = '';
                if (emptyEl) {
                    container.appendChild(emptyEl);
                    emptyEl.style.display = 'flex';
                }
                previousSessionData[containerId] = {};
                return;
            }

            // Hide empty state
            if (emptyEl) emptyEl.style.display = 'none';

            // Get existing cards by session ID
            const existingCards = {};
            container.querySelectorAll('.session-card[data-session-id]').forEach(card => {
                existingCards[card.dataset.sessionId] = card;
            });

            // Build set of current session IDs
            const currentSessionIds = new Set(sessions.map(s => s.id));

            // Remove cards for sessions that no longer exist
            Object.keys(existingCards).forEach(id => {
                if (!currentSessionIds.has(id)) {
                    existingCards[id].remove();
                    delete existingCards[id];
                }
            });

            // Initialize previous data tracker for this container
            if (!previousSessionData[containerId]) {
                previousSessionData[containerId] = {};
            }

            // Update or create cards
            sessions.forEach((session, index) => {
                const existingCard = existingCards[session.id];

                if (existingCard) {
                    // Smart update: only update changed elements
                    updateSessionCardInPlace(existingCard, session, panelType, previousSessionData[containerId][session.id]);
                } else {
                    // Create new card
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = renderSessionCard(session, panelType);
                    const newCard = tempDiv.firstElementChild;

                    // Insert at correct position
                    const existingAtIndex = container.children[index];
                    if (existingAtIndex) {
                        container.insertBefore(newCard, existingAtIndex);
                    } else {
                        container.appendChild(newCard);
                    }
                }

                // Store current data for next comparison
                previousSessionData[containerId][session.id] = {
                    status: session.status,
                    total_pnl: session.total_pnl,
                    seconds_since_update: session.seconds_since_update,
                    trade_count: session.trade_count
                };
            });
        }

        // Update a session card in place without replacing DOM
        function updateSessionCardInPlace(card, session, panelType, prevData) {
            const isRunning = session.status === 'running';

            // Update card classes for health status
            const cardClass = getCardHealthClass(session);
            card.className = `session-card clickable ${cardClass}`;

            // Update runtime (always changes for running sessions)
            const runtimeEl = card.querySelector('.session-runtime');
            if (runtimeEl) {
                let runtime = '--';
                if (session.started_at) {
                    const startTime = new Date(session.started_at).getTime();
                    const endTime = (session.status === 'running' || !session.stopped_at)
                        ? Date.now()
                        : new Date(session.stopped_at).getTime();
                    const durationMs = endTime - startTime;
                    runtime = durationMs >= 0 ? formatDuration(durationMs) : '00:00:00';
                }
                if (runtimeEl.textContent !== runtime) {
                    runtimeEl.textContent = runtime;
                }
            }

            // Update heartbeat (for running sessions)
            const heartbeatEl = card.querySelector('.heartbeat-indicator');
            if (heartbeatEl && isRunning) {
                const healthClass = getHealthClass(session);
                heartbeatEl.className = `heartbeat-indicator ${healthClass}`;
                const timeSpan = heartbeatEl.querySelector('span:last-child');
                if (timeSpan) {
                    const newTime = `${session.seconds_since_update || 0}s ago`;
                    if (timeSpan.textContent !== newTime) {
                        timeSpan.textContent = newTime;
                    }
                }
            }

            // Update P&L if changed
            if (!prevData || prevData.total_pnl !== session.total_pnl) {
                // Find P&L element by checking label (not just first metric)
                const allMetrics = card.querySelectorAll('.session-metric');
                for (const metric of allMetrics) {
                    const label = metric.querySelector('.metric-label');
                    if (label && label.textContent === 'P&L') {
                        const pnlEl = metric.querySelector('.metric-value');
                        if (pnlEl) {
                            const pnl = parseFloat(session.total_pnl || 0);
                            const pnlClass = pnl >= 0 ? 'positive' : 'negative';
                            const pnlFormatted = pnl >= 0 ? `+$${pnl.toFixed(2)}` : `-$${Math.abs(pnl).toFixed(2)}`;
                            pnlEl.className = `metric-value ${pnlClass}`;
                            pnlEl.textContent = pnlFormatted;
                        }
                        break;
                    }
                }
            }

            // Update trade count for all sessions
            if (!prevData || prevData.trade_count !== session.trade_count) {
                const tradeMetrics = card.querySelectorAll('.session-metric');
                for (const metric of tradeMetrics) {
                    const label = metric.querySelector('.metric-label');
                    if (label && label.textContent === 'Trades') {
                        const valueEl = metric.querySelector('.metric-value');
                        if (valueEl) valueEl.textContent = session.trade_count || 0;
                        break;
                    }
                }
            }

            // Update status if changed
            if (!prevData || prevData.status !== session.status) {
                const statusEl = card.querySelector('.session-status');
                if (statusEl) {
                    statusEl.className = `session-status ${session.status}`;
                    const textNode = Array.from(statusEl.childNodes).find(n => n.nodeType === Node.TEXT_NODE);
                    if (textNode) {
                        textNode.textContent = `\n                            ${session.status}\n                        `;
                    }
                }
            }
        }

        // Render a single session card
        function renderSessionCard(session, panelType) {
            const isRunning = session.status === 'running';
            const isScraper = session.type === 'scraper';
            const healthClass = getHealthClass(session);
            const cardClass = getCardHealthClass(session);

            // Calculate runtime
            let runtime = '--';
            if (session.started_at) {
                const startTime = new Date(session.started_at).getTime();
                // For running sessions, always use current time (ignore stopped_at from previous run)
                const endTime = (session.status === 'running' || !session.stopped_at)
                    ? Date.now()
                    : new Date(session.stopped_at).getTime();
                const durationMs = endTime - startTime;
                // Guard against negative duration (can happen with clock skew or bad data)
                runtime = durationMs >= 0 ? formatDuration(durationMs) : '00:00:00';
            }

            // Format PnL (not shown for scrapers)
            const pnl = parseFloat(session.total_pnl || 0);
            const pnlClass = pnl >= 0 ? 'positive' : 'negative';
            const pnlFormatted = pnl >= 0 ? `+$${pnl.toFixed(2)}` : `-$${Math.abs(pnl).toFixed(2)}`;

            // Get heartbeat display
            const heartbeatHtml = isRunning ? renderHeartbeat(session) : '';

            // Actions based on panel type (View button removed - row click navigates)
            let actionsHtml = '';
            if (panelType === 'running' || panelType === 'scrapers') {
                actionsHtml = `
                    <button class="btn-session-action btn-session-restart" onclick="event.stopPropagation(); restartSession('${session.id}')">Restart</button>
                    <button class="btn-session-action btn-session-stop" onclick="event.stopPropagation(); stopSession('${session.id}')">Stop</button>
                `;
            } else {
                actionsHtml = `
                    <button class="btn-session-action btn-session-restart" onclick="event.stopPropagation(); restartSession('${session.id}')">Restart</button>
                    <button class="btn-session-action btn-session-clone" onclick="event.stopPropagation(); cloneSession('${session.id}')">Clone</button>
                    <button class="btn-session-action btn-session-delete" onclick="event.stopPropagation(); deleteSession('${session.id}')"></button>
                `;
            }

            // Show "LIVE DATA" badge for running test sessions with healthy heartbeat (providing market data)
            const isProvidingLiveData = isRunning && session.type === 'test' &&
                session.seconds_since_update !== undefined && session.seconds_since_update < 30;
            const liveDataBadge = isProvidingLiveData ?
                '<span class="live-data-badge" title="This session is providing live market data"> LIVE</span>' : '';

            // Parse and format strategy params for display
            let paramsDisplay = '';
            try {
                const params = session.strategy_params ? 
                    (typeof session.strategy_params === 'string' ? JSON.parse(session.strategy_params) : session.strategy_params) : {};
                const paramItems = [];
                if (params.trade_size !== undefined) paramItems.push(`Size: ${params.trade_size}`);
                if (params.trade_interval !== undefined) paramItems.push(`Interval: ${params.trade_interval}s`);
                if (params.leverage !== undefined && params.leverage !== 1) paramItems.push(`Lev: ${params.leverage}x`);
                if (paramItems.length > 0) {
                    paramsDisplay = `<span class="session-params">${paramItems.join('  ')}</span>`;
                }
            } catch (e) { /* ignore parse errors */ }

            // Format session name - handle multi-market scrapers
            let sessionName = session.name || `${session.strategy} - ${session.market}`;
            let marketDisplay = session.market;
            if (isScraper && session.market && session.market.includes('+')) {
                // Multi-market scraper - show count instead of full list
                const markets = session.market.split('+');
                marketDisplay = `${markets.length} markets`;
                // If name already contains first market, don't duplicate
                if (!session.name) {
                    sessionName = `${session.strategy}`;
                }
            }

            return `
                <div class="session-card clickable ${cardClass}" data-session-id="${session.id}" onclick="showInlineDetail('${session.id}', '${panelType}')">
                    <div class="session-info">
                        <div class="session-name">
                            ${sessionName}
                            <span class="session-market">${marketDisplay}</span>
                            ${liveDataBadge}
                        </div>
                        <div class="session-meta">
                            <span class="session-strategy">${session.strategy}</span>
                            <span>${session.type}</span>
                            ${paramsDisplay}
                        </div>
                    </div>
                    <div class="session-status ${session.status}">
                        <span class="status-dot"></span>
                        ${session.status}
                    </div>
                    <div class="session-runtime">${runtime}</div>
                    ${isRunning && !isScraper ? `
                        <div class="heartbeat-indicator ${healthClass}">
                            <span class="heartbeat-icon"></span>
                            <span>${session.seconds_since_update || 0}s ago</span>
                        </div>
                    ` : ''}
                    ${isRunning && isScraper ? `
                        <div class="heartbeat-indicator ${session.service_active === true ? 'service-active' : (session.service_active === false ? 'service-inactive' : 'healthy')}">
                            <span class="heartbeat-icon"></span>
                            <span>${session.service_active === false ? 'stopped' : (session.seconds_since_data !== undefined ? session.seconds_since_data + 's ago' : 'loading...')}</span>
                        </div>
                    ` : ''}
                    ${!isScraper ? `
                        <div class="session-metric">
                            <span class="metric-label">Trades</span>
                            <span class="metric-value">${session.trade_count || 0}</span>
                        </div>
                        <div class="session-metric">
                            <span class="metric-label">P&L</span>
                            <span class="metric-value ${pnlClass}">${pnlFormatted}</span>
                        </div>
                    ` : ''}
                    <div class="session-actions">
                        ${actionsHtml}
                    </div>
                </div>
            `;
        }

        // Get health class for heartbeat indicator
        function getHealthClass(session) {
            if (!session.health_status) return 'healthy';
            return session.health_status; // healthy, warning, stale, dead
        }

        // Get card class for stale warnings
        function getCardHealthClass(session) {
            if (session.status !== 'running') return '';
            if (session.health_status === 'stale' || session.health_status === 'dead') {
                return 'stale-danger';
            }
            if (session.health_status === 'warning') {
                return 'stale-warning';
            }
            return '';
        }

        // Render heartbeat indicator
        function renderHeartbeat(session) {
            const healthClass = getHealthClass(session);
            const seconds = session.seconds_since_update || 0;
            return `
                <div class="heartbeat-indicator ${healthClass}">
                    <span class="heartbeat-icon"></span>
                    <span>${seconds}s ago</span>
                </div>
            `;
        }

        // Format duration from milliseconds
        function formatDuration(ms) {
            const seconds = Math.floor(ms / 1000);
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Sub-tab switching
        function initSessionSubTabs() {
            document.querySelectorAll('.session-sub-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    // ALWAYS hide inline detail when switching tabs (fixes contamination bug)
                    document.getElementById('inline-session-detail').style.display = 'none';
                    currentInlineSessionId = null;
                    currentSessionTradeData = null; // Clear stored trade data

                    // Clear chart markers when leaving detail view
                    if (liveMarketCandleSeries) {
                        safeSetMarkers(liveMarketCandleSeries, [], 'clearOnTabSwitch');
                    }

                    // Update active tab
                    document.querySelectorAll('.session-sub-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    // Update active panel - explicitly set display to prevent state pollution
                    const panelId = tab.dataset.panel;
                    document.querySelectorAll('.session-panel').forEach(p => {
                        p.classList.remove('active');
                        p.style.display = 'none';
                    });
                    const targetPanel = document.getElementById(`panel-${panelId}`);
                    targetPanel.classList.add('active');
                    targetPanel.style.display = 'flex';

                    // Reset previousPanelId to current panel
                    previousPanelId = `panel-${panelId}`;
                });
            });
        }

        // Modal functions
        function openNewSessionModal(type = 'test') {
            document.getElementById('new-session-modal').classList.add('active');
            document.getElementById('new-session-type').value = type;
            updateNewSessionForm();
        }

        function closeNewSessionModal() {
            document.getElementById('new-session-modal').classList.remove('active');
            // Reset form
            document.getElementById('new-session-name').value = '';
        }

        // Update form based on session type
        function updateNewSessionForm() {
            const type = document.getElementById('new-session-type').value;
            const backtestFields = document.getElementById('backtest-range-fields');
            const feeFields = document.getElementById('fee-config-fields');
            const strategySelect = document.getElementById('new-session-strategy');

            // Show/hide backtest date range
            backtestFields.style.display = type === 'backtest' ? 'grid' : 'none';

            // Show/hide fee config (hide for scrapers)
            feeFields.style.display = type === 'scraper' ? 'none' : 'grid';

            // Filter strategies by type
            strategySelect.innerHTML = '';
            strategiesData.filter(s => {
                const types = s.supported_types || [];
                return types.includes(type);
            }).forEach(strategy => {
                const option = document.createElement('option');
                option.value = strategy.id;
                option.textContent = strategy.name;
                strategySelect.appendChild(option);
            });

            updateStrategyParams();
        }

        // Update strategy params form
        function updateStrategyParams() {
            const strategyId = document.getElementById('new-session-strategy').value;
            const strategy = strategiesData.find(s => s.id === strategyId);
            const container = document.getElementById('strategy-params-container');
            const fieldsContainer = document.getElementById('strategy-params-fields');

            if (!strategy || !strategy.default_params || Object.keys(strategy.default_params).length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            fieldsContainer.innerHTML = '';

            const params = strategy.default_params;
            const schema = strategy.param_schema?.properties || {};

            Object.keys(params).forEach(key => {
                const value = params[key];
                const paramSchema = schema[key] || {};
                const inputType = typeof value === 'number' ? 'number' : 'text';
                
                // Format the label nicely (trade_size -> Trade Size)
                const label = paramSchema.description || key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                
                // Get min/max/step from schema
                const min = paramSchema.minimum !== undefined ? `min="${paramSchema.minimum}"` : '';
                const max = paramSchema.maximum !== undefined ? `max="${paramSchema.maximum}"` : '';
                const step = inputType === 'number' ? 'step="any"' : '';
                
                fieldsContainer.innerHTML += `
                    <div class="form-group">
                        <label class="form-label">${label}</label>
                        <input type="${inputType}" class="form-input strategy-param"
                               data-param="${key}" value="${value}" ${min} ${max} ${step}
                               title="${paramSchema.description || ''}">
                    </div>
                `;
            });
        }

        // Create a new session
        async function createSession() {
            const type = document.getElementById('new-session-type').value;
            const market = document.getElementById('new-session-market').value;
            const strategy = document.getElementById('new-session-strategy').value;
            const name = document.getElementById('new-session-name').value;

            // Collect strategy params
            const strategyParams = {};
            document.querySelectorAll('.strategy-param').forEach(input => {
                const param = input.dataset.param;
                let value = input.value;
                // Convert to number if needed
                if (input.type === 'number') {
                    value = parseFloat(value);
                }
                strategyParams[param] = value;
            });

            // Build request body
            const body = {
                type,
                market,
                strategy,
                strategy_params: strategyParams
            };
            if (name) body.name = name;

            // Add fee configuration for test/backtest (not scrapers)
            if (type !== 'scraper') {
                const makerFee = parseFloat(document.getElementById('new-session-maker-fee').value);
                const takerFee = parseFloat(document.getElementById('new-session-taker-fee').value);
                if (!isNaN(makerFee)) body.maker_fee = makerFee;
                if (!isNaN(takerFee)) body.taker_fee = takerFee;
            }

            // Add date range for backtest
            if (type === 'backtest') {
                const startDate = document.getElementById('new-session-start').value;
                const endDate = document.getElementById('new-session-end').value;
                if (startDate) body.range_start = Math.floor(new Date(startDate).getTime() / 1000);
                if (endDate) body.range_end = Math.floor(new Date(endDate).getTime() / 1000);
            }

            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': CONTROL_API_KEY
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to create session');
                }

                const data = await response.json();
                closeNewSessionModal();

                // Start the session immediately
                await startSession(data.session.id);

                // Refresh sessions list
                await fetchSessions();

            } catch (error) {
                console.error('[Sessions] Failed to create session:', error);
                showErrorToast('Session Error', error.message);
            }
        }

        // Start a session
        async function startSession(sessionId) {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/start`, {
                    method: 'POST',
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to start session');
                }
                await fetchSessions();
            } catch (error) {
                console.error('[Sessions] Failed to start session:', error);
                showErrorToast('Session Error', error.message);
            }
        }

        // Stop a session
        async function stopSession(sessionId) {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/stop`, {
                    method: 'POST',
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to stop session');
                }
                await fetchSessions();
            } catch (error) {
                console.error('[Sessions] Failed to stop session:', error);
                showErrorToast('Session Error', error.message);
            }
        }

        // Restart a session
        async function restartSession(sessionId) {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/restart`, {
                    method: 'POST',
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to restart session');
                }
                const result = await response.json();
                console.log('[Sessions] Session restarted:', result);
                await fetchSessions();
            } catch (error) {
                console.error('[Sessions] Failed to restart session:', error);
                showErrorToast('Session Error', error.message);
            }
        }

        // Launch backtest from a finished test session
        async function launchBacktestFromSession(session) {
            try {
                // Get session time range from started_at and stopped_at
                const startTime = session.started_at ? new Date(session.started_at) : null;
                const endTime = session.stopped_at ? new Date(session.stopped_at) : null;

                // Open the new session modal with pre-filled values
                openNewSessionModal();

                // Wait for modal to be ready
                await new Promise(resolve => setTimeout(resolve, 100));

                // Pre-fill the form
                document.getElementById('new-session-type').value = 'backtest';
                document.getElementById('new-session-type').dispatchEvent(new Event('change'));
                document.getElementById('new-session-market').value = session.market;
                document.getElementById('new-session-strategy').value = session.strategy;
                document.getElementById('new-session-strategy').dispatchEvent(new Event('change'));
                document.getElementById('new-session-name').value = `Backtest: ${session.name || session.strategy}`;

                // Set date range
                if (startTime) {
                    document.getElementById('new-session-start').value = startTime.toISOString().slice(0, 16);
                }
                if (endTime) {
                    document.getElementById('new-session-end').value = endTime.toISOString().slice(0, 16);
                }

                // Wait for strategy params to load, then fill them
                await new Promise(resolve => setTimeout(resolve, 200));
                if (session.strategy_params) {
                    const params = typeof session.strategy_params === 'string' ?
                        JSON.parse(session.strategy_params) : session.strategy_params;
                    document.querySelectorAll('.strategy-param').forEach(input => {
                        const param = input.dataset.param;
                        if (params[param] !== undefined) {
                            input.value = params[param];
                        }
                    });
                }

                showSessionNotification(`Backtest form pre-filled with "${session.name || session.strategy}" parameters`);
            } catch (error) {
                console.error('[Sessions] Failed to prepare backtest:', error);
                showErrorToast('Session Error', error.message);
            }
        }

        // Clone a session
        async function cloneSession(sessionId) {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/clone`, {
                    method: 'POST',
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to clone session');
                }
                await fetchSessions();
            } catch (error) {
                console.error('[Sessions] Failed to clone session:', error);
                showErrorToast('Session Error', error.message);
            }
        }

        // Delete a session
        async function deleteSession(sessionId) {
            if (!confirm('Are you sure you want to delete this session?')) return;

            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': CONTROL_API_KEY
                    },
                    body: JSON.stringify({ confirm: true })
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to delete session');
                }
                await fetchSessions();
            } catch (error) {
                console.error('[Sessions] Failed to delete session:', error);
                showErrorToast('Session Error', error.message);
            }
        }

        // Currently viewed session
        let currentViewedSessionId = null;
        let currentInlineSessionId = null;
        let previousPanelId = null;
        let logsPollingInterval = null;  // For streaming logs
        let currentSessionTradeData = null; // Store trade data for re-rendering on period change
        let lastLogTimestamp = null; // Track last log timestamp for incremental updates

        // Show inline session detail view
        async function showInlineDetail(sessionId, panelType) {
          try {
            console.log('[Sessions] Show inline detail for:', sessionId);
            currentInlineSessionId = sessionId;
            lastLogTimestamp = null;  // Reset for fresh log load

            // Find the session data
            let session = sessionsData.running.find(s => s.id === sessionId) ||
                          sessionsData.scrapers.find(s => s.id === sessionId) ||
                          sessionsData.history.find(s => s.id === sessionId);

            if (!session) {
                console.error('[Sessions] Session not found:', sessionId);
                logJsError('DetailView', `Session not found: ${sessionId}`, 'showInlineDetail', '', '');
                return;
            }

            // Hide current panel and show inline detail
            previousPanelId = `panel-${panelType === 'running' ? 'running' : panelType === 'scrapers' ? 'scrapers' : 'history'}`;
            document.getElementById(previousPanelId).style.display = 'none';
            document.getElementById('inline-session-detail').style.display = 'flex';

            // Populate header info
            document.getElementById('inline-session-name').textContent = session.name || `${session.strategy} - ${session.market}`;
            const statusEl = document.getElementById('inline-session-status');
            statusEl.textContent = session.status;
            statusEl.className = `inline-session-status ${session.status}`;
            document.getElementById('inline-session-market').textContent = session.market;
            document.getElementById('inline-session-strategy').textContent = session.strategy;

            // Show strategy params
            const paramsEl = document.getElementById('inline-session-params');
            try {
                const params = session.strategy_params ? 
                    (typeof session.strategy_params === 'string' ? JSON.parse(session.strategy_params) : session.strategy_params) : {};
                const paramItems = [];
                if (params.trade_size !== undefined) paramItems.push(`Size: ${params.trade_size}`);
                if (params.trade_interval !== undefined) paramItems.push(`Interval: ${params.trade_interval}s`);
                if (params.leverage !== undefined && params.leverage !== 1) paramItems.push(`Lev: ${params.leverage}x`);
                // Add any other params
                Object.keys(params).filter(k => !['trade_size', 'trade_interval', 'leverage'].includes(k)).forEach(k => {
                    paramItems.push(`${k}: ${params[k]}`);
                });
                if (paramItems.length > 0) {
                    paramsEl.textContent = paramItems.join('  ');
                    paramsEl.style.display = 'inline-block';
                } else {
                    paramsEl.style.display = 'none';
                }
            } catch (e) { paramsEl.style.display = 'none'; }

            // Calculate runtime
            let runtime = '--';
            if (session.started_at) {
                const startTime = new Date(session.started_at).getTime();
                const endTime = session.status === 'running' ? Date.now() : (session.stopped_at ? new Date(session.stopped_at).getTime() : Date.now());
                runtime = formatDuration(endTime - startTime);
            }
            document.getElementById('inline-session-runtime').textContent = runtime;

            // Setup action buttons
            document.getElementById('inline-restart-btn').onclick = () => { restartSession(sessionId); };
            document.getElementById('inline-stop-btn').onclick = () => { stopSession(sessionId); };
            document.getElementById('inline-stop-btn').style.display = session.status === 'running' ? 'inline-block' : 'none';

            // Show Launch Backtest button for finished test sessions
            const backtestBtn = document.getElementById('inline-backtest-btn');
            const isFinishedTest = session.status !== 'running' && session.type === 'test';
            backtestBtn.style.display = isFinishedTest ? 'inline-block' : 'none';
            if (isFinishedTest) {
                backtestBtn.onclick = () => { launchBacktestFromSession(session); };
            }

            // Load metrics
            await loadInlineMetrics(sessionId);

            // Load ALL sections at once (no tabs anymore)
            await Promise.all([
                loadInlineTrades(sessionId),
                loadInlineLogs(sessionId),
                loadInlineEquity(sessionId)
            ]);

            // Start logs polling for running sessions (every 2 seconds)
            if (logsPollingInterval) clearInterval(logsPollingInterval);
            if (session.status === 'running') {
                logsPollingInterval = setInterval(() => {
                    if (currentInlineSessionId === sessionId) {
                        pollInlineLogs(sessionId);  // Use incremental polling
                    }
                }, 2000);
            }

            // Switch chart to session's market if different
            const currentMarketVal = document.getElementById('market-selector').value.toLowerCase();
            const sessionMarket = session.market.toLowerCase();
            console.log('[Market] showInlineDetail switching market?', { current: currentMarketVal, session: sessionMarket, willSwitch: currentMarketVal !== sessionMarket });
            if (currentMarketVal !== sessionMarket) {
                console.log('[Market] RESETTING market selector to:', sessionMarket);
                document.getElementById('market-selector').value = sessionMarket;
                document.getElementById('market-selector').dispatchEvent(new Event('change'));
            }

            // Load trades onto chart (directly, don't open modal)
            try {
                // Use new helper (tries DB first, falls back to file) - limit to 200 for chart performance
                const result = await fetchSessionTrades(sessionId, { limit: 200 });
                if (result.success) {
                    displaySessionTrades({ trades: result.trades, count: result.count });
                }
            } catch (err) {
                console.error('[Sessions] Failed to load trades for chart:', err);
            }

            // Load DevDistStatBot indicators if this is a DevDistStatBot strategy session
            if (session.strategy === 'DevDistStatBot') {
                console.log('[DevDistStatBot] Loading indicators for session:', sessionId);
                await loadDevDistStatIndicators(sessionId);
                // Update chart with DevDistStatBot indicators
                updateChartIndicators('DevDistStatBot');
            }
          } catch (err) {
            // Catch ALL errors in showInlineDetail and log them visibly
            const stack = err.stack || '';
            logJsError('DetailViewError', `showInlineDetail failed: ${err.message}`, stack.split('\n')[1] || '', '', '', stack);
            console.error('[Sessions] showInlineDetail error:', err);
          }
        }

        // Hide inline detail and return to list
        function hideInlineDetail() {
            document.getElementById('inline-session-detail').style.display = 'none';
            if (previousPanelId) {
                document.getElementById(previousPanelId).style.display = 'flex';
            }
            currentInlineSessionId = null;
            currentSessionTradeData = null; // Clear stored trade data

            // Stop logs polling
            if (logsPollingInterval) {
                clearInterval(logsPollingInterval);
                logsPollingInterval = null;
            }

            // Clear chart markers
            if (liveMarketCandleSeries) {
                safeSetMarkers(liveMarketCandleSeries, [], 'hideInlineDetail');
            }

            // Clear DevDistStat indicator data and chart indicators
            devDistStatIndicatorData = { mean: [], upper: [], lower: [], zscore: [] };
            clearIndicators();
        }

        // Load metrics for inline detail
        async function loadInlineMetrics(sessionId) {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/metrics`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (response.ok) {
                    const data = await response.json();
                    const m = data.metrics;
                    document.getElementById('inline-trades').textContent = m.total_trades || 0;
                    const pnl = m.total_pnl || 0;
                    const pnlEl = document.getElementById('inline-pnl');
                    pnlEl.textContent = pnl >= 0 ? `+$${pnl.toFixed(2)}` : `-$${Math.abs(pnl).toFixed(2)}`;
                    pnlEl.className = `inline-metric-value ${pnl >= 0 ? 'positive' : 'negative'}`;
                    document.getElementById('inline-winrate').textContent = `${(m.win_rate || 0).toFixed(1)}%`;
                    document.getElementById('inline-maxdd').textContent = `$${(m.max_drawdown || 0).toFixed(0)}`;
                }
            } catch (err) {
                console.error('[Sessions] Failed to load metrics:', err);
            }
        }

        // Load trades for inline detail
        async function loadInlineTrades(sessionId) {
            const container = document.getElementById('inline-trades-list');
            try {
                // Use new helper (tries DB first, falls back to file)
                const result = await fetchSessionTrades(sessionId, { limit: 100 });
                if (result.success) {
                    const trades = result.trades || [];
                    if (trades.length === 0) {
                        container.innerHTML = '<div class="inline-empty">No trades yet</div>';
                    } else {
                        // Note: t.timestamp is Unix seconds, multiply by 1000 for JavaScript Date
                        // Parse price/pnl as numbers (DB returns strings)
                        container.innerHTML = trades.slice(-50).reverse().map(t => {
                            const pnl = parseFloat(t.pnl) || 0;
                            const price = parseFloat(t.price) || 0;
                            return `
                            <div class="inline-trade-row">
                                <span>${new Date(t.timestamp * 1000).toLocaleTimeString()}</span>
                                <span style="color: ${t.side === 'BUY' ? '#3fb950' : '#f85149'}">${t.action}</span>
                                <span>$${price.toFixed(2)}</span>
                                <span>${formatTradeSize(t.size)}</span>
                                <span class="${pnl >= 0 ? 'positive' : 'negative'}">${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}</span>
                            </div>
                        `}).join('');
                    }
                } else {
                    container.innerHTML = '<div class="inline-empty">Failed to load trades</div>';
                }
            } catch (err) {
                console.error('[Sessions] Failed to load trades:', err);
                container.innerHTML = '<div class="inline-empty">Failed to load trades</div>';
            }
        }

        // Load logs for inline detail
        // Filter out verbose/noisy log messages (order book, debug spam)
        function filterVerboseLogs(logs) {
            const verbosePatterns = [
                /orderBook/i,
                /book.*update/i,
                /book.*insert/i,
                /book.*delete/i,
                /Received orderBookL2/i,
                /DBClient/i,
                /WebSocket.*ping/i,
                /WebSocket.*pong/i,
                /heartbeat/i
            ];

            return logs.filter(log => {
                const msg = log.message || '';
                // Always keep errors and warnings
                if (log.level === 'ERROR' || log.level === 'WARN') return true;
                // Filter out ALL debug messages
                if (log.level === 'DEBUG') return false;
                // Filter out verbose patterns
                return !verbosePatterns.some(pattern => pattern.test(msg));
            });
        }

        async function loadInlineLogs(sessionId) {
            const container = document.getElementById('inline-logs-list');
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/logs?limit=200`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (response.ok) {
                    const data = await response.json();
                    let logs = data.logs || [];

                    // Store last timestamp from raw logs (before filtering)
                    if (logs.length > 0) {
                        lastLogTimestamp = logs[logs.length - 1].timestamp;
                    }

                    // Filter out verbose order book and debug messages
                    logs = filterVerboseLogs(logs);

                    if (logs.length === 0) {
                        container.innerHTML = '<div class="inline-empty">No INFO/WARN/ERROR logs (DEBUG filtered)</div>';
                    } else {
                        // Show most recent logs at bottom (chronological order)
                        container.innerHTML = logs.slice(-100).map(l => `
                            <div class="inline-log-row ${l.level?.toLowerCase()}">
                                <span style="color: #6e7681">${new Date(l.timestamp).toLocaleTimeString()}</span>
                                <span style="color: ${l.level === 'ERROR' ? '#f85149' : l.level === 'WARN' ? '#d29922' : '#8b949e'}">[${l.level}]</span>
                                ${l.message}
                            </div>
                        `).join('');
                        // Auto-scroll to bottom (latest logs)
                        container.scrollTop = container.scrollHeight;
                    }
                } else {
                    container.innerHTML = '<div class="inline-empty">Failed to load logs</div>';
                }
            } catch (err) {
                console.error('[Sessions] Failed to load logs:', err);
                logJsError('LogsError', `loadInlineLogs: ${err.message}`, '', '', '', err.stack);
                container.innerHTML = '<div class="inline-empty">Failed to load logs: ' + err.message + '</div>';
            }
        }

        // Poll for new logs incrementally (only fetch logs newer than lastLogTimestamp)
        async function pollInlineLogs(sessionId) {
            if (!lastLogTimestamp) {
                // No previous timestamp, do full load
                return loadInlineLogs(sessionId);
            }

            try {
                // Fetch recent logs
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/logs?limit=50`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (response.ok) {
                    const data = await response.json();
                    let logs = data.logs || [];

                    // Filter to only logs newer than lastLogTimestamp (client-side)
                    const lastTs = new Date(lastLogTimestamp).getTime();
                    const newLogs = logs.filter(l => new Date(l.timestamp).getTime() > lastTs);

                    // Update last timestamp from raw logs (before filtering)
                    if (logs.length > 0) {
                        lastLogTimestamp = logs[logs.length - 1].timestamp;
                    }

                    // Append only the new logs (if any)
                    if (newLogs.length > 0) {
                        appendInlineLogs(newLogs);
                    }
                }
            } catch (err) {
                console.error('[Sessions] Failed to poll logs:', err);
                // Only log first poll error to avoid spam
                if (!window._pollLogErrorShown) {
                    logJsError('PollError', `pollInlineLogs: ${err.message}`, '', '', '', err.stack);
                    window._pollLogErrorShown = true;
                }
            }
        }

        // Append new log entries and auto-scroll
        function appendInlineLogs(newLogs) {
            const container = document.getElementById('inline-logs-list');
            if (!container || !newLogs || newLogs.length === 0) return;

            // Filter verbose logs
            const filteredLogs = filterVerboseLogs(newLogs);
            if (filteredLogs.length === 0) return;

            // Check if user has scrolled up (not at bottom)
            const wasAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;

            // Remove "No logs" message if present
            const emptyMsg = container.querySelector('.inline-empty');
            if (emptyMsg) emptyMsg.remove();

            // Append new logs
            const html = filteredLogs.map(l => `
                <div class="inline-log-row ${l.level?.toLowerCase()} new-log">
                    <span style="color: #6e7681">${new Date(l.timestamp).toLocaleTimeString()}</span>
                    <span style="color: ${l.level === 'ERROR' ? '#f85149' : l.level === 'WARN' ? '#d29922' : '#8b949e'}">[${l.level}]</span>
                    ${l.message}
                </div>
            `).join('');
            container.insertAdjacentHTML('beforeend', html);

            // Auto-scroll if user was at bottom
            if (wasAtBottom) {
                container.scrollTop = container.scrollHeight;
            }

            // Remove highlight after animation
            setTimeout(() => {
                container.querySelectorAll('.new-log').forEach(el => el.classList.remove('new-log'));
            }, 1000);
        }

        // Load equity curve for inline detail
        let inlineEquityChart = null;
        async function loadInlineEquity(sessionId) {
            try {
                // Use new helper (tries DB first, falls back to file)
                const result = await fetchSessionEquity(sessionId);
                if (result.success) {
                    const equity = result.equity || [];
                    if (equity.length > 0) {
                        // Create mini equity chart
                        const container = document.getElementById('inline-equity-chart');
                        container.innerHTML = '';

                        // Get width - use offsetWidth or fallback to parent width
                        const chartWidth = container.offsetWidth || container.clientWidth || container.parentElement?.offsetWidth || 400;
                        const chartHeight = 180;

                        // Destroy previous chart if exists
                        if (inlineEquityChart) {
                            inlineEquityChart.remove();
                            inlineEquityChart = null;
                        }

                        inlineEquityChart = LightweightCharts.createChart(container, {
                            width: chartWidth,
                            height: chartHeight,
                            layout: { background: { color: '#0d1117' }, textColor: '#8b949e' },
                            grid: { vertLines: { color: '#21262d' }, horzLines: { color: '#21262d' } },
                            rightPriceScale: { borderColor: '#21262d' },
                            timeScale: { borderColor: '#21262d' }
                        });

                        const series = inlineEquityChart.addLineSeries({
                            color: '#58a6ff',
                            lineWidth: 2,
                            priceFormat: { type: 'price', precision: 2, minMove: 0.01 }
                        });

                        // Map equity data - handle both timestamp formats
                        const chartData = equity.map(e => {
                            // Handle timestamp: could be in ms or seconds
                            let time = e.timestamp;
                            if (time > 1e12) time = Math.floor(time / 1000); // Convert ms to seconds
                            return { time: time, value: parseFloat(e.equity) || 0 };
                        }).filter(d => d.time > 0 && !isNaN(d.value));

                        if (chartData.length > 0) {
                            safeSetData(series, chartData, 'inlineEquityChart');
                            inlineEquityChart.timeScale().fitContent();
                            // Apply adaptive time formatting for zoom
                            setupAdaptiveTimeFormat(inlineEquityChart);
                            console.log(`[InlineEquity] Loaded ${chartData.length} points, width: ${chartWidth}`);
                        } else {
                            container.innerHTML = '<div class="inline-empty">No valid equity data</div>';
                        }

                        // Handle resize
                        const resizeHandler = () => {
                            if (inlineEquityChart && container.offsetWidth > 0) {
                                inlineEquityChart.applyOptions({ width: container.offsetWidth });
                            }
                        };
                        window.addEventListener('resize', resizeHandler);
                    } else {
                        document.getElementById('inline-equity-chart').innerHTML = '<div class="inline-empty">No equity data</div>';
                    }
                }
            } catch (err) {
                console.error('[InlineEquity] Error:', err);
                document.getElementById('inline-equity-chart').innerHTML = '<div class="inline-empty">Failed to load equity</div>';
            }
        }

        // Switch inline detail tabs
        function switchInlineTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.inline-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.inline-tab[data-tab="${tabName}"]`).classList.add('active');

            // Hide all tabs
            document.querySelectorAll('.inline-tab-content').forEach(c => c.style.display = 'none');

            // Show selected tab
            document.getElementById(`inline-tab-${tabName}`).style.display = 'block';

            // Load data for tab
            if (currentInlineSessionId) {
                if (tabName === 'trades') loadInlineTrades(currentInlineSessionId);
                else if (tabName === 'logs') loadInlineLogs(currentInlineSessionId);
                else if (tabName === 'equity') loadInlineEquity(currentInlineSessionId);
            }
        }

        // View session - load trades and display on chart
        async function viewSession(sessionId) {
            console.log('[Sessions] View session:', sessionId);
            currentViewedSessionId = sessionId;

            try {
                // Use new helper (tries DB first, falls back to file) - limit to 200 for chart performance
                const result = await fetchSessionTrades(sessionId, { limit: 200 });

                if (!result.success) {
                    throw new Error('Failed to load session trades');
                }

                const data = { trades: result.trades, count: result.count, total: result.total, session_name: sessionId };
                console.log(`[Sessions] Loaded ${data.count} trades of ${result.total || 'unknown'} total (source: ${result.source})`);

                // Display trades on chart
                displaySessionTrades(data);

                // Show notification
                if (data.count > 0) {
                    showSessionNotification(`Showing ${data.count} trades from "${data.session_name}" on chart`);
                } else {
                    showSessionNotification(`No trades yet for "${data.session_name}"`);
                }

            } catch (error) {
                console.error('[Sessions] Failed to load trades:', error);
                showErrorToast('Session Error', error.message);
            }
        }

        // Display session trades as markers on the chart
        // OPTIMIZED: Sort candles once, use binary search, limit markers
        function displaySessionTrades(tradeData) {
            // Store trade data for re-rendering when period changes
            currentSessionTradeData = tradeData;

            if (!liveMarketCandleSeries || !lastCandleData || lastCandleData.length === 0) {
                console.log('[Sessions] Cannot display trades - chart not ready');
                return;
            }

            const trades = tradeData.trades || [];
            if (trades.length === 0) {
                safeSetMarkers(liveMarketCandleSeries, [], 'displaySessionTrades_empty');
                return;
            }

            // OPTIMIZATION 1: Sort candles ONCE (not per trade)
            const sortedCandles = [...lastCandleData].sort((a, b) => a.time - b.time);
            const candleTimes = sortedCandles.map(c => c.time);

            // OPTIMIZATION 2: Binary search for candle lookup
            const findContainingCandle = (timestampSec) => {
                // Binary search to find largest candle.time <= timestampSec
                let left = 0, right = candleTimes.length - 1;
                let result = 0;
                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    if (candleTimes[mid] <= timestampSec) {
                        result = mid;
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
                return sortedCandles[result];
            };

            // OPTIMIZATION 3: Limit to most recent 200 trades for performance
            const MAX_MARKERS = 200;
            const tradesToShow = trades.length > MAX_MARKERS
                ? trades.slice(-MAX_MARKERS)
                : trades;

            const markers = [];

            tradesToShow.forEach(trade => {
                const candle = findContainingCandle(trade.timestamp);
                const isEntry = trade.action === 'OPEN';
                const isLong = trade.side === 'BUY';

                if (isEntry) {
                    // Entry marker - arrow
                    markers.push({
                        time: candle.time,
                        position: isLong ? 'belowBar' : 'aboveBar',
                        color: isLong ? '#2196F3' : '#FF9800', // Blue for long, orange for short
                        shape: isLong ? 'arrowUp' : 'arrowDown',
                        text: `${trade.side} @ ${trade.price.toFixed(1)}`
                    });
                } else {
                    // Exit marker - circle
                    const pnl = trade.pnl || 0;
                    markers.push({
                        time: candle.time,
                        position: !isLong ? 'belowBar' : 'aboveBar', // Opposite of entry
                        color: pnl >= 0 ? '#00c853' : '#ff5252', // Green for profit, red for loss
                        shape: 'circle',
                        text: pnl !== 0 ? `${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}` : ''
                    });
                }
            });

            // Sort markers by time (required by Lightweight Charts)
            markers.sort((a, b) => a.time - b.time);
            safeSetMarkers(liveMarketCandleSeries, markers, 'displaySessionTrades');

            const limitNote = trades.length > MAX_MARKERS ? ` (limited from ${trades.length})` : '';
            console.log(`[Sessions] Displayed ${markers.length} trade markers on chart${limitNote}`);
        }

        // Clear session trade markers
        function clearSessionTrades() {
            currentViewedSessionId = null;
            if (liveMarketCandleSeries) {
                safeSetMarkers(liveMarketCandleSeries, [], 'clearSessionTrades');
            }
        }

        // Show session notification toast
        function showSessionNotification(message) {
            // Reuse error toast with different styling
            const toast = document.getElementById('error-toast');
            const titleEl = document.getElementById('error-toast-title');
            const messageEl = document.getElementById('error-toast-message');

            titleEl.textContent = ' Session Trades';
            messageEl.textContent = message;
            toast.style.borderColor = '#58a6ff';
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
                toast.style.borderColor = '';
            }, 3000);
        }

        // ============= SESSION DETAIL MODAL =============
        let currentDetailSessionId = null;
        let detailEquityChart = null;
        let logStreamWs = null;
        let tradesCurrentPage = 1;
        const TRADES_PER_PAGE = 50;

        // Open session detail modal
        async function openSessionDetailModal(sessionId) {
            console.log('[Detail] Opening modal for session:', sessionId);
            currentDetailSessionId = sessionId;

            // Show modal
            document.getElementById('session-detail-modal').classList.add('active');

            // Reset to info tab
            switchDetailTab('info');

            // Load session data
            await loadSessionDetail(sessionId);
        }

        // Close session detail modal
        function closeSessionDetailModal() {
            document.getElementById('session-detail-modal').classList.remove('active');
            currentDetailSessionId = null;

            // Stop log streaming if active
            if (logStreamWs) {
                logStreamWs.close();
                logStreamWs = null;
            }

            // Destroy equity chart
            if (detailEquityChart) {
                detailEquityChart.remove();
                detailEquityChart = null;
            }
        }

        // Switch between detail tabs
        function switchDetailTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.modal-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            // Update tab content
            document.querySelectorAll('.detail-tab-content').forEach(content => {
                content.classList.toggle('active', content.id === `tab-${tabName}`);
            });

            // Load tab-specific data
            if (currentDetailSessionId) {
                if (tabName === 'metrics') loadSessionMetrics(currentDetailSessionId);
                if (tabName === 'trades') loadSessionTrades(currentDetailSessionId, 1);
                if (tabName === 'logs') loadSessionLogs(currentDetailSessionId);
            }
        }

        // Load session detail info
        async function loadSessionDetail(sessionId) {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                if (!response.ok) throw new Error('Failed to load session');

                const data = await response.json();
                const session = data.session;

                // Update header
                document.getElementById('detail-session-name').textContent = session.name || `${session.strategy} - ${session.market}`;
                document.getElementById('detail-session-type').textContent = session.type;
                document.getElementById('detail-session-market').textContent = session.market;
                document.getElementById('detail-session-strategy').textContent = session.strategy;
                const statusEl = document.getElementById('detail-session-status');
                statusEl.textContent = session.status;
                statusEl.className = `detail-status ${session.status}`;

                // Update info tab
                document.getElementById('detail-id').textContent = session.id;
                document.getElementById('detail-name').textContent = session.name || '-';
                document.getElementById('detail-type').textContent = session.type;
                document.getElementById('detail-market').textContent = session.market;
                document.getElementById('detail-strategy').textContent = session.strategy;
                document.getElementById('detail-status').textContent = session.status;

                // Timing
                document.getElementById('detail-created').textContent = formatDateTime(session.created_at);
                document.getElementById('detail-started').textContent = session.started_at ? formatDateTime(session.started_at) : '-';
                document.getElementById('detail-completed').textContent = session.completed_at ? formatDateTime(session.completed_at) : '-';
                document.getElementById('detail-duration').textContent = session.started_at ?
                    formatDurationFromDates(session.started_at, session.completed_at || new Date().toISOString()) : '-';

                // Strategy params - format nicely
                try {
                    const params = session.strategy_params ? 
                        (typeof session.strategy_params === 'string' ? JSON.parse(session.strategy_params) : session.strategy_params) : {};
                    if (Object.keys(params).length > 0) {
                        const formatted = Object.entries(params)
                            .map(([key, value]) => `${key.replace(/_/g, ' ')}: ${value}`)
                            .join('\n');
                        document.getElementById('detail-params').textContent = formatted;
                    } else {
                        document.getElementById('detail-params').textContent = 'No custom parameters';
                    }
                } catch (e) {
                    document.getElementById('detail-params').textContent = session.strategy_params || 'No parameters';
                }

                // Notes
                document.getElementById('detail-notes').value = session.notes || '';

            } catch (error) {
                console.error('[Detail] Failed to load session:', error);
                showErrorToast('Error', 'Failed to load session details');
            }
        }

        // Format date/time
        function formatDateTime(isoString) {
            if (!isoString) return '-';
            const d = new Date(isoString);
            return d.toLocaleString();
        }

        // Format duration from two dates
        function formatDurationFromDates(start, end) {
            const ms = new Date(end) - new Date(start);
            const seconds = Math.floor(ms / 1000);
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hours > 0) return `${hours}h ${minutes}m ${secs}s`;
            if (minutes > 0) return `${minutes}m ${secs}s`;
            return `${secs}s`;
        }

        // Load session metrics
        async function loadSessionMetrics(sessionId) {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/metrics`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                if (!response.ok) throw new Error('Failed to load metrics');

                const data = await response.json();
                const m = data.metrics || {};

                // Update metric cards
                const pnl = m.total_pnl || 0;
                const pnlEl = document.getElementById('metric-pnl');
                pnlEl.textContent = `$${pnl.toFixed(2)}`;
                pnlEl.className = `metric-card-value ${pnl >= 0 ? 'positive' : 'negative'}`;

                document.getElementById('metric-trades').textContent = m.total_trades || 0;
                document.getElementById('metric-winrate').textContent = `${(m.win_rate || 0).toFixed(1)}%`;
                document.getElementById('metric-avgwin').textContent = `$${(m.avg_win || 0).toFixed(2)}`;
                document.getElementById('metric-avgloss').textContent = `$${(m.avg_loss || 0).toFixed(2)}`;
                document.getElementById('metric-drawdown').textContent = `$${(m.max_drawdown || 0).toFixed(2)}`;
                document.getElementById('metric-pf').textContent = (m.profit_factor || 0).toFixed(2);
                document.getElementById('metric-sharpe').textContent = (m.sharpe_ratio || 0).toFixed(2);

                // Load equity curve
                await loadEquityCurve(sessionId);

            } catch (error) {
                console.error('[Detail] Failed to load metrics:', error);
            }
        }

        // Load equity curve chart
        async function loadEquityCurve(sessionId) {
            try {
                // Use new helper (tries DB first, falls back to file)
                const result = await fetchSessionEquity(sessionId);
                if (!result.success) throw new Error('Failed to load equity curve');

                const points = result.equity || [];

                // Create/update chart
                const container = document.getElementById('detail-equity-chart');
                if (!container) return;

                if (detailEquityChart) {
                    detailEquityChart.remove();
                }

                detailEquityChart = LightweightCharts.createChart(container, {
                    width: container.clientWidth,
                    height: 250,
                    layout: { background: { type: 'solid', color: '#0d1117' }, textColor: '#8b949e' },
                    grid: { vertLines: { color: 'rgba(255,255,255,0.05)' }, horzLines: { color: 'rgba(255,255,255,0.05)' } },
                    timeScale: { timeVisible: true, secondsVisible: false, borderColor: 'rgba(255,255,255,0.1)' },
                    rightPriceScale: { borderColor: 'rgba(255,255,255,0.1)' }
                });

                const lineSeries = detailEquityChart.addLineSeries({
                    color: '#58a6ff',
                    lineWidth: 2
                });

                if (points.length > 0) {
                    const equityPoints = points.map(p => ({
                        time: Math.floor(p.timestamp / 1000),
                        value: p.equity
                    }));
                    safeSetData(lineSeries, equityPoints, 'detailEquityChart');
                }

                // Apply adaptive time formatting for zoom
                setupAdaptiveTimeFormat(detailEquityChart);

            } catch (error) {
                console.error('[Detail] Failed to load equity curve:', error);
            }
        }

        // Load session trades with pagination
        async function loadSessionTrades(sessionId, page = 1) {
            try {
                tradesCurrentPage = page;
                const offset = (page - 1) * TRADES_PER_PAGE;

                // Use new helper (tries DB first, falls back to file)
                const result = await fetchSessionTrades(sessionId, { limit: TRADES_PER_PAGE, offset });
                if (!result.success) throw new Error('Failed to load trades');

                const trades = result.trades || [];
                const total = result.total || result.count || 0;

                const tbody = document.getElementById('detail-trades-body');
                if (trades.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" class="no-data">No trades yet</td></tr>';
                } else {
                    // Note: t.timestamp is Unix seconds, multiply by 1000 for JavaScript Date
                    tbody.innerHTML = trades.map(t => `
                        <tr>
                            <td>${new Date(t.timestamp * 1000).toLocaleString()}</td>
                            <td>${t.action}</td>
                            <td class="${t.side.toLowerCase()}">${t.side}</td>
                            <td>$${t.price.toFixed(2)}</td>
                            <td>${formatTradeSize(t.size)}</td>
                            <td class="${(t.pnl || 0) >= 0 ? 'buy' : 'sell'}">${t.pnl ? `$${t.pnl.toFixed(2)}` : '-'}</td>
                            <td>${t.reason || '-'}</td>
                        </tr>
                    `).join('');
                }

                // Update pagination
                const totalPages = Math.ceil(total / TRADES_PER_PAGE);
                document.getElementById('trades-page-info').textContent = `Page ${page} of ${totalPages || 1}`;

            } catch (error) {
                console.error('[Detail] Failed to load trades:', error);
            }
        }

        // Pagination controls
        function loadTradesPage(direction) {
            if (!currentDetailSessionId) return;
            const newPage = direction === 'next' ? tradesCurrentPage + 1 : Math.max(1, tradesCurrentPage - 1);
            loadSessionTrades(currentDetailSessionId, newPage);
        }

        // Load session logs
        async function loadSessionLogs(sessionId) {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/logs?limit=100`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                if (!response.ok) throw new Error('Failed to load logs');

                const data = await response.json();
                const logs = data.logs || [];

                const container = document.getElementById('detail-logs-container');
                if (logs.length === 0) {
                    container.innerHTML = '<div class="log-line log-info">No logs yet</div>';
                } else {
                    container.innerHTML = logs.map(log => {
                        const levelClass = `log-${(log.level || 'info').toLowerCase()}`;
                        return `<div class="log-line ${levelClass}">[${new Date(log.timestamp).toLocaleTimeString()}] [${log.level || 'INFO'}] ${log.message}</div>`;
                    }).join('');

                    // Auto-scroll to bottom
                    if (document.getElementById('logs-autoscroll-check').checked) {
                        container.scrollTop = container.scrollHeight;
                    }
                }

            } catch (error) {
                console.error('[Detail] Failed to load logs:', error);
                document.getElementById('detail-logs-container').innerHTML =
                    '<div class="log-line log-error">Failed to load logs</div>';
            }
        }

        // Filter logs by level
        function filterLogs() {
            // Re-load logs with filter (API should support level filter)
            if (currentDetailSessionId) {
                loadSessionLogs(currentDetailSessionId);
            }
        }

        // Toggle live log streaming
        function toggleLogStream() {
            const btn = document.getElementById('btn-logs-stream');

            if (logStreamWs) {
                // Unsubscribe and close
                if (logStreamWs.readyState === WebSocket.OPEN) {
                    logStreamWs.send(JSON.stringify({
                        type: 'unsubscribe',
                        channel: 'logs',
                        session_id: currentDetailSessionId
                    }));
                }
                logStreamWs.close();
                logStreamWs = null;
                btn.textContent = ' Start Stream';
                btn.classList.remove('streaming');
            } else {
                // Connect to main WebSocket and subscribe to logs
                logStreamWs = new WebSocket(CONTROL_WS_URL);

                logStreamWs.onopen = () => {
                    btn.textContent = ' Stop Stream';
                    btn.classList.add('streaming');
                    // Subscribe to logs for this session
                    logStreamWs.send(JSON.stringify({
                        type: 'subscribe',
                        channel: 'logs',
                        session_id: currentDetailSessionId
                    }));
                };

                logStreamWs.onmessage = (event) => {
                    try {
                        const msg = JSON.parse(event.data);
                        // Only process log messages
                        if (msg.type === 'log' && msg.session_id === currentDetailSessionId) {
                            const container = document.getElementById('detail-logs-container');
                            const levelClass = `log-${(msg.level || 'info').toLowerCase()}`;
                            const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
                            container.innerHTML += `<div class="log-line ${levelClass}">[${timestamp}] [${msg.level || 'INFO'}] ${msg.message}</div>`;

                            if (document.getElementById('logs-autoscroll-check').checked) {
                                container.scrollTop = container.scrollHeight;
                            }
                        }
                    } catch (e) {
                        // Ignore non-JSON or other messages
                    }
                };

                logStreamWs.onclose = () => {
                    btn.textContent = ' Start Stream';
                    btn.classList.remove('streaming');
                    logStreamWs = null;
                };

                logStreamWs.onerror = (err) => {
                    console.error('[LogStream] WebSocket error:', err);
                    btn.textContent = ' Start Stream';
                    btn.classList.remove('streaming');
                };
            }
        }

        // Save session notes
        async function saveSessionNotes() {
            if (!currentDetailSessionId) return;

            const notes = document.getElementById('detail-notes').value;

            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${currentDetailSessionId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': CONTROL_API_KEY
                    },
                    body: JSON.stringify({ notes })
                });

                if (!response.ok) throw new Error('Failed to save notes');

                showSessionNotification('Notes saved');

            } catch (error) {
                console.error('[Detail] Failed to save notes:', error);
                showErrorToast('Error', 'Failed to save notes');
            }
        }

        // View current session on chart
        function viewSessionOnChart() {
            if (currentDetailSessionId) {
                viewSession(currentDetailSessionId);
                closeSessionDetailModal();
            }
        }

        // Clone current session
        async function cloneCurrentSession() {
            if (currentDetailSessionId) {
                await cloneSession(currentDetailSessionId);
                closeSessionDetailModal();
            }
        }

        // Session card clicks now handled inline via onclick attribute in renderSessionCard()
        // Old modal-based click handler removed - using inline detail view instead
        // ============= END SESSION DETAIL MODAL =============

        // Check URL params and open session detail if specified
        async function handleUrlParams() {
            const params = new URLSearchParams(window.location.search);
            const sessionId = params.get('session');
            if (sessionId) {
                console.log(`[URL] Session param detected: ${sessionId}`);

                // Wait for sessions data to be populated
                let attempts = 0;
                while (attempts < 20 && (!sessionsData.running.length && !sessionsData.history.length)) {
                    await new Promise(resolve => setTimeout(resolve, 250));
                    attempts++;
                }
                console.log(`[URL] Sessions loaded after ${attempts} attempts. Running: ${sessionsData.running.length}, History: ${sessionsData.history.length}`);

                // Find which panel the session is in
                let panelType = 'running';
                let foundSession = sessionsData.running.find(s => s.id === sessionId);
                if (foundSession) {
                    panelType = 'running';
                } else if (sessionsData.scrapers.find(s => s.id === sessionId)) {
                    panelType = 'scrapers';
                    foundSession = sessionsData.scrapers.find(s => s.id === sessionId);
                } else if (sessionsData.history.find(s => s.id === sessionId)) {
                    panelType = 'history';
                    foundSession = sessionsData.history.find(s => s.id === sessionId);
                }

                if (!foundSession) {
                    console.error(`[URL] Session not found: ${sessionId}`);
                    return;
                }
                console.log(`[URL] Found session in ${panelType} panel:`, foundSession.name);

                // Switch to the correct sub-tab (uses data-panel attribute)
                const subTabBtn = document.querySelector(`.session-sub-tab[data-panel="${panelType}"]`);
                if (subTabBtn) {
                    console.log(`[URL] Clicking sub-tab for: ${panelType}`);
                    subTabBtn.click();
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                // Open the session detail
                console.log(`[URL] Opening detail view for ${sessionId} (${panelType})`);
                showInlineDetail(sessionId, panelType);
            }
        }

        // Start session polling
        let scraperHeartbeatInterval = null;

        function startSessionPolling() {
            // Initial fetch
            fetchStrategies();
            fetchSessions().then(() => {
                // Check URL params after sessions are loaded
                handleUrlParams();
                // Initial scraper heartbeat fetch
                pollScraperHeartbeats();
            });

            // Poll every 5 seconds
            sessionPollingInterval = setInterval(() => {
                fetchSessions();
            }, SESSION_POLL_INTERVAL);

            // Poll scraper heartbeats every 15 seconds
            scraperHeartbeatInterval = setInterval(() => {
                pollScraperHeartbeats();
            }, 15000);
        }

        // Stop session polling
        function stopSessionPolling() {
            if (sessionPollingInterval) {
                clearInterval(sessionPollingInterval);
                sessionPollingInterval = null;
            }
            if (scraperHeartbeatInterval) {
                clearInterval(scraperHeartbeatInterval);
                scraperHeartbeatInterval = null;
            }
        }

        // Initialize session management on page load
        function initSessionManagement() {
            initSessionSubTabs();

            // Set up event listeners
            document.getElementById('btn-new-session')?.addEventListener('click', () => openNewSessionModal());
            document.getElementById('new-session-type')?.addEventListener('change', updateNewSessionForm);
            document.getElementById('new-session-strategy')?.addEventListener('change', updateStrategyParams);

            // Start polling
            startSessionPolling();
        }

        // ==========================================
        // END SESSION MANAGEMENT
        // ==========================================

        let liveTestRunning = false;
        let liveTestPollingInterval = null;
        let liveTestStartTime = null;
        let currentStrategy = 'TestBot';

        // Bot configurations for display
        const botConfigs = {
            DivergeBot: { icon: '', color: '#00c853', desc: 'Price ratio divergence trading' },
            SazBot: { icon: '', color: '#00d4ff', desc: 'Order book imbalance analysis' },
            SDBot: { icon: '', color: '#ffc107', desc: 'Standard deviation mean reversion' },
            PairTradeBot: { icon: '', color: '#7b2cbf', desc: 'Statistical arbitrage' }
        };

        // Error Toast Functions
        function showErrorToast(title, message, duration = 8000) {
            const toast = document.getElementById('error-toast');
            const titleEl = document.getElementById('error-toast-title');
            const messageEl = document.getElementById('error-toast-message');

            titleEl.textContent = title;
            messageEl.textContent = message;
            toast.classList.add('show');

            // Auto-hide after duration
            if (duration > 0) {
                setTimeout(() => hideErrorToast(), duration);
            }
        }

        function hideErrorToast() {
            document.getElementById('error-toast').classList.remove('show');
        }

        // ==========================================
        // LIVE MARKET DATA FUNCTIONS
        // ==========================================

        let liveMarketChart = null;
        let liveMarketCandleSeries = null;
        let currentMarket = 'xbtusd';
        let currentMarketPeriod = '5m';
        let liveMarketRefreshInterval = null;

        // Live forming candle state
        let formingCandle = null;  // { time, open, high, low, close, volume }
        let lastCandleData = [];   // Store the historical candles for reference

        // Lazy loading state for historical candles
        let earliestCandleTime = null;  // Track earliest loaded candle timestamp
        let isLoadingOlderCandles = false;  // Prevent concurrent fetches
        let archiveMinTime = null;  // Track archive data availability

        // Period duration in seconds
        const PERIOD_SECONDS = {
            '1m': 60,
            '5m': 300,
            '15m': 900,
            '1h': 3600,
            '4h': 14400,
            '1d': 86400,
            '1w': 604800
        };

        // Get the start time for a candle period containing the given timestamp
        function getPeriodStartTime(timestamp, period) {
            const periodSecs = PERIOD_SECONDS[period] || 300;
            return Math.floor(timestamp / periodSecs) * periodSecs;
        }

        // Initialize or update the forming candle from a trade
        function updateFormingCandle(trade) {
            if (!liveMarketCandleSeries) return;

            // Get raw timestamp, defaulting to current time in seconds
            const rawTimestamp = trade.timestamp || Math.floor(Date.now() / 1000);
            // Convert milliseconds to seconds if needed (timestamps > year 2033 are likely in ms)
            const tradeTime = rawTimestamp > 9999999999 ? Math.floor(rawTimestamp / 1000) : rawTimestamp;
            const price = trade.price;
            const amount = trade.amount || 0;
            const periodStart = getPeriodStartTime(tradeTime, currentMarketPeriod);

            // Check if we need to start a new candle (period rolled over)
            if (formingCandle && periodStart > formingCandle.time) {
                // Period ended - the forming candle is now frozen (already in the chart)
                // Start a new forming candle
                formingCandle = {
                    time: periodStart,
                    open: price,
                    high: price,
                    low: price,
                    close: price,
                    volume: amount
                };
                console.log('[LiveCandle] New period started:', new Date(periodStart * 1000).toISOString());
            } else if (!formingCandle) {
                // First trade - initialize forming candle
                formingCandle = {
                    time: periodStart,
                    open: price,
                    high: price,
                    low: price,
                    close: price,
                    volume: amount
                };
                console.log('[LiveCandle] Initialized forming candle:', formingCandle);
            } else {
                // Update existing forming candle
                formingCandle.high = Math.max(formingCandle.high, price);
                formingCandle.low = Math.min(formingCandle.low, price);
                formingCandle.close = price;
                formingCandle.volume += amount;
            }

            // Update the chart with the forming candle
            try {
                liveMarketCandleSeries.update({
                    time: formingCandle.time,
                    open: formingCandle.open,
                    high: formingCandle.high,
                    low: formingCandle.low,
                    close: formingCandle.close
                });
            } catch (err) {
                console.error('[LiveCandle] Update error:', err);
            }
        }

        // Initialize forming candle from loaded historical data
        function initFormingCandleFromData(candles) {
            if (!candles || candles.length === 0) return;

            const lastCandle = candles[candles.length - 1];
            const now = Math.floor(Date.now() / 1000);
            const currentPeriodStart = getPeriodStartTime(now, currentMarketPeriod);

            // If the last candle is from the current period, use it as the forming candle
            if (lastCandle.time === currentPeriodStart) {
                formingCandle = {
                    time: lastCandle.time,
                    open: lastCandle.open,
                    high: lastCandle.high,
                    low: lastCandle.low,
                    close: lastCandle.close,
                    volume: lastCandle.volume || 0
                };
                console.log('[LiveCandle] Restored forming candle from data:', formingCandle);
            } else {
                // Last candle is from a previous period, create a new forming candle
                // Use the last candle's close as the starting point
                formingCandle = {
                    time: currentPeriodStart,
                    open: lastCandle.close,
                    high: lastCandle.close,
                    low: lastCandle.close,
                    close: lastCandle.close,
                    volume: 0
                };
                console.log('[LiveCandle] Created new forming candle from last close:', formingCandle);

                // Add this forming candle to the chart
                try {
                    liveMarketCandleSeries.update({
                        time: formingCandle.time,
                        open: formingCandle.open,
                        high: formingCandle.high,
                        low: formingCandle.low,
                        close: formingCandle.close
                    });
                } catch (err) {
                    console.error('[LiveCandle] Init update error:', err);
                }
            }
        }

        const MARKET_NAMES = {
            'xbtusd': 'BTC/USD',
            'ethusd': 'ETH/USD',
            'solusd': 'SOL/USD',
            'xrpusd': 'XRP/USD',
            'dogeusd': 'DOGE/USD'
        };

        // Strategy descriptions for the Live Test Control panel
        const STRATEGY_DESCRIPTIONS = {
            'none': 'Live market data only. Select a strategy to view trade overlays and backtest results.',
            'TestBot': 'Simple test strategy that trades every 60 seconds for verification purposes.',
            'DivergeBot': 'Arbitrage strategy that detects price divergence between BTC/USD and BTC/USDT markets.',
            'SazBot': 'Order book imbalance strategy analyzing bid/ask ratios at multiple depth levels (1%-25%).',
            'SDBot': 'Supply/demand zone trading based on detecting significant price runs and zone boundaries.',
            'PairTradeBot': 'Statistical arbitrage using mean reversion between correlated trading pairs.',
            'DevDistStatBot': 'Distribution-based mean reversion using statistical z-score bands for entry/exit signals.'
        };

        // Strategy indicator configurations
        const STRATEGY_INDICATORS = {
            'TestBot': [], // Simple - no indicators
            'DivergeBot': [
                { type: 'ema', period: 20, color: '#ff9800', label: 'EMA 20' }
            ],
            'SazBot': [
                { type: 'ema', period: 20, color: '#2196f3', label: 'EMA 20' },
                { type: 'ema', period: 50, color: '#ff9800', label: 'EMA 50' }
            ],
            'SDBot': [
                { type: 'ema', period: 20, color: '#2196f3', label: 'EMA 20' },
                { type: 'ema', period: 50, color: '#ff9800', label: 'EMA 50' },
                { type: 'bollinger', period: 20, stdDev: 2, color: '#9c27b0', label: 'BB' }
            ],
            'PairTradeBot': [
                { type: 'ema', period: 20, color: '#2196f3', label: 'EMA 20' },
                { type: 'ema', period: 50, color: '#ff9800', label: 'EMA 50' }
            ],
            'DevDistStatBot': [
                { type: 'devdiststat_bands', colorMean: '#ffeb3b', colorUpper: '#4caf50', colorLower: '#f44336' }
            ]
        };

        // Indicator line series for live market chart
        let indicatorSeries = {}; // { 'ema_20': lineSeries, 'ema_50': lineSeries, etc. }
        let currentStrategyIndicators = 'TestBot';

        // DevDistStat indicator data parsed from session logs
        let devDistStatIndicatorData = {
            mean: [],   // { time, value }
            upper: [],  // { time, value }
            lower: [],  // { time, value }
            zscore: []  // { time, value } - for optional z-score panel
        };

        // Parse [INDICATOR] logs from session logs
        // Format: [INDICATOR] ts=1706000000 price=89100.00 mean=89108.32 upper=89117.93 lower=89098.71 zscore=-1.732
        function parseDevDistStatIndicatorLogs(logs) {
            const data = { mean: [], upper: [], lower: [], zscore: [] };

            if (!logs || !Array.isArray(logs)) return data;

            for (const log of logs) {
                const msg = log.message || '';
                if (!msg.includes('[INDICATOR]')) continue;

                // Parse key=value pairs
                const tsMatch = msg.match(/ts=(\d+)/);
                const meanMatch = msg.match(/mean=([\d.]+)/);
                const upperMatch = msg.match(/upper=([\d.]+)/);
                const lowerMatch = msg.match(/lower=([\d.]+)/);
                const zscoreMatch = msg.match(/zscore=([-\d.]+)/);

                if (!tsMatch) continue;

                // Convert timestamp to seconds (TradingView expects seconds)
                let time = parseInt(tsMatch[1]);
                if (time > 9999999999) time = Math.floor(time / 1000); // Convert ms to seconds

                if (meanMatch) data.mean.push({ time, value: parseFloat(meanMatch[1]) });
                if (upperMatch) data.upper.push({ time, value: parseFloat(upperMatch[1]) });
                if (lowerMatch) data.lower.push({ time, value: parseFloat(lowerMatch[1]) });
                if (zscoreMatch) data.zscore.push({ time, value: parseFloat(zscoreMatch[1]) });
            }

            // Sort by time (ascending)
            data.mean.sort((a, b) => a.time - b.time);
            data.upper.sort((a, b) => a.time - b.time);
            data.lower.sort((a, b) => a.time - b.time);
            data.zscore.sort((a, b) => a.time - b.time);

            console.log(`[DevDistStat] Parsed ${data.mean.length} indicator points from logs`);
            return data;
        }

        // Load DevDistStat indicators from session logs
        async function loadDevDistStatIndicators(sessionId) {
            try {
                const response = await fetch(`${CONTROL_API_URL}/sessions/${sessionId}/logs?limit=5000`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                if (!response.ok) {
                    console.warn('[DevDistStat] Failed to load logs for indicators');
                    return null;
                }

                const data = await response.json();
                const logs = data.logs || [];

                // Parse indicator data from logs
                devDistStatIndicatorData = parseDevDistStatIndicatorLogs(logs);
                return devDistStatIndicatorData;
            } catch (err) {
                console.error('[DevDistStat] Error loading indicator logs:', err);
                return null;
            }
        }

        // Calculate EMA from candle data
        function calculateEMA(candles, period) {
            if (!candles || candles.length < period) return [];
            const k = 2 / (period + 1);
            const emaData = [];

            // Initialize with SMA for first period
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += candles[i].close;
            }
            let ema = sum / period;
            emaData.push({ time: candles[period - 1].time, value: ema });

            // Calculate EMA for remaining candles
            for (let i = period; i < candles.length; i++) {
                ema = candles[i].close * k + ema * (1 - k);
                emaData.push({ time: candles[i].time, value: ema });
            }
            return emaData;
        }

        // Calculate Bollinger Bands from candle data
        function calculateBollingerBands(candles, period, stdDev) {
            if (!candles || candles.length < period) return { upper: [], middle: [], lower: [] };

            const upper = [], middle = [], lower = [];

            for (let i = period - 1; i < candles.length; i++) {
                // Calculate SMA
                let sum = 0;
                for (let j = i - period + 1; j <= i; j++) {
                    sum += candles[j].close;
                }
                const sma = sum / period;

                // Calculate standard deviation
                let sqSum = 0;
                for (let j = i - period + 1; j <= i; j++) {
                    sqSum += Math.pow(candles[j].close - sma, 2);
                }
                const std = Math.sqrt(sqSum / period);

                const time = candles[i].time;
                middle.push({ time, value: sma });
                upper.push({ time, value: sma + stdDev * std });
                lower.push({ time, value: sma - stdDev * std });
            }

            return { upper, middle, lower };
        }

        // Clear all indicator series from chart
        function clearIndicators() {
            for (const key in indicatorSeries) {
                if (indicatorSeries[key] && liveMarketChart) {
                    try {
                        liveMarketChart.removeSeries(indicatorSeries[key]);
                    } catch (e) {
                        console.warn('[Indicators] Error removing series:', key, e);
                    }
                }
            }
            indicatorSeries = {};
        }

        // Update indicators for the selected strategy
        function updateChartIndicators(strategy) {
            if (!liveMarketChart || !lastCandleData.length) return;

            // Clear existing indicators
            clearIndicators();

            const indicators = STRATEGY_INDICATORS[strategy] || [];
            currentStrategyIndicators = strategy;

            if (indicators.length === 0) {
                console.log('[Indicators] No indicators for', strategy);
                return;
            }

            console.log('[Indicators] Adding indicators for', strategy, ':', indicators.length);

            for (const config of indicators) {
                if (config.type === 'ema') {
                    const emaData = calculateEMA(lastCandleData, config.period);
                    if (emaData.length > 0) {
                        const series = liveMarketChart.addLineSeries({
                            color: config.color,
                            lineWidth: 1,
                            title: config.label,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                        safeSetData(series, emaData, `EMA_${config.period}`);
                        indicatorSeries[`ema_${config.period}`] = series;
                    }
                } else if (config.type === 'bollinger') {
                    const bb = calculateBollingerBands(lastCandleData, config.period, config.stdDev);
                    if (bb.upper.length > 0) {
                        // Upper band
                        const upperSeries = liveMarketChart.addLineSeries({
                            color: config.color,
                            lineWidth: 1,
                            lineStyle: 2, // Dashed
                            title: 'BB Upper',
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                        safeSetData(upperSeries, bb.upper, 'BB_upper');
                        indicatorSeries['bb_upper'] = upperSeries;

                        // Lower band
                        const lowerSeries = liveMarketChart.addLineSeries({
                            color: config.color,
                            lineWidth: 1,
                            lineStyle: 2, // Dashed
                            title: 'BB Lower',
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                        safeSetData(lowerSeries, bb.lower, 'BB_lower');
                        indicatorSeries['bb_lower'] = lowerSeries;

                        console.log(`[Indicators] Added Bollinger Bands with ${bb.upper.length} points`);
                    }
                } else if (config.type === 'devdiststat_bands') {
                    // DevDistStat bands from parsed log data
                    // Validate data - filter out any null/undefined/invalid points
                    const isValidPoint = (p) => p && typeof p.time === 'number' && p.time > 0 && typeof p.value === 'number' && !isNaN(p.value);
                    const validMean = (devDistStatIndicatorData.mean || []).filter(isValidPoint);
                    const validUpper = (devDistStatIndicatorData.upper || []).filter(isValidPoint);
                    const validLower = (devDistStatIndicatorData.lower || []).filter(isValidPoint);

                    console.log(`[Indicators] DevDistStat validation: mean=${validMean.length}, upper=${validUpper.length}, lower=${validLower.length}`);

                    if (validMean.length > 0) {
                        try {
                            // Mean line (yellow - moving average)
                            const meanSeries = liveMarketChart.addLineSeries({
                                color: config.colorMean || '#ffeb3b',
                                lineWidth: 2,
                                title: 'Mean',
                                priceLineVisible: false,
                                lastValueVisible: true
                            });
                            safeSetData(meanSeries, validMean, 'DevDistStat_mean');
                            indicatorSeries['devdist_mean'] = meanSeries;

                            // Upper band (green - overbought zone) - only if has data
                            if (validUpper.length > 0) {
                                const upperSeries = liveMarketChart.addLineSeries({
                                    color: config.colorUpper || '#4caf50',
                                    lineWidth: 1,
                                    lineStyle: 2, // Dashed
                                    title: 'Upper',
                                    priceLineVisible: false,
                                    lastValueVisible: false
                                });
                                safeSetData(upperSeries, validUpper, 'DevDistStat_upper');
                                indicatorSeries['devdist_upper'] = upperSeries;
                            }

                            // Lower band (red - oversold zone) - only if has data
                            if (validLower.length > 0) {
                                const lowerSeries = liveMarketChart.addLineSeries({
                                    color: config.colorLower || '#f44336',
                                    lineWidth: 1,
                                    lineStyle: 2, // Dashed
                                    title: 'Lower',
                                    priceLineVisible: false,
                                    lastValueVisible: false
                                });
                                safeSetData(lowerSeries, validLower, 'DevDistStat_lower');
                                indicatorSeries['devdist_lower'] = lowerSeries;
                            }

                            console.log(`[Indicators] Added DevDistStat bands: mean=${validMean.length}, upper=${validUpper.length}, lower=${validLower.length}`);
                        } catch (chartErr) {
                            console.error('[Indicators] DevDistStat chart error:', chartErr);
                            logJsError('ChartError', `DevDistStat setData: ${chartErr.message}`, '', '', '', chartErr.stack);
                        }
                    } else {
                        console.log('[Indicators] No valid DevDistStat indicator data available');
                    }
                }
            }
        }

        // Update strategy description when selector changes
        function updateStrategyDescription(strategy) {
            const descEl = document.getElementById('strategy-description');
            if (descEl) {
                descEl.textContent = STRATEGY_DESCRIPTIONS[strategy] || 'No description available.';
            }
        }

        // Current dashboard mode ('market' = no strategy, 'strategy' = strategy selected)
        let currentDashboardMode = 'market';

        // Switch dashboard mode based on strategy selection
        // Mode A (market): Live price chart + orderbook + recent trades
        // Mode B (strategy): Price chart with trade overlays + equity curve
        async function switchDashboardMode(mode) {
            const dashboardContent = document.getElementById('dashboard-content');
            const liveMarketContent = document.getElementById('live-market-content');
            const sessionControl = document.getElementById('session-control');
            const exportButtons = document.querySelector('.export-buttons');
            const liveTestPanel = document.getElementById('live-test-panel');
            const liveTradeFeed = document.getElementById('live-trade-feed');
            const equityCurveContainer = document.getElementById('equity-curve-container');
            const tradeOverlayLegend = document.getElementById('trade-overlay-legend');

            currentDashboardMode = mode;

            if (mode === 'market') {
                // Mode A: No strategy selected - show live market view
                if (dashboardContent) {
                    dashboardContent.style.display = 'none';
                    dashboardContent.classList.add('hidden');
                }
                if (liveMarketContent) {
                    liveMarketContent.classList.add('active');
                    liveMarketContent.style.display = 'block';
                }

                // Hide backtest controls
                document.querySelectorAll('.control-group').forEach(el => el.style.display = 'none');
                if (exportButtons) exportButtons.style.display = 'none';
                if (liveTradeFeed) liveTradeFeed.style.display = 'none';
                if (equityCurveContainer) equityCurveContainer.style.display = 'none';
                if (tradeOverlayLegend) tradeOverlayLegend.style.display = 'none';

                // Initialize live market chart
                if (!liveMarketChart) initLiveMarketChart();
                await loadLiveMarketData();
                // Removed polling - using WebSocket for real-time updates only
                connectLiveMarketWebSocket();

                // Clear trade overlays from chart
                clearTradeOverlays();

                // Update chart title
                const chartTitle = document.getElementById('live-chart-title');
                if (chartTitle) chartTitle.textContent = 'BTC/USD Live Price';

            } else if (mode === 'strategy') {
                // Mode B: Strategy selected - show price chart with trade overlays + equity curve
                if (dashboardContent) {
                    dashboardContent.style.display = 'none';
                    dashboardContent.classList.add('hidden');
                }
                if (liveMarketContent) {
                    liveMarketContent.classList.add('active');
                    liveMarketContent.style.display = 'block';
                }

                // Keep live market chart but add trade overlays
                if (!liveMarketChart) initLiveMarketChart();
                await loadLiveMarketData();
                // Removed polling - using WebSocket for real-time updates only
                connectLiveMarketWebSocket();

                // Show equity curve container and trade overlay legend
                if (equityCurveContainer) equityCurveContainer.style.display = 'block';
                if (tradeOverlayLegend) tradeOverlayLegend.style.display = 'flex';

                // Hide other controls
                document.querySelectorAll('.control-group').forEach(el => el.style.display = 'none');
                if (exportButtons) exportButtons.style.display = 'none';
                if (liveTradeFeed) liveTradeFeed.style.display = 'none';

                // Load trade overlays for selected strategy
                await loadTradeOverlays();

                // Load equity curve
                await loadEquityCurve();

                // Update chart title with strategy
                const chartTitle = document.getElementById('live-chart-title');
                if (chartTitle) chartTitle.textContent = `BTC/USD Price with ${currentStrategy} Trades`;
            }
        }

        // Initialize mode switching based on strategy selector
        function initViewToggle() {
            // Mode is now driven by strategy selector
            // This function is kept for backwards compatibility
            // Actual mode switching happens in strategy selector change handler
        }

        // Clear trade overlay markers from the live market chart
        function clearTradeOverlays() {
            if (liveMarketCandleSeries) {
                safeSetMarkers(liveMarketCandleSeries, [], 'clearTradeOverlays');
            }
        }

        // Load and display trade overlays on the live market chart
        async function loadTradeOverlays() {
            console.log('[Trade Overlays] >>> loadTradeOverlays() CALLED <<<');
            console.log(`[Trade Overlays] liveMarketCandleSeries exists: ${!!liveMarketCandleSeries}`);
            console.log(`[Trade Overlays] lastCandleData length: ${lastCandleData?.length || 0}`);
            console.log(`[Trade Overlays] currentStrategy: ${currentStrategy}`);

            if (!liveMarketCandleSeries || !lastCandleData.length) {
                console.log('[Trade Overlays] ABORT: No candle series or candle data available');
                return;
            }
            if (currentStrategy === 'none') {
                console.log('[Trade Overlays] ABORT: Strategy is none, clearing overlays');
                clearTradeOverlays();
                return;
            }

            let trades = [];

            try {
                // Try live test session first
                console.log(`[Trade Overlays] Fetching: ${CONTROL_API_URL}/session/test`);
                const testResponse = await fetch(`${CONTROL_API_URL}/session/test`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                console.log(`[Trade Overlays] /session/test status: ${testResponse.status}`);
                if (testResponse.ok) {
                    const testData = await testResponse.json();
                    if (testData.success && testData.trades && testData.trades.length > 0) {
                        trades = testData.trades;
                        console.log(`[Trade Overlays] Loaded ${trades.length} trades from live test session`);
                    }
                } else if (testResponse.status === 401) {
                    console.warn('[Trade Overlays] /session/test 401 - API key may be invalid');
                }

                // If no live test trades, try backtest session
                if (trades.length === 0) {
                    console.log(`[Trade Overlays] Fetching: ${CONTROL_API_URL}/session/backtest`);
                    const backtestResponse = await fetch(`${CONTROL_API_URL}/session/backtest`, {
                        headers: { 'x-api-key': CONTROL_API_KEY }
                    });
                    console.log(`[Trade Overlays] /session/backtest status: ${backtestResponse.status}`);
                    if (backtestResponse.ok) {
                        const backtestData = await backtestResponse.json();
                        if (backtestData.success && backtestData.trades && backtestData.trades.length > 0) {
                            trades = backtestData.trades;
                            console.log(`[Trade Overlays] Loaded ${trades.length} trades from backtest session`);
                        }
                    } else if (backtestResponse.status === 401) {
                        console.warn('[Trade Overlays] /session/backtest 401 - API key may be invalid');
                    }
                }

                if (trades.length === 0) {
                    console.log('[Trade Overlays] No active session - run a backtest to see trade arrows on chart');
                    clearTradeOverlays();
                    return;
                }

                const markers = [];

                // Helper to find closest candle to a timestamp
                const findClosestCandle = (timestamp) => {
                    return lastCandleData.reduce((prev, curr) => {
                        return Math.abs(curr.time - timestamp) < Math.abs(prev.time - timestamp) ? curr : prev;
                    });
                };

                trades.forEach(trade => {
                    // ENTRY marker - arrow shape
                    const entryTime = trade.timestamp_unix || trade.entry_time_unix;
                    if (entryTime) {
                        const entryCandle = findClosestCandle(entryTime);
                        markers.push({
                            time: entryCandle.time,
                            position: trade.side === 'long' ? 'belowBar' : 'aboveBar',
                            color: trade.side === 'long' ? '#2196F3' : '#FF9800', // Blue for long, orange for short
                            shape: trade.side === 'long' ? 'arrowUp' : 'arrowDown',
                            text: '' // No text to prevent overlap
                        });
                    }

                    // EXIT marker - circle shape (if exit data exists)
                    if (trade.exit_time_unix && trade.exit_price) {
                        const exitCandle = findClosestCandle(trade.exit_time_unix);
                        markers.push({
                            time: exitCandle.time,
                            position: trade.side === 'long' ? 'aboveBar' : 'belowBar',
                            color: trade.pnl >= 0 ? '#00c853' : '#ff5252', // Green for profit, red for loss
                            shape: 'circle',
                            text: ''
                        });
                    }
                });

                // Sort markers by time (required by Lightweight Charts)
                markers.sort((a, b) => a.time - b.time);
                safeSetMarkers(liveMarketCandleSeries, markers, 'loadTradesOntoChart');
                console.log(`[Trade Overlays] Displayed ${markers.length} markers for ${trades.length} trades`);

            } catch (err) {
                console.error('[Trade Overlays] Error loading trades:', err);
            }
        }

        // Equity curve chart instance
        let equityCurveChart = null;
        let equitySeries = null;
        let drawdownSeries = null;

        // Load and display equity curve in the separate chart
        async function loadEquityCurve() {
            const container = document.getElementById('equity-curve-chart-container');
            if (!container) return;

            if (currentStrategy === 'none') {
                // Clear equity curve in market mode
                if (equityCurveChart) {
                    equityCurveChart.remove();
                    equityCurveChart = null;
                    equitySeries = null;
                    drawdownSeries = null;
                }
                return;
            }

            try {
                // Fetch equity curve data from session/test endpoint
                const response = await fetch(`${CONTROL_API_URL}/session/test`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (!response.ok) {
                    console.log('[Equity Curve] No test session data available');
                    return;
                }

                const data = await response.json();
                if (!data.success || !data.equity_curve || data.equity_curve.length === 0) {
                    console.log('[Equity Curve] No equity curve data');
                    // Show empty state
                    if (!equityCurveChart) {
                        initEquityCurveChart(container);
                    }
                    if (equitySeries) safeSetData(equitySeries, [], 'equityCurve_empty');
                    if (drawdownSeries) safeSetData(drawdownSeries, [], 'drawdown_empty');
                    return;
                }

                // Initialize chart if not exists
                if (!equityCurveChart) {
                    initEquityCurveChart(container);
                }

                // Format equity curve data for Lightweight Charts
                const equityData = data.equity_curve.map(point => ({
                    time: point.timestamp_unix,
                    value: point.equity
                }));

                // Format drawdown data (inverted to show below zero line)
                const drawdownData = data.equity_curve.map(point => ({
                    time: point.timestamp_unix,
                    value: -(point.drawdown || 0) / 100  // Negative percentage as decimal
                }));

                safeSetData(equitySeries, equityData, 'equityCurve');
                safeSetData(drawdownSeries, drawdownData, 'drawdown');

                // Update title with strategy name
                const titleEl = document.getElementById('equity-chart-title');
                if (titleEl) titleEl.textContent = `${currentStrategy} Equity Curve`;

                equityCurveChart.timeScale().fitContent();
                console.log(`[Equity Curve] Loaded ${equityData.length} points`);

            } catch (err) {
                console.error('[Equity Curve] Error loading data:', err);
            }
        }

        // Initialize the equity curve chart
        function initEquityCurveChart(container) {
            equityCurveChart = LightweightCharts.createChart(container, {
                layout: { background: { type: 'solid', color: 'transparent' }, textColor: '#8892b0' },
                grid: { vertLines: { color: 'rgba(255,255,255,0.05)' }, horzLines: { color: 'rgba(255,255,255,0.05)' } },
                timeScale: { timeVisible: true, secondsVisible: false, borderColor: 'rgba(255,255,255,0.1)' },
                rightPriceScale: { borderColor: 'rgba(255,255,255,0.1)', autoScale: true },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                height: 200
            });

            equitySeries = equityCurveChart.addLineSeries({
                color: '#4caf50',
                lineWidth: 2,
                priceScaleId: 'right'
            });

            drawdownSeries = equityCurveChart.addAreaSeries({
                topColor: 'rgba(255, 82, 82, 0.4)',
                bottomColor: 'rgba(255, 82, 82, 0.1)',
                lineColor: '#ff5252',
                lineWidth: 1,
                priceScaleId: 'left'
            });

            // Configure left scale for drawdown
            equityCurveChart.applyOptions({
                leftPriceScale: {
                    visible: true,
                    borderColor: 'rgba(255,255,255,0.1)',
                    autoScale: true
                }
            });

            // Resize observer
            const resizeObserver = new ResizeObserver(() => {
                equityCurveChart.applyOptions({ width: container.clientWidth });
            });
            resizeObserver.observe(container);

            // Apply adaptive time formatting for zoom
            setupAdaptiveTimeFormat(equityCurveChart);
        }

        // Volume series for live market chart
        let liveMarketVolumeSeries = null;

        // Initialize live market chart
        function initLiveMarketChart() {
            const container = document.getElementById('live-price-chart-container');
            if (!container) return;

            // Get initial dimensions from container
            const initialWidth = container.clientWidth || 800;
            const initialHeight = container.clientHeight || 400;

            liveMarketChart = LightweightCharts.createChart(container, {
                width: initialWidth,
                height: initialHeight,
                layout: { background: { type: 'solid', color: 'transparent' }, textColor: '#8892b0' },
                grid: { vertLines: { color: 'rgba(255,255,255,0.05)' }, horzLines: { color: 'rgba(255,255,255,0.05)' } },
                timeScale: { timeVisible: true, secondsVisible: false, borderColor: 'rgba(255,255,255,0.1)' },
                rightPriceScale: { borderColor: 'rgba(255,255,255,0.1)', autoScale: true, scaleMargins: { top: 0.1, bottom: 0.25 } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal }
            });

            liveMarketCandleSeries = liveMarketChart.addCandlestickSeries({
                upColor: '#26a69a', downColor: '#ef5350', borderVisible: false,
                wickUpColor: '#26a69a', wickDownColor: '#ef5350'
            });

            // Add volume histogram series below the candlesticks
            liveMarketVolumeSeries = liveMarketChart.addHistogramSeries({
                color: '#26a69a',
                priceFormat: { type: 'volume' },
                priceScaleId: 'volume',
            });

            // Configure volume scale to appear at the bottom
            liveMarketChart.priceScale('volume').applyOptions({
                scaleMargins: { top: 0.85, bottom: 0 },
                borderVisible: false,
            });

            // Subscribe to crosshair move for OHLC display
            liveMarketChart.subscribeCrosshairMove((param) => {
                updateOHLCDisplay(param);
            });

            // ResizeObserver to handle container size changes - update BOTH width AND height
            const resizeObserver = new ResizeObserver((entries) => {
                for (const entry of entries) {
                    const { width, height } = entry.contentRect;
                    if (width > 0 && height > 0) {
                        liveMarketChart.applyOptions({ width, height });
                    }
                }
            });
            resizeObserver.observe(container);

            // Initial resize to fill container - retry multiple times for mobile layout
            const retryResize = (attempts = 0) => {
                if (attempts >= 5) return; // Max 5 attempts
                const w = container.clientWidth;
                const h = container.clientHeight;
                if (w > 0 && h > 0) {
                    liveMarketChart.applyOptions({ width: w, height: h });
                } else {
                    // Container not ready, retry after delay
                    setTimeout(() => retryResize(attempts + 1), 100 * (attempts + 1));
                }
            };
            setTimeout(() => retryResize(0), 50);

            // Subscribe to visible range changes for lazy loading
            liveMarketChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
                if (!logicalRange || !lastCandleData.length || isLoadingOlderCandles) return;

                // Check if user has scrolled near the left edge (first 10% of visible range)
                const visibleBarsCount = logicalRange.to - logicalRange.from;
                const leftEdgeThreshold = Math.max(5, Math.floor(visibleBarsCount * 0.1));

                // If logicalRange.from is close to 0, user is at the start of data
                if (logicalRange.from < leftEdgeThreshold) {
                    loadOlderCandles();
                }
            });
        }

        // Update OHLC display on crosshair move
        function updateOHLCDisplay(param) {
            const openEl = document.getElementById('ohlc-open');
            const highEl = document.getElementById('ohlc-high');
            const lowEl = document.getElementById('ohlc-low');
            const closeEl = document.getElementById('ohlc-close');
            const volumeEl = document.getElementById('ohlc-volume');

            if (!openEl || !highEl || !lowEl || !closeEl) return;

            if (!param || !param.time || !param.seriesData) {
                // Reset to latest candle when crosshair is not on chart
                if (lastCandleData && lastCandleData.length > 0) {
                    const latest = lastCandleData[lastCandleData.length - 1];
                    openEl.textContent = formatPrice(latest.open);
                    highEl.textContent = formatPrice(latest.high);
                    lowEl.textContent = formatPrice(latest.low);
                    closeEl.textContent = formatPrice(latest.close);
                    if (volumeEl) volumeEl.textContent = formatVolume(latest.volume || 0);

                    // Set colors based on candle direction
                    const isUp = latest.close >= latest.open;
                    const color = isUp ? 'up' : 'down';
                    [openEl, highEl, lowEl, closeEl].forEach(el => {
                        el.classList.remove('up', 'down');
                        el.classList.add(color);
                    });
                }
                return;
            }

            // Get candle data at crosshair position
            const candleData = param.seriesData.get(liveMarketCandleSeries);
            if (candleData) {
                openEl.textContent = formatPrice(candleData.open);
                highEl.textContent = formatPrice(candleData.high);
                lowEl.textContent = formatPrice(candleData.low);
                closeEl.textContent = formatPrice(candleData.close);

                // Get volume data
                const volumeData = param.seriesData.get(liveMarketVolumeSeries);
                if (volumeEl && volumeData) {
                    volumeEl.textContent = formatVolume(volumeData.value || 0);
                }

                // Set colors based on candle direction
                const isUp = candleData.close >= candleData.open;
                const color = isUp ? 'up' : 'down';
                [openEl, highEl, lowEl, closeEl].forEach(el => {
                    el.classList.remove('up', 'down');
                    el.classList.add(color);
                });
            }
        }

        // Format price for OHLC display
        function formatPrice(price) {
            if (price >= 10000) return price.toFixed(1);
            if (price >= 1000) return price.toFixed(2);
            if (price >= 1) return price.toFixed(4);
            return price.toFixed(6);
        }

        // Format volume for OHLC display
        function formatVolume(volume) {
            if (volume >= 1000000) return (volume / 1000000).toFixed(2) + 'M';
            if (volume >= 1000) return (volume / 1000).toFixed(1) + 'K';
            return volume.toFixed(0);
        }

        // Format trade size - removes unnecessary decimal places
        function formatTradeSize(size) {
            if (size == null) return '-';
            const num = parseFloat(size);
            if (isNaN(num)) return size;
            // If whole number, show no decimals
            if (num === Math.floor(num)) return num.toFixed(0);
            // Otherwise show up to 2 decimals, trimming trailing zeros
            return parseFloat(num.toFixed(2)).toString();
        }

        // Update volume series with candle data
        function updateVolumeSeries(candles) {
            if (!liveMarketVolumeSeries || !candles || candles.length === 0) return;

            // Check if we have real volume data
            const hasVolume = candles.some(c => c.volume && c.volume > 0);
            console.log(`[Volume] Has real volume data: ${hasVolume}, candles: ${candles.length}`);

            const volumeData = candles.map(c => {
                // Use real volume if available, otherwise generate synthetic volume based on price movement
                let volume = c.volume || 0;
                if (!hasVolume) {
                    // Generate synthetic volume: larger moves = more volume
                    const priceRange = Math.abs(c.high - c.low);
                    const avgPrice = (c.high + c.low) / 2;
                    volume = priceRange / avgPrice * 1000000; // Synthetic volume based on volatility
                }
                return {
                    time: c.time,
                    value: volume,
                    color: c.close >= c.open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                };
            });

            safeSetData(liveMarketVolumeSeries, volumeData, 'updateVolumeSeries');
        }

        // Load older candles when user scrolls left
        async function loadOlderCandles() {
            if (isLoadingOlderCandles || !earliestCandleTime) return;

            // Check if we've already loaded all available archive data
            if (archiveMinTime && earliestCandleTime <= archiveMinTime) {
                console.log('[LazyLoad] Already at archive start, no more data available');
                return;
            }

            isLoadingOlderCandles = true;
            const chartTitle = document.getElementById('live-chart-title');
            const originalTitle = chartTitle?.textContent || '';

            try {
                // Show loading indicator
                if (chartTitle) {
                    chartTitle.textContent = originalTitle.replace(')', '   Loading older...)').replace('))', ')');
                }

                // Calculate time range to fetch (go back by period-appropriate amount)
                const periodSeconds = PERIOD_SECONDS[currentMarketPeriod] || 300;
                const candlesToFetch = 200; // Fetch ~200 candles at a time
                const fetchDuration = candlesToFetch * periodSeconds;

                const endTime = earliestCandleTime - 1; // Just before our earliest
                const startTime = endTime - fetchDuration;

                console.log(`[LazyLoad] Fetching older candles: ${new Date(startTime * 1000).toISOString()} to ${new Date(endTime * 1000).toISOString()}`);

                const response = await fetch(
                    `${CONTROL_API_URL}/api/prices?market=${currentMarket}&period=${currentMarketPeriod}&startTime=${startTime}&endTime=${endTime}&source=archive`,
                    { headers: { 'x-api-key': CONTROL_API_KEY } }
                );

                if (!response.ok) throw new Error('Failed to fetch older candles');
                const data = await response.json();

                if (data.success && data.candles && data.candles.length > 0) {
                    const olderCandles = data.candles.map(c => ({
                        time: c.time, open: c.open, high: c.high, low: c.low, close: c.close,
                        volume: c.volume || 0
                    }));

                    // Filter out any duplicates (candles we already have)
                    const existingTimes = new Set(lastCandleData.map(c => c.time));
                    const newCandles = olderCandles.filter(c => !existingTimes.has(c.time));

                    if (newCandles.length > 0) {
                        // Prepend new candles to existing data
                        lastCandleData = [...newCandles, ...lastCandleData];
                        // Sort by time to ensure correct order
                        lastCandleData.sort((a, b) => a.time - b.time);

                        // Update earliest time
                        earliestCandleTime = lastCandleData[0].time;

                        // Update chart with all data
                        safeSetData(liveMarketCandleSeries, lastCandleData, 'loadOlderCandles');

                        // Update volume series
                        updateVolumeSeries(lastCandleData);

                        // Re-calculate and update indicators with new data
                        updateChartIndicators(currentStrategyIndicators);

                        console.log(`[LazyLoad] Added ${newCandles.length} older candles, total: ${lastCandleData.length}`);

                        // Update title with new candle count
                        if (chartTitle) {
                            chartTitle.textContent = `${MARKET_NAMES[currentMarket]} Price ( Archive  ${lastCandleData.length} candles   Live)`;
                        }
                    } else {
                        console.log('[LazyLoad] No new candles in response (all duplicates)');
                        // Restore original title
                        if (chartTitle) chartTitle.textContent = originalTitle;
                    }
                } else {
                    console.log('[LazyLoad] No older data available');
                    // Restore original title
                    if (chartTitle) chartTitle.textContent = originalTitle;
                }
            } catch (err) {
                console.error('[LazyLoad] Error:', err);
                // Restore original title
                if (chartTitle) chartTitle.textContent = originalTitle;
            } finally {
                isLoadingOlderCandles = false;
            }
        }

        // Fetch archive info to know the available data range
        async function fetchArchiveInfo(market) {
            try {
                const response = await fetch(
                    `${CONTROL_API_URL}/api/archive/info?market=${market}`,
                    { headers: { 'x-api-key': CONTROL_API_KEY } }
                );
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.archive?.available) {
                        archiveMinTime = data.archive.minTime;
                        console.log(`[Archive] Data available from ${new Date(archiveMinTime * 1000).toISOString()}`);
                    }
                }
            } catch (err) {
                console.error('[Archive] Error fetching archive info:', err);
            }
        }

        // Load all live market data
        async function loadLiveMarketData() {
            const refreshBtn = document.getElementById('refresh-market-btn');
            if (refreshBtn) { refreshBtn.disabled = true; refreshBtn.textContent = ' Loading...'; }
            try {
                await Promise.all([loadPriceData(), loadOrderbookData(), loadTradesData()]);
            } catch (err) { console.error('Error loading market data:', err); }
            finally { if (refreshBtn) { refreshBtn.disabled = false; refreshBtn.textContent = ' Refresh'; } }
        }

        // Load price/candle data
        async function loadPriceData() {
            const chartTitle = document.getElementById('live-chart-title');
            const priceDisplay = document.getElementById('current-market-price');

            // Show loading state
            chartTitle.textContent = `${MARKET_NAMES[currentMarket]} Price ( Loading...)`;
            priceDisplay.textContent = '...';

            try {
                // Use hybrid source to combine archive (historical) + MySQL (recent) data
                const response = await fetch(`${CONTROL_API_URL}/api/prices?market=${currentMarket}&period=${currentMarketPeriod}&limit=500&source=hybrid`,
                    { headers: { 'x-api-key': CONTROL_API_KEY } });
                if (!response.ok) throw new Error('Failed to fetch prices');
                const data = await response.json();
                if (data.success && data.candles && data.candles.length > 0) {
                    const candles = data.candles.map(c => ({
                        time: c.time, open: c.open, high: c.high, low: c.low, close: c.close,
                        volume: c.volume || 0
                    }));
                    lastCandleData = candles; // Store for reference
                    earliestCandleTime = candles[0].time; // Track earliest for lazy loading
                    safeSetData(liveMarketCandleSeries, candles, 'loadLiveMarketData');

                    // Update volume series
                    updateVolumeSeries(candles);

                    // Update OHLC display with latest candle
                    updateOHLCDisplay(null);

                    // Re-render trade markers with new candle data (if viewing a session)
                    if (currentSessionTradeData) {
                        displaySessionTrades(currentSessionTradeData);
                    }

                    // Fetch archive info for lazy loading bounds (don't await, do in background)
                    fetchArchiveInfo(currentMarket);

                    // Update chart indicators for selected strategy
                    const selectedStrategy = document.getElementById('strategy-selector')?.value || 'TestBot';
                    updateChartIndicators(selectedStrategy);

                    // Show only recent data (scroll to right) instead of all data
                    // This prevents large time gaps from compressing the visible candles
                    const lastTime = candles[candles.length - 1].time;
                    // Scale visible range based on period for appropriate candle count
                    const hoursToShowByPeriod = {
                        '1m': 6,      // 360 candles
                        '5m': 6,      // 72 candles
                        '15m': 12,    // 48 candles
                        '1h': 24,     // 24 candles
                        '4h': 96,     // 24 candles (4 days)
                        '1d': 720,    // 30 candles (30 days)
                        '1w': 2520    // 15 candles (105 days)
                    };
                    const hoursToShow = hoursToShowByPeriod[currentMarketPeriod] || 6;
                    const visibleFrom = lastTime - (hoursToShow * 3600);
                    liveMarketChart.timeScale().setVisibleRange({
                        from: visibleFrom,
                        to: lastTime + 300 // Small buffer for forming candle
                    });

                    // Force price scale to auto-fit the visible data
                    liveMarketChart.priceScale('right').applyOptions({
                        autoScale: true,
                        scaleMargins: { top: 0.1, bottom: 0.1 }
                    });

                    // Initialize the forming candle from loaded data
                    initFormingCandleFromData(candles);

                    const lastCandle = data.candles[data.candles.length - 1];
                    const firstCandle = data.candles[0];
                    priceDisplay.textContent = formatMarketPrice(lastCandle.close, currentMarket);
                    const change = ((lastCandle.close - firstCandle.open) / firstCandle.open * 100).toFixed(2);
                    const changeBadge = document.getElementById('price-change-badge');
                    const changeValue = document.getElementById('price-change-value');
                    changeValue.textContent = `${change >= 0 ? '+' : ''}${change}%`;
                    changeBadge.className = `price-change ${change >= 0 ? 'positive' : 'negative'}`;

                    // Update professional trading header
                    updateTradingHeader(lastCandle.close, parseFloat(change));

                    // Calculate 24h high/low from candles
                    const high24h = Math.max(...data.candles.map(c => c.high));
                    const low24h = Math.min(...data.candles.map(c => c.low));
                    const highEl = document.getElementById('header-high');
                    const lowEl = document.getElementById('header-low');
                    if (highEl) highEl.textContent = formatMarketPrice(high24h, currentMarket);
                    if (lowEl) lowEl.textContent = formatMarketPrice(low24h, currentMarket);

                    // Update candle count in toolbar
                    const candleCountEl = document.getElementById('candle-count');
                    if (candleCountEl) candleCountEl.textContent = `${data.candles.length} candles`;

                    // Show data source and candle count
                    const sourceLabels = { 'archive': ' Archive', 'mysql': ' Live', 'hybrid': ' Combined' };
                    const sourceLabel = sourceLabels[data.source] || data.source;
                    chartTitle.textContent = `${MARKET_NAMES[currentMarket]} Price (${sourceLabel}  ${data.candleCount || data.candles.length} candles   Live)`;
                } else {
                    chartTitle.textContent = `${MARKET_NAMES[currentMarket]} Price (No data)`;
                    priceDisplay.textContent = '--';
                }
            } catch (err) {
                console.error('Error loading price data:', err);
                chartTitle.textContent = `${MARKET_NAMES[currentMarket]} Price (Error)`;
                priceDisplay.textContent = '--';
            }
        }

        // Load orderbook data
        async function loadOrderbookData() {
            const spreadEl = document.getElementById('orderbook-spread');
            spreadEl.textContent = 'Loading...';

            try {
                const response = await fetch(`${CONTROL_API_URL}/api/orderbook?market=${currentMarket}&depth=12`,
                    { headers: { 'x-api-key': CONTROL_API_KEY } });
                if (!response.ok) throw new Error('Failed to fetch orderbook');
                const data = await response.json();
                if (data.success) {
                    // Use professional orderbook rendering
                    renderOrderbookPro(data.bids || [], data.asks || []);
                    if (data.bids?.length && data.asks?.length) {
                        const spread = data.asks[0].price - data.bids[0].price;
                        const spreadPct = (spread / data.asks[0].price * 100).toFixed(3);
                        if (spreadEl) spreadEl.textContent = `Spread: ${formatMarketPrice(spread, currentMarket)} (${spreadPct}%)`;
                    } else {
                        if (spreadEl) spreadEl.textContent = 'No data';
                    }
                }
            } catch (err) {
                console.error('Error loading orderbook:', err);
                spreadEl.textContent = 'Error loading';
            }
        }

        // Render orderbook (legacy + pro)
        function renderOrderbook(bids, asks) {
            // Render pro orderbook
            renderOrderbookPro(bids, asks);

            // Legacy orderbook rendering
            const bidsContainer = document.getElementById('orderbook-bids');
            const asksContainer = document.getElementById('orderbook-asks');
            if (!bidsContainer || !asksContainer) return;

            const allAmounts = [...bids, ...asks].map(o => o.amount);
            const maxAmount = Math.max(...allAmounts);
            bidsContainer.innerHTML = bids.slice(0, 10).map(bid => {
                const barWidth = (bid.amount / maxAmount * 100).toFixed(1);
                return `<div class="orderbook-row"><span class="bar" style="width: ${barWidth}%"></span><span class="price">${formatMarketPrice(bid.price, currentMarket)}</span><span class="amount">${formatMarketAmount(bid.amount)}</span></div>`;
            }).join('');
            asksContainer.innerHTML = asks.slice(0, 10).map(ask => {
                const barWidth = (ask.amount / maxAmount * 100).toFixed(1);
                return `<div class="orderbook-row"><span class="bar" style="width: ${barWidth}%"></span><span class="price">${formatMarketPrice(ask.price, currentMarket)}</span><span class="amount">${formatMarketAmount(ask.amount)}</span></div>`;
            }).join('');
        }

        // Load trades data
        async function loadTradesData() {
            const countEl = document.getElementById('trades-count');
            countEl.textContent = 'Loading...';

            try {
                const response = await fetch(`${CONTROL_API_URL}/api/trades?market=${currentMarket}&limit=50`,
                    { headers: { 'x-api-key': CONTROL_API_KEY } });
                if (!response.ok) throw new Error('Failed to fetch trades');
                const data = await response.json();
                if (data.success && data.trades) {
                    renderLiveMarketTrades(data.trades);
                    countEl.textContent = `${data.trades.length} trades`;
                } else {
                    countEl.textContent = 'No trades';
                }
            } catch (err) {
                console.error('Error loading trades:', err);
                countEl.textContent = 'Error';
            }
        }

        // Render live market trades (renamed to avoid collision with backtest renderTrades)
        function renderLiveMarketTrades(trades) {
            // Update professional trades panel
            renderTradesPro(trades);

            // Legacy table update
            const tbody = document.getElementById('trades-tbody');
            if (tbody) {
                tbody.innerHTML = trades.map(trade => {
                    const time = new Date(trade.timestamp * 1000).toLocaleTimeString();
                    const sideClass = trade.side === 'buy' ? 'side-buy' : 'side-sell';
                    return `<tr><td>${time}</td><td class="${sideClass}">${trade.side.toUpperCase()}</td><td>${formatMarketPrice(trade.price, currentMarket)}</td><td>${formatMarketAmount(trade.amount)}</td></tr>`;
                }).join('');
            }
        }

        // Format price based on market
        function formatMarketPrice(price, market) {
            if (market === 'dogeusd' || market === 'xrpusd') return price.toFixed(4);
            else if (market === 'solusd') return price.toFixed(2);
            return price.toFixed(1);
        }

        // Format amount - clean decimal formatting
        function formatMarketAmount(amount) {
            if (amount == null) return '-';
            const num = parseFloat(amount);
            if (isNaN(num)) return amount;
            if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            // For amounts < 1000: show clean decimals (max 2 places, trim trailing zeros)
            if (num === Math.floor(num)) return num.toFixed(0);
            return parseFloat(num.toFixed(2)).toString();
        }

        // === PROFESSIONAL UI FUNCTIONS ===

        // Update header with current price and stats
        function updateTradingHeader(price, change24h = null) {
            const priceValueEl = document.getElementById('price-value');
            const priceMainEl = document.getElementById('header-price');
            const priceArrowEl = document.getElementById('price-arrow');
            const changeEl = document.getElementById('header-change');
            const markEl = document.getElementById('header-mark');

            if (priceValueEl && price) {
                // Format with comma separators
                const formattedPrice = price.toLocaleString('en-US', { minimumFractionDigits: 1, maximumFractionDigits: 1 });
                priceValueEl.textContent = formattedPrice;
            }

            if (priceMainEl && change24h !== null) {
                priceMainEl.className = 'price-main' + (change24h >= 0 ? '' : ' down');
            }

            if (priceArrowEl && change24h !== null) {
                priceArrowEl.textContent = change24h >= 0 ? '' : '';
            }

            if (changeEl && change24h !== null) {
                const changePercent = Math.abs(change24h).toFixed(2);
                changeEl.textContent = (change24h >= 0 ? '+' : '-') + changePercent + '%';
                changeEl.className = 'price-change' + (change24h >= 0 ? ' positive' : '');
            }

            if (markEl && price) {
                markEl.textContent = price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }

            // Update instrument name based on market
            const instrumentEl = document.getElementById('header-instrument');
            if (instrumentEl) {
                const names = { xbtusd: 'BTCUSD', ethusd: 'ETHUSD', solusd: 'SOLUSD', xrpusd: 'XRPUSD', dogeusd: 'DOGEUSD' };
                instrumentEl.textContent = names[currentMarket] || 'BTCUSD';
            }
        }

        // Render orderbook in professional format
        function renderOrderbookPro(bids, asks) {
            const bidsContainer = document.getElementById('orderbook-bids-pro');
            const asksContainer = document.getElementById('orderbook-asks-pro');
            const spreadRow = document.getElementById('spread-row');
            const spreadHeader = document.getElementById('orderbook-spread-header');

            if (!bidsContainer || !asksContainer) return;

            // Calculate totals and max for depth bars
            // Show up to 15 levels each side
            let bidTotal = 0, askTotal = 0;
            const bidRows = bids.slice(0, 15).map(b => { bidTotal += b.amount; return { ...b, total: bidTotal }; });
            // Asks: calculate totals in original order (lowest first), then reverse for display (highest at top, lowest at bottom near spread)
            const askRowsRaw = asks.slice(0, 15).map(a => { askTotal += a.amount; return { ...a, total: askTotal }; });
            const askRows = askRowsRaw.reverse();  // Now highest price at top, lowest at bottom
            const maxTotal = Math.max(bidTotal, askTotal);

            // Render asks (sells) - highest at top, lowest at bottom (near spread)
            asksContainer.innerHTML = askRows.map(ask => {
                const depth = (ask.total / maxTotal * 100).toFixed(0);
                return `<div class="orderbook-row ask">
                    <span class="depth-bar" style="width: ${depth}%"></span>
                    <span class="ob-price">${formatMarketPrice(ask.price, currentMarket)}</span>
                    <span class="ob-size">${formatMarketAmount(ask.amount)}</span>
                    <span class="ob-total">${formatMarketAmount(ask.total)}</span>
                </div>`;
            }).join('');

            // Spread
            if (bids.length && asks.length) {
                const spread = asks[0].price - bids[0].price;
                const spreadPercent = (spread / asks[0].price * 100).toFixed(3);
                if (spreadRow) spreadRow.textContent = `Spread: ${formatMarketPrice(spread, currentMarket)} (${spreadPercent}%)`;
                if (spreadHeader) spreadHeader.textContent = `Spread: ${spreadPercent}%`;
            }

            // Render bids (buys)
            bidsContainer.innerHTML = bidRows.map(bid => {
                const depth = (bid.total / maxTotal * 100).toFixed(0);
                return `<div class="orderbook-row bid">
                    <span class="depth-bar" style="width: ${depth}%"></span>
                    <span class="ob-price">${formatMarketPrice(bid.price, currentMarket)}</span>
                    <span class="ob-size">${formatMarketAmount(bid.amount)}</span>
                    <span class="ob-total">${formatMarketAmount(bid.total)}</span>
                </div>`;
            }).join('');
            // Note: Don't call renderOrderbook here - it already calls us (avoid circular call)
        }

        // Render trades in professional format
        function renderTradesPro(trades) {
            const container = document.getElementById('recent-trades-pro');
            const countEl = document.getElementById('trades-count');
            if (!container) return;

            container.innerHTML = trades.slice(0, 30).map(trade => {
                const time = new Date(trade.timestamp * 1000).toLocaleTimeString('en-US', { hour12: false });
                const side = trade.side === 'buy' ? 'BUY' : 'SELL';
                return `<div class="trade-row ${trade.side}">
                    <span class="trade-time">${time}</span>
                    <span class="trade-side">${side}</span>
                    <span class="trade-price">${formatMarketPrice(trade.price, currentMarket)}</span>
                    <span class="trade-size">${formatMarketAmount(trade.amount)}</span>
                </div>`;
            }).join('');

            if (countEl) countEl.textContent = trades.length;
        }

        // Initialize period dropdown
        function initPeriodDropdown() {
            const btn = document.getElementById('period-btn');
            const menu = document.getElementById('period-menu');
            const label = document.getElementById('period-label');

            if (!btn || !menu) return;

            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                menu.classList.toggle('show');
            });

            document.addEventListener('click', () => menu.classList.remove('show'));

            menu.querySelectorAll('.period-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    const period = opt.dataset.period;
                    currentMarketPeriod = period;
                    if (label) label.textContent = period;
                    menu.querySelectorAll('.period-option').forEach(o => o.classList.remove('active'));
                    opt.classList.add('active');
                    menu.classList.remove('show');
                    formingCandle = null;
                    earliestCandleTime = null;
                    isLoadingOlderCandles = false;
                    clearIndicators();
                    loadPriceData();
                });
            });
        }

        // Initialize bottom period selector (time range buttons)
        function initChartPeriodBar() {
            const buttons = document.querySelectorAll('.chart-period-btn');
            if (!buttons.length) return;

            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const range = btn.dataset.range;
                    if (!range || !lastCandleData || lastCandleData.length === 0) return;

                    // Update active state
                    buttons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Calculate time range based on selection
                    const lastTime = lastCandleData[lastCandleData.length - 1].time;
                    let hoursBack;

                    switch (range) {
                        case '1y': hoursBack = 24 * 365; break;
                        case '1m': hoursBack = 24 * 30; break;
                        case '5d': hoursBack = 24 * 5; break;
                        case '1d': hoursBack = 24; break;
                        case '5h': hoursBack = 5; break;
                        default: hoursBack = 24;
                    }

                    const visibleFrom = lastTime - (hoursBack * 3600);
                    liveMarketChart.timeScale().setVisibleRange({
                        from: visibleFrom,
                        to: lastTime + 300
                    });
                });
            });
        }

        // Initialize live market controls
        function initLiveMarketControls() {
            const marketSelector = document.getElementById('market-selector');
            const marketSelectorSecondary = document.getElementById('market-selector-secondary');
            const periodSelector = document.getElementById('market-period-selector');
            const refreshBtn = document.getElementById('refresh-market-btn');

            console.log('[Market] initLiveMarketControls called', {
                marketSelector: !!marketSelector,
                marketSelectorSecondary: !!marketSelectorSecondary
            });

            // Common handler for market change
            function handleMarketChange(newMarket, sourceSelector) {
                console.log('[Market] handleMarketChange called:', newMarket, 'from:', sourceSelector?.id);
                currentMarket = newMarket;
                formingCandle = null; // Reset forming candle on market change
                earliestCandleTime = null; // Reset lazy loading state
                archiveMinTime = null;
                isLoadingOlderCandles = false;
                clearIndicators(); // Clear indicators before loading new data
                console.log('[Market] Calling loadLiveMarketData for:', currentMarket);
                loadLiveMarketData();
                console.log('[Market] Calling subscribeToMarket for:', currentMarket);
                subscribeToMarket(currentMarket);

                // Sync the other selector
                if (sourceSelector !== marketSelector && marketSelector) {
                    marketSelector.value = newMarket;
                }
                if (sourceSelector !== marketSelectorSecondary && marketSelectorSecondary) {
                    marketSelectorSecondary.value = newMarket;
                }
            }

            if (marketSelector) {
                console.log('[Market] Adding change listener to market-selector');
                marketSelector.addEventListener('change', (e) => {
                    console.log('[Market] market-selector change event fired:', e.target.value);
                    handleMarketChange(e.target.value, marketSelector);
                });
            }
            if (marketSelectorSecondary) {
                console.log('[Market] Adding change listener to market-selector-secondary');
                marketSelectorSecondary.addEventListener('change', (e) => {
                    console.log('[Market] market-selector-secondary change event fired:', e.target.value);
                    handleMarketChange(e.target.value, marketSelectorSecondary);
                });
            }
            if (periodSelector) periodSelector.addEventListener('change', (e) => {
                currentMarketPeriod = e.target.value;
                formingCandle = null; // Reset forming candle on period change
                earliestCandleTime = null; // Reset lazy loading state
                isLoadingOlderCandles = false;
                clearIndicators(); // Clear indicators before loading new data
                loadPriceData();
            });
            if (refreshBtn) refreshBtn.addEventListener('click', loadLiveMarketData);
        }

        // ==========================================
        // LIVE MARKET WEBSOCKET
        // ==========================================
        let liveMarketWs = null;
        let liveMarketWsReconnectTimer = null;

        function connectLiveMarketWebSocket() {
            if (liveMarketWs && liveMarketWs.readyState === WebSocket.OPEN) return;

            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsHost = CONTROL_API_URL.replace(/^https?:/, wsProtocol);
            const wsUrl = `${wsHost}/trades/stream`;

            console.log('[LiveMarket WS] Connecting to:', wsUrl);
            liveMarketWs = new WebSocket(wsUrl);

            liveMarketWs.onopen = () => {
                console.log('[LiveMarket WS] Connected');
                subscribeToMarket(currentMarket);
            };

            liveMarketWs.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'market_update') {
                        handleMarketUpdate(data);
                    }
                } catch (err) {
                    console.error('[LiveMarket WS] Parse error:', err);
                }
            };

            liveMarketWs.onclose = () => {
                console.log('[LiveMarket WS] Disconnected, reconnecting in 5s...');
                liveMarketWsReconnectTimer = setTimeout(connectLiveMarketWebSocket, 5000);
            };

            liveMarketWs.onerror = (err) => {
                console.error('[LiveMarket WS] Error:', err);
            };
        }

        function subscribeToMarket(market) {
            if (liveMarketWs && liveMarketWs.readyState === WebSocket.OPEN) {
                liveMarketWs.send(JSON.stringify({ type: 'subscribe', channel: 'market', market: market }));
                console.log('[LiveMarket WS] Subscribed to:', market);
            }
        }

        function handleMarketUpdate(data) {
            // Update price display
            if (data.price) {
                const priceEl = document.getElementById('current-market-price');
                if (priceEl) priceEl.textContent = formatMarketPrice(data.price.value, data.market);

                // Update professional trading header
                updateTradingHeader(data.price.value, data.price.change24h || null);

                // Update forming candle with current price if we have one
                if (data.price.value && formingCandle) {
                    updateFormingCandle({
                        price: data.price.value,
                        timestamp: data.price.timestamp || Math.floor(Date.now() / 1000),
                        amount: 0
                    });
                }
            }

            // Update orderbook (professional version)
            if (data.orderbook) {
                renderOrderbookPro(data.orderbook.bids || [], data.orderbook.asks || []);
                if (data.orderbook.bids?.length && data.orderbook.asks?.length) {
                    const spread = data.orderbook.asks[0].price - data.orderbook.bids[0].price;
                    const spreadPct = (spread / data.orderbook.asks[0].price * 100).toFixed(3);
                    const legacySpread = document.getElementById('orderbook-spread');
                    if (legacySpread) legacySpread.textContent = `Spread: ${formatMarketPrice(spread, data.market)} (${spreadPct}%)`;
                }
            }

            // Update trades and forming candle
            if (data.trades && data.trades.length > 0) {
                renderLiveMarketTrades(data.trades);

                // Update forming candle with the most recent trade
                const latestTrade = data.trades[0]; // Assuming trades are sorted newest first
                if (latestTrade && latestTrade.price) {
                    updateFormingCandle({
                        price: latestTrade.price,
                        timestamp: latestTrade.timestamp || Math.floor(Date.now() / 1000),
                        amount: latestTrade.amount || 0
                    });
                }
            }
        }

        function disconnectLiveMarketWebSocket() {
            if (liveMarketWsReconnectTimer) {
                clearTimeout(liveMarketWsReconnectTimer);
                liveMarketWsReconnectTimer = null;
            }
            if (liveMarketWs) {
                liveMarketWs.close();
                liveMarketWs = null;
            }
        }

        // ==========================================
        // LIVE TEST CONTROL FUNCTIONS
        // ==========================================

        // Update UI based on live test state
        function updateLiveTestUI(state) {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const startBtn = document.getElementById('btn-start-test');
            const stopBtn = document.getElementById('btn-stop-backtest');
            const liveStats = document.getElementById('live-stats');
            const strategySelector = document.getElementById('strategy-selector');

            if (state === 'ready') {
                statusIndicator.className = 'status-indicator ready';
                statusText.textContent = 'Ready';
                startBtn.disabled = false;
                stopBtn.disabled = true;
                liveStats.classList.remove('active');
                strategySelector.disabled = false;
                // Reset Performance Metrics badge when test stops
                const metricsBadge = document.getElementById('metrics-badge');
                if (metricsBadge) metricsBadge.textContent = '14 Metrics';
            } else if (state === 'running') {
                statusIndicator.className = 'status-indicator running';
                statusText.textContent = 'Running...';
                startBtn.disabled = true;
                stopBtn.disabled = false;
                liveStats.classList.add('active');
                strategySelector.disabled = true;
            } else if (state === 'backtesting') {
                statusIndicator.className = 'status-indicator backtesting';
                statusText.textContent = 'Backtesting...';
                startBtn.disabled = true;
                stopBtn.disabled = true;
                liveStats.classList.remove('active');
                strategySelector.disabled = true;
            }
        }

        // Format duration from milliseconds
        function formatDuration(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Update live stats display
        function updateLiveStats(data) {
            // Use tradeCount from API (not trades)
            const tradeCount = data.tradeCount || 0;
            const liveTrades = document.getElementById('live-trades');
            if (liveTrades) liveTrades.textContent = tradeCount;
            // Also update pro UI
            const testTradesPro = document.getElementById('test-trades-pro');
            if (testTradesPro) testTradesPro.textContent = tradeCount;

            // Use totalPnl from API (not pnl)
            const pnl = data.totalPnl || 0;
            const pnlElement = document.getElementById('live-pnl');
            if (pnlElement) {
                pnlElement.textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
                pnlElement.className = 'live-stat-value ' + (pnl >= 0 ? 'positive' : 'negative');
            }
            // Also update pro UI
            const testPnlPro = document.getElementById('test-pnl-pro');
            if (testPnlPro) {
                testPnlPro.textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
                testPnlPro.className = pnl >= 0 ? 'stat-value positive' : 'stat-value negative';
            }

            if (liveTestStartTime) {
                const duration = Date.now() - liveTestStartTime;
                const durationStr = formatDuration(duration);
                const liveDuration = document.getElementById('live-duration');
                if (liveDuration) liveDuration.textContent = durationStr;
                // Also update pro UI
                const testDurationPro = document.getElementById('test-duration-pro');
                if (testDurationPro) testDurationPro.textContent = durationStr;
            }

            const liveStrategy = document.getElementById('live-strategy');
            if (liveStrategy) liveStrategy.textContent = currentStrategy;
        }

        // Flag to prevent double-clicking during API call
        let isStartingTest = false;

        // Start live test (uses archive replay for deterministic parity testing)
        async function startLiveTest() {
            const btn = document.getElementById('btn-start-test');
            console.log('[startLiveTest] Function called');

            // Prevent double-clicking
            if (isStartingTest || liveTestRunning) {
                console.log('[startLiveTest] Already starting or running, ignoring click');
                btn.innerHTML = '<span></span> Please wait...';
                return;
            }
            isStartingTest = true;

            btn.innerHTML = '<span>1</span> Getting strategy...';

            const strategy = document.getElementById('strategy-selector').value;
            console.log('[startLiveTest] Strategy:', strategy);
            currentStrategy = strategy;

            try {
                console.log('[startLiveTest] Updating UI to running state');
                btn.innerHTML = '<span>2</span> Updating UI...';
                updateLiveTestUI('running');
                liveTestStartTime = Date.now();

                // Use /test/start for archive replay (deterministic, enables parity with backtest)
                const url = `${CONTROL_API_URL}/test/start`;
                console.log('[startLiveTest] Fetching:', url);
                console.log('[startLiveTest] API Key:', CONTROL_API_KEY ? 'present' : 'MISSING');
                btn.innerHTML = '<span>3</span> Calling API...';

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'x-api-key': CONTROL_API_KEY },
                    body: JSON.stringify({ strategy: strategy })
                });
                console.log('[startLiveTest] Response received:', response.status, response.statusText);
                btn.innerHTML = '<span>4</span> Got response: ' + response.status;

                const result = await response.json();

                if (!response.ok) {
                    // Parse error from API response body
                    const errorMsg = result.error || result.message || `HTTP ${response.status}`;
                    throw new Error(errorMsg);
                }
                console.log('[startLiveTest] Live test started:', result);
                btn.innerHTML = '<span></span> Started!';
                btn.style.border = '3px solid lime';

                liveTestRunning = true;
                isStartingTest = false;
                startPolling();
                console.log('[startLiveTest] Polling started');

            } catch (error) {
                console.error('[startLiveTest] FAILED:', error);
                btn.innerHTML = '<span></span> Start Live Test';
                btn.style.border = '';
                isStartingTest = false;
                updateLiveTestUI('ready');

                // Show error toast to user
                showErrorToast(
                    'Failed to Start Test',
                    error.message || 'Could not connect to the Control API. Please check if the backend is running.',
                    10000
                );
            }
        }

        // Stop live test and trigger backtest (uses same archive time range for parity)
        async function stopAndBacktest() {
            try {
                updateLiveTestUI('backtesting');
                stopPolling();

                // Use /test/stop-and-backtest to ensure backtest uses SAME archive time range as test
                // This is critical for achieving 100% parity
                const response = await fetch(`${CONTROL_API_URL}/test/stop-and-backtest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'x-api-key': CONTROL_API_KEY }
                });

                if (!response.ok) {
                    throw new Error(`Stop and backtest failed: HTTP ${response.status}`);
                }

                const result = await response.json();
                console.log('Stop and backtest completed:', result);

                liveTestRunning = false;
                liveTestStartTime = null;

                // Wait a moment for backtest to complete
                await new Promise(resolve => setTimeout(resolve, 3000));

                // Switch to comparison view to show TEST vs BACKTEST
                document.getElementById('session-selector').value = 'compare';
                await handleSessionChange('compare');

                // Update UI to show comparison is ready
                updateLiveTestUI('ready');

            } catch (error) {
                console.error('Failed to stop test or run backtest:', error);
                updateLiveTestUI('ready');
                liveTestRunning = false;
                showErrorToast(
                    'Backtest Failed',
                    error.message || 'Could not stop test or run backtest. Please try again.',
                    10000
                );
            }
        }

        // Poll for live test status
        let lastMetricsRefresh = 0;
        const METRICS_REFRESH_INTERVAL = 5000; // Refresh Performance Metrics every 5 seconds

        async function pollLiveTestStatus() {
            if (!liveTestRunning) return;

            try {
                const response = await fetch(`${CONTROL_API_URL}/test/status`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const status = await response.json();

                // Update the running status text
                const statusText = document.getElementById('status-text');
                statusText.textContent = `Running: ${status.tradeCount || 0} trades`;

                // Update live stats
                updateLiveStats(status);

                // Periodically refresh Performance Metrics panel with live test data
                const now = Date.now();
                if (now - lastMetricsRefresh > METRICS_REFRESH_INTERVAL) {
                    lastMetricsRefresh = now;
                    refreshPerformanceMetricsFromLiveTest();
                }

                // Check if test is still running
                if (!status.running && liveTestRunning) {
                    // Test was stopped externally
                    liveTestRunning = false;
                    stopPolling();
                    updateLiveTestUI('ready');
                }

            } catch (error) {
                console.warn('Status poll failed:', error.message);
                // Don't stop polling on transient errors
            }
        }

        // Refresh Performance Metrics panel with current live test data
        async function refreshPerformanceMetricsFromLiveTest() {
            try {
                const response = await fetch(`${CONTROL_API_URL}/session/test`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (!response.ok) return;

                const data = await response.json();
                if (data.success && data.metrics) {
                    // Add fallback values for missing metrics
                    const metrics = data.metrics;
                    metrics.initial_balance = metrics.initial_balance ?? 1.0;
                    metrics.final_balance = metrics.final_balance ?? (metrics.initial_balance + (metrics.total_pnl / 100));
                    metrics.total_return_percent = metrics.total_return_percent ?? metrics.total_pnl;
                    metrics.max_drawdown_percent = metrics.max_drawdown_percent ?? 0;
                    metrics.sharpe_ratio = metrics.sharpe_ratio ?? 0;
                    metrics.profit_factor = metrics.profit_factor ?? (metrics.winning_trades > 0 && metrics.losing_trades > 0 ?
                        Math.abs(metrics.avg_win * metrics.winning_trades) / Math.abs(metrics.avg_loss * metrics.losing_trades) : 0);
                    metrics.max_drawdown = metrics.max_drawdown ?? 0;

                    // Update Performance Metrics panel
                    renderMetrics(metrics);

                    // Update metrics badge to show live indicator
                    const badge = document.getElementById('metrics-badge');
                    if (badge) badge.textContent = ' LIVE';

                    // Update equity curve status from live test data
                    const equityStatus = document.getElementById('equity-status');
                    if (equityStatus && data.equity_curve) {
                        equityStatus.textContent = data.equity_curve.length + ' data points';
                    }

                    // Update Trade Activity badge
                    const tradesBadge = document.getElementById('trades-badge');
                    if (tradesBadge && data.trades) {
                        const exitCount = data.trades.filter(t => t.exit_time_unix && t.exit_price).length;
                        tradesBadge.textContent = `${data.trades.length} entries / ${exitCount} exits`;
                    }

                    // Refresh equity curve chart if in strategy mode
                    if (typeof currentDashboardMode !== 'undefined' && currentDashboardMode === 'strategy') {
                        await loadEquityCurve();
                        await loadTradeOverlays();
                    }

                    // Update chart title with correct strategy name during live test
                    const chartTitle = document.getElementById('chart-title');
                    if (chartTitle && data.metadata?.bot_name) {
                        const candlePeriodLabel = currentCandlePeriod || '1m';
                        chartTitle.textContent = `BTC/USD Price (${candlePeriodLabel}) & ${data.metadata.bot_name} P&L (TEST)`;
                    }

                    console.log('[LiveTest] Refreshed - trades:', metrics.total_trades, 'P&L:', metrics.total_pnl, 'Equity points:', data.equity_curve?.length || 0);
                }
            } catch (err) {
                console.warn('[LiveTest] Failed to refresh Performance Metrics:', err.message);
            }
        }

        // Start polling for status updates
        function startPolling() {
            if (liveTestPollingInterval) {
                clearInterval(liveTestPollingInterval);
            }
            // Poll every 2 seconds
            liveTestPollingInterval = setInterval(pollLiveTestStatus, 2000);
            // Also poll immediately
            pollLiveTestStatus();
        }

        // Stop polling
        function stopPolling() {
            if (liveTestPollingInterval) {
                clearInterval(liveTestPollingInterval);
                liveTestPollingInterval = null;
            }
        }

        // Check initial test status on page load
        async function checkInitialTestStatus() {
            try {
                const response = await fetch(`${CONTROL_API_URL}/test/status`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                if (response.ok) {
                    const status = await response.json();

                    if (status.running) {
                        // Test is already running - resume polling
                        liveTestRunning = true;
                        liveTestStartTime = status.startTime ? status.startTime * 1000 : Date.now();
                        currentStrategy = status.strategy || 'Unknown';
                        document.getElementById('strategy-selector').value = currentStrategy;
                        updateLiveTestUI('running');
                        startPolling();
                    } else {
                        // No test running - enable the start button
                        updateLiveTestUI('ready');
                    }
                } else {
                    // API error - still enable buttons for manual attempt
                    updateLiveTestUI('ready');
                }
            } catch (error) {
                // API not available - still enable buttons (user will see error when they click)
                console.log('Control API not available:', error.message);
                updateLiveTestUI('ready');
            }
        }

        // ==========================================
        // END LIVE TEST CONTROL FUNCTIONS
        // ==========================================

        // ==========================================
        // WEBSOCKET - Real-time trade streaming
        // ==========================================

        let tradeWebSocket = null;
        let wsReconnectAttempts = 0;
        const WS_MAX_RECONNECT = 5;
        const WS_RECONNECT_DELAY = 3000;
        let liveTrades = [];

        // Connect to WebSocket for live trade streaming
        function connectTradeWebSocket() {
            // Use secure websocket if page is HTTPS, otherwise regular
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            // The Control API host (same as CONTROL_API_URL but with ws protocol)
            const wsHost = CONTROL_API_URL.replace(/^https?:/, wsProtocol);
            const wsUrl = `${wsHost}/trades/stream`;

            console.log('[WS] Connecting to:', wsUrl);

            try {
                tradeWebSocket = new WebSocket(wsUrl);

                tradeWebSocket.onopen = () => {
                    console.log('[WS] Connected');
                    wsReconnectAttempts = 0;
                    updateWsStatus(true);

                    // Subscribe to session trade updates (all sessions)
                    tradeWebSocket.send(JSON.stringify({
                        type: 'subscribe',
                        channel: 'session_trades',
                        session_id: 'all'
                    }));
                    console.log('[WS] Subscribed to session_trades');
                };

                tradeWebSocket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleWsMessage(message);
                    } catch (err) {
                        console.error('[WS] Failed to parse message:', err);
                    }
                };

                tradeWebSocket.onclose = (event) => {
                    console.log('[WS] Disconnected:', event.code, event.reason);
                    updateWsStatus(false);

                    // Attempt reconnect if not a clean close
                    if (wsReconnectAttempts < WS_MAX_RECONNECT) {
                        wsReconnectAttempts++;
                        console.log(`[WS] Reconnecting in ${WS_RECONNECT_DELAY}ms (attempt ${wsReconnectAttempts})`);
                        setTimeout(connectTradeWebSocket, WS_RECONNECT_DELAY);
                    }
                };

                tradeWebSocket.onerror = (error) => {
                    console.error('[WS] Error:', error);
                    updateWsStatus(false);
                };

            } catch (err) {
                console.error('[WS] Failed to create WebSocket:', err);
                updateWsStatus(false);
            }
        }

        // Handle incoming WebSocket messages
        function handleWsMessage(message) {
            console.log('[WS] Received:', message.type);

            switch (message.type) {
                case 'status':
                    // Server status update
                    if (message.marketRunning) {
                        showLiveTradeFeed(true);
                    }
                    break;

                case 'trades':
                    // Full trade list (sent on connect)
                    liveTrades = message.trades || [];
                    renderLiveTrades();
                    break;

                case 'new_trades':
                    // New trades to add
                    const newTrades = message.trades || [];
                    if (newTrades.length > 0) {
                        liveTrades = [...liveTrades, ...newTrades];
                        renderLiveTrades(newTrades);
                        // Update live trades count
                        document.getElementById('live-trades').textContent = liveTrades.length;
                    }
                    break;

                case 'market_started':
                    showLiveTradeFeed(true);
                    liveTrades = [];
                    renderLiveTrades();
                    break;

                case 'market_stopped':
                    // Keep feed visible but stop updates
                    break;

                case 'session_trade':
                    // Realtime session trade from C++ bot
                    handleSessionTradeUpdate(message);
                    break;
            }
        }

        // Handle realtime session trade updates from WebSocket
        function handleSessionTradeUpdate(message) {
            const sessionId = message.session_id;
            const trades = message.trades || [];

            if (trades.length === 0) return;

            console.log(`[WS] Session trade update: ${trades.length} trade(s) for session ${sessionId}`);

            // Calculate P&L from the trades
            const tradePnl = trades.reduce((sum, t) => sum + (parseFloat(t.realized_pnl) || 0), 0);

            // Find and update session in sessionsData
            let sessionFound = null;
            ['running', 'scrapers', 'history'].forEach(category => {
                const session = sessionsData[category].find(s => s.id === sessionId);
                if (session) {
                    sessionFound = session;
                    // Update trade count and P&L
                    session.trade_count = (parseInt(session.trade_count) || 0) + trades.length;
                    session.total_pnl = (parseFloat(session.total_pnl) || 0) + tradePnl;
                }
            });

            if (sessionFound) {
                // Re-render the session card to show updated trade count and P&L
                renderSessionList('running-sessions-list', filterRunningSessions(sessionsData.running), 'running');
                renderSessionList('scrapers-list', filterScraperSessions(sessionsData.scrapers), 'scrapers');
                renderSessionList('history-list', sessionsData.history, 'history');
            }

            // If inline detail view is open for this session, update it
            if (currentInlineSessionId === sessionId) {
                // Update trade count display
                const tradesEl = document.getElementById('inline-trades');
                if (tradesEl) {
                    const currentCount = parseInt(tradesEl.textContent) || 0;
                    tradesEl.textContent = currentCount + trades.length;
                }

                // Update P&L display
                const pnlEl = document.getElementById('inline-pnl');
                if (pnlEl && sessionFound) {
                    const pnl = parseFloat(sessionFound.total_pnl) || 0;
                    pnlEl.textContent = pnl >= 0 ? `+$${pnl.toFixed(2)}` : `-$${Math.abs(pnl).toFixed(2)}`;
                    pnlEl.className = `inline-metric-value ${pnl >= 0 ? 'positive' : 'negative'}`;
                }

                // Prepend new trades to the inline trades list
                const tradesContainer = document.getElementById('inline-trades-list');
                if (tradesContainer) {
                    const newTradesHtml = trades.map(t => `
                        <div class="inline-trade-row new-trade">
                            <span>${new Date((t.timestamp || Date.now()) * 1000).toLocaleTimeString()}</span>
                            <span style="color: ${(t.direction || t.side) === 'BUY' ? '#3fb950' : '#f85149'}">${t.action}</span>
                            <span>$${parseFloat(t.price).toFixed(2)}</span>
                            <span>${t.size}</span>
                            <span class="${(parseFloat(t.realized_pnl) || 0) >= 0 ? 'positive' : 'negative'}">${(parseFloat(t.realized_pnl) || 0) >= 0 ? '+' : ''}${(parseFloat(t.realized_pnl) || 0).toFixed(2)}</span>
                        </div>
                    `).join('');

                    // Check if "No trades yet" message is showing
                    if (tradesContainer.querySelector('.inline-empty')) {
                        tradesContainer.innerHTML = newTradesHtml;
                    } else {
                        tradesContainer.insertAdjacentHTML('afterbegin', newTradesHtml);
                    }

                    // Flash effect on new trades
                    setTimeout(() => {
                        tradesContainer.querySelectorAll('.new-trade').forEach(el => el.classList.remove('new-trade'));
                    }, 1000);
                }

                // Update chart markers if trades are on the chart
                if (currentSessionTradeData && liveMarketCandleSeries) {
                    currentSessionTradeData.trades = [...(currentSessionTradeData.trades || []), ...trades];
                    displaySessionTrades(currentSessionTradeData);
                }
            }
        }

        // Update WebSocket connection status indicator
        function updateWsStatus(connected) {
            const dot = document.getElementById('ws-dot');
            const text = document.getElementById('ws-status-text');

            if (dot && text) {
                if (connected) {
                    dot.classList.add('connected');
                    text.textContent = 'Connected';
                } else {
                    dot.classList.remove('connected');
                    text.textContent = 'Disconnected';
                }
            }
        }

        // Show/hide the live trade feed
        function showLiveTradeFeed(show) {
            const feed = document.getElementById('live-trade-feed');
            if (feed) {
                if (show) {
                    feed.classList.add('active');
                } else {
                    feed.classList.remove('active');
                }
            }
        }

        // Render live trades in the feed
        function renderLiveTrades(newOnly = null) {
            const container = document.getElementById('live-trade-list');
            if (!container) return;

            // If no trades, show waiting message
            if (liveTrades.length === 0) {
                container.innerHTML = '<div class="no-trades-message">Waiting for trades...</div>';
                return;
            }

            // If rendering new trades only, prepend them
            if (newOnly && newOnly.length > 0) {
                const fragment = document.createDocumentFragment();
                newOnly.forEach(trade => {
                    const item = createTradeItem(trade);
                    fragment.appendChild(item);
                });
                // Remove "waiting" message if present
                const waiting = container.querySelector('.no-trades-message');
                if (waiting) waiting.remove();
                // Prepend new trades (most recent at top)
                container.insertBefore(fragment, container.firstChild);
            } else {
                // Full render - show most recent first
                container.innerHTML = '';
                const tradesReversed = [...liveTrades].reverse();
                tradesReversed.slice(0, 50).forEach(trade => {
                    const item = createTradeItem(trade);
                    container.appendChild(item);
                });
            }
        }

        // Create a trade item element
        function createTradeItem(trade) {
            const item = document.createElement('div');
            const side = trade.side || 'long';
            item.className = `live-trade-item ${side}`;

            const time = new Date(trade.timestamp_unix * 1000).toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            const sideLabel = side === 'long' ? ' LONG' : ' SHORT';
            const sideClass = side === 'long' ? 'long' : 'short';

            item.innerHTML = `
                <div class="live-trade-info">
                    <span class="live-trade-side ${sideClass}">${sideLabel}</span>
                    <span class="live-trade-price">$${trade.price?.toFixed(1) || '0.0'}</span>
                </div>
                <span class="live-trade-time">${time}</span>
            `;

            return item;
        }

        // Initialize WebSocket on page load
        function initWebSocket() {
            // Small delay to let the page initialize
            setTimeout(() => {
                connectTradeWebSocket();
            }, 1000);
        }

        // ==========================================
        // END WEBSOCKET
        // ==========================================

        // Load backtest data from Control API (no static fallback)
        async function loadBacktestData(botName = 'DivergeBot') {
            try {
                // Try Control API first
                console.log(`[loadBacktestData] Trying Control API for ${botName}...`);
                let data = null;
                try {
                    const apiResponse = await fetch(`${CONTROL_API_URL}/session/backtest`, {
                        headers: { 'x-api-key': CONTROL_API_KEY }
                    });
                    if (apiResponse.ok) {
                        data = await apiResponse.json();
                        if (data.success) {
                            console.log(`[loadBacktestData] Loaded ${data.trades?.length || 0} trades from Control API`);
                        } else {
                            data = null;
                        }
                    }
                } catch (apiErr) {
                    console.log(`[loadBacktestData] Control API not available: ${apiErr.message}`);
                }

                // If no data from API, return empty dataset
                if (!data) {
                    console.log(`[loadBacktestData] No data available, returning empty dataset`);
                    data = {
                        success: true,
                        metadata: {
                            bot_name: botName,
                            exchange: 'bitmex',
                            pair: 'BTC/USD',
                            session_type: 'backtest',
                            start_time: Math.floor(Date.now() / 1000) - 3600,
                            end_time: Math.floor(Date.now() / 1000)
                        },
                        metrics: {
                            total_pnl: 0,
                            win_rate: 0,
                            sharpe_ratio: 0,
                            max_drawdown: 0,
                            profit_factor: 0,
                            total_trades: 0,
                            winning_trades: 0,
                            losing_trades: 0,
                            avg_win: 0,
                            avg_loss: 0,
                            largest_win: 0,
                            largest_loss: 0,
                            avg_trade_duration: 0
                        },
                        trades: [],
                        equity_curve: [],
                        candles: []
                    };
                }

                // Add defaults for missing metrics fields
                const metrics = data.metrics;
                metrics.initial_balance = metrics.initial_balance ?? 1.0;
                metrics.final_balance = metrics.final_balance ?? (metrics.initial_balance + (metrics.total_pnl / 100));
                metrics.total_return_percent = metrics.total_return_percent ?? metrics.total_pnl;
                metrics.max_drawdown_percent = metrics.max_drawdown_percent ?? metrics.max_drawdown;

                // Add defaults for missing metadata fields (used in renderConfig)
                const metadata = data.metadata || {};
                data.metadata = metadata;
                metadata.bot_name = metadata.bot_name ?? botName;
                metadata.exchange = metadata.exchange ?? 'bitmex';
                metadata.pair = metadata.pair ?? 'BTC/USD';
                metadata.second_pair = metadata.second_pair ?? 'ETH/USD';
                metadata.trade_size = metadata.trade_size ?? 0.01;
                metadata.leverage = metadata.leverage ?? 1;
                metadata.initial_balance = metadata.initial_balance ?? 1;
                metadata.divergence_threshold = metadata.divergence_threshold ?? 0.003;
                metadata.ema_period = metadata.ema_period ?? 100;
                // Use trade timestamps for session period if not provided
                const firstTrade = data.trades?.[0];
                const lastTrade = data.trades?.[data.trades.length - 1];
                metadata.start_timestamp_unix = metadata.start_timestamp_unix ?? metadata.start_time ?? firstTrade?.timestamp_unix ?? Math.floor(Date.now() / 1000);
                metadata.end_timestamp_unix = metadata.end_timestamp_unix ?? metadata.end_time ?? lastTrade?.exit_time_unix ?? lastTrade?.timestamp_unix ?? Math.floor(Date.now() / 1000);

                // If data lacks candles or has non-1m candles, generate 1m candles from trades
                if (data.candles && data.candles.length >= 2) {
                    // Check if candles are 1-minute (60 sec apart) or larger timeframe
                    const candleInterval = data.candles[1].time - data.candles[0].time;
                    if (candleInterval > 60) {
                        console.log(`[loadBacktestData] Candles are ${candleInterval}s intervals (not 1m), generating 1m candles from trades`);
                        data.candles = generateCandlesFromTrades(data);
                    }
                } else if (!data.candles || data.candles.length === 0) {
                    console.log(`[loadBacktestData] No candles found, generating from trades`);
                    data.candles = generateCandlesFromTrades(data);
                }

                return data;
            } catch (error) {
                console.error('Failed to load backtest data:', error);
                throw error;
            }
        }

        // Load session-specific data
        async function loadSessionData(sessionType) {
            try {
                // First try to load from Control API (for fresh test/backtest data)
                const apiEndpoint = sessionType === 'test' ? '/session/test' : '/session/backtest';
                console.log(`[loadSessionData] Trying Control API: ${CONTROL_API_URL}${apiEndpoint}`);

                let data = null;
                let apiSuccess = false;
                try {
                    const apiResponse = await fetch(`${CONTROL_API_URL}${apiEndpoint}`, {
                        headers: { 'x-api-key': CONTROL_API_KEY }
                    });
                    if (apiResponse.ok) {
                        data = await apiResponse.json();
                        if (data.success) {
                            apiSuccess = true;
                            console.log(`[loadSessionData] Loaded ${data.trades?.length || 0} trades from Control API`);
                        }
                    }
                } catch (apiErr) {
                    console.log(`[loadSessionData] Control API not available: ${apiErr.message}`);
                }

                // If no data from API, return empty dataset (no static fallback)
                if (!apiSuccess) {
                    console.log(`[loadSessionData] No data available from API, returning empty dataset`);
                    data = {
                        success: true,
                        metadata: {
                            bot_name: 'Unknown',
                            exchange: 'bitmex',
                            pair: 'BTC/USD',
                            session_type: sessionType,
                            start_time: Math.floor(Date.now() / 1000) - 3600,
                            end_time: Math.floor(Date.now() / 1000)
                        },
                        metrics: {
                            total_pnl: 0,
                            win_rate: 0,
                            sharpe_ratio: 0,
                            max_drawdown: 0,
                            profit_factor: 0,
                            total_trades: 0,
                            winning_trades: 0,
                            losing_trades: 0,
                            avg_win: 0,
                            avg_loss: 0,
                            largest_win: 0,
                            largest_loss: 0,
                            avg_trade_duration: 0
                        },
                        trades: [],
                        equity_curve: [],
                        candles: []
                    };
                }

                // Add defaults for missing metrics fields
                const metrics = data.metrics;
                metrics.initial_balance = metrics.initial_balance ?? 1.0;
                metrics.final_balance = metrics.final_balance ?? (metrics.initial_balance + (metrics.total_pnl / 100));
                metrics.total_return_percent = metrics.total_return_percent ?? metrics.total_pnl;
                metrics.max_drawdown_percent = metrics.max_drawdown_percent ?? metrics.max_drawdown ?? 0;
                // Additional defaults for metrics used in rendering
                metrics.sharpe_ratio = metrics.sharpe_ratio ?? 0;
                metrics.profit_factor = metrics.profit_factor ?? (metrics.winning_trades > 0 ? 1 : 0);
                metrics.avg_win = metrics.avg_win ?? (metrics.winning_trades > 0 ? metrics.total_pnl / metrics.winning_trades : 0);
                metrics.avg_loss = metrics.avg_loss ?? 0;
                metrics.max_drawdown = metrics.max_drawdown ?? 0;

                // Add defaults for missing metadata fields (used in renderConfig)
                const metadata = data.metadata;
                metadata.divergence_threshold = metadata.divergence_threshold ?? 0.003;
                metadata.ema_period = metadata.ema_period ?? 100;
                metadata.trade_size = metadata.trade_size ?? 0.01;
                metadata.leverage = metadata.leverage ?? 1;
                metadata.second_pair = metadata.second_pair ?? 'ETH/USD';
                metadata.initial_balance = metadata.initial_balance ?? 1;
                // Use trade timestamps for session period if not provided
                // Support both start_timestamp_unix and start_time field names
                const firstTrade = data.trades?.[0];
                const lastTrade = data.trades?.[data.trades.length - 1];
                metadata.start_timestamp_unix = metadata.start_timestamp_unix ?? metadata.start_time ?? firstTrade?.timestamp_unix ?? Math.floor(Date.now() / 1000);
                metadata.end_timestamp_unix = metadata.end_timestamp_unix ?? metadata.end_time ?? lastTrade?.exit_time_unix ?? lastTrade?.timestamp_unix ?? Math.floor(Date.now() / 1000);

                // Ensure equity_curve exists
                data.equity_curve = data.equity_curve || [];
                // Ensure trades array exists
                data.trades = data.trades || [];

                // If session data lacks candles or has non-1m candles, generate 1m candles from trades
                if (data.candles && data.candles.length >= 2) {
                    const candleInterval = data.candles[1].time - data.candles[0].time;
                    if (candleInterval > 60) {
                        console.log(`[loadSessionData] Candles are ${candleInterval}s intervals, generating 1m candles from ${data.trades?.length || 0} trades`);
                        data.candles = generateCandlesFromTrades(data);
                    }
                } else if (!data.candles || data.candles.length === 0) {
                    console.log(`[loadSessionData] No candles found, generating from ${data.trades?.length || 0} trades`);
                    data.candles = generateCandlesFromTrades(data);
                }
                console.log(`[loadSessionData] Final candle count: ${data.candles?.length || 0}`);

                return data;
            } catch (error) {
                console.error(`Failed to load ${sessionType} session data:`, error);
                throw error;
            }
        }

        // Load both sessions for comparison
        async function loadBothSessions() {
            const [testData, backtestData] = await Promise.all([
                loadSessionData('test'),
                loadSessionData('backtest')
            ]);
            return { testData, backtestData };
        }

        // Compare two metric values with tolerance
        function metricsMatch(val1, val2, tolerance = 0.01) {
            if (typeof val1 === 'number' && typeof val2 === 'number') {
                if (val1 === 0 && val2 === 0) return true;
                const diff = Math.abs(val1 - val2);
                const maxVal = Math.max(Math.abs(val1), Math.abs(val2), 1);
                return (diff / maxVal) <= tolerance;
            }
            return val1 === val2;
        }

        // Format trade time for display
        function formatTradeTime(timestamp) {
            return new Date(timestamp * 1000).toLocaleString('en-US', {
                month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
        }

        // Render a single trade log item
        function renderTradeLogItem(trade, divergenceType = null) {
            const entryTime = formatTradeTime(trade.timestamp_unix);
            const sideClass = trade.side === 'long' ? 'side-long' : 'side-short';
            const sideIcon = trade.side === 'long' ? '' : '';
            const sideLabel = trade.side === 'long' ? 'Long' : 'Short';

            let exitHtml = '';
            if (trade.exit_time_unix && trade.exit_price) {
                const exitTime = formatTradeTime(trade.exit_time_unix);
                const pnlClass = (trade.pnl ?? 0) >= 0 ? 'pnl-positive' : 'pnl-negative';
                const pnlSign = (trade.pnl ?? 0) >= 0 ? '+' : '';
                exitHtml = `
                    <div class="trade-log-action">
                        <span class="exit"> Exit @ $${(trade.exit_price ?? 0).toFixed(1)}</span>
                        <span class="${pnlClass}">${pnlSign}$${(trade.pnl ?? 0).toFixed(2)}</span>
                    </div>
                    <div class="trade-log-time">${exitTime}</div>
                `;
            }

            const divergenceClass = divergenceType === 'divergent' ? 'divergent' :
                                    divergenceType === 'matching' ? 'matching' : '';

            return `
                <div class="trade-log-item ${divergenceClass}" data-divergence="${divergenceType || 'none'}">
                    <div class="trade-log-time">${entryTime}</div>
                    <div class="trade-log-action">
                        <span class="${sideClass}">${sideIcon} ${sideLabel} Entry</span>
                        <span>@ $${(trade.price ?? 0).toFixed(1)}</span>
                        <span style="color: #8892b0;">qty: ${trade.quantity ?? 0}</span>
                    </div>
                    ${exitHtml}
                </div>
            `;
        }

        // Compare trades between test and backtest to find divergences
        function findTradeDivergences(testTrades, backtestTrades) {
            const tolerance = 60; // 60 seconds tolerance for matching trades
            const priceTolerance = 0.001; // 0.1% price tolerance

            const testWithStatus = testTrades.map(t => ({ ...t, matched: false, divergenceType: 'divergent' }));
            const backtestWithStatus = backtestTrades.map(t => ({ ...t, matched: false, divergenceType: 'divergent' }));

            // Try to match trades
            testWithStatus.forEach(testTrade => {
                const matchingBacktest = backtestWithStatus.find(btTrade => {
                    if (btTrade.matched) return false;

                    const timeDiff = Math.abs(testTrade.timestamp_unix - btTrade.timestamp_unix);
                    const sideMatch = testTrade.side === btTrade.side;
                    const priceMatch = Math.abs(testTrade.price - btTrade.price) / testTrade.price < priceTolerance;

                    return timeDiff <= tolerance && sideMatch && priceMatch;
                });

                if (matchingBacktest) {
                    testTrade.matched = true;
                    testTrade.divergenceType = 'matching';
                    matchingBacktest.matched = true;
                    matchingBacktest.divergenceType = 'matching';
                }
            });

            return {
                testTrades: testWithStatus,
                backtestTrades: backtestWithStatus,
                divergenceCount: testWithStatus.filter(t => !t.matched).length +
                                 backtestWithStatus.filter(t => !t.matched).length
            };
        }

        // Render side-by-side trade logs comparison
        function renderTradeLogsComparison(testData, backtestData) {
            const testTrades = testData.trades || [];
            const backtestTrades = backtestData.trades || [];

            // Find divergences
            const { testTrades: testWithStatus, backtestTrades: backtestWithStatus, divergenceCount } =
                findTradeDivergences(testTrades, backtestTrades);

            // Update counts
            document.getElementById('test-trades-count').textContent = `${testTrades.length} trades`;
            document.getElementById('backtest-trades-count').textContent = `${backtestTrades.length} trades`;

            // Update divergence indicator
            const divergenceIndicator = document.getElementById('divergence-count');
            if (divergenceCount > 0) {
                divergenceIndicator.textContent = `${divergenceCount} divergence${divergenceCount > 1 ? 's' : ''}`;
                divergenceIndicator.style.display = 'inline-flex';
            } else {
                divergenceIndicator.style.display = 'none';
            }

            // Render test trades
            const testLogEl = document.getElementById('test-trades-log');
            if (testWithStatus.length === 0) {
                testLogEl.innerHTML = '<div class="no-trades-msg">No trades in test session</div>';
            } else {
                testLogEl.innerHTML = testWithStatus.map(t => renderTradeLogItem(t, t.divergenceType)).join('');
            }

            // Render backtest trades
            const backtestLogEl = document.getElementById('backtest-trades-log');
            if (backtestWithStatus.length === 0) {
                backtestLogEl.innerHTML = '<div class="no-trades-msg">No trades in backtest session</div>';
            } else {
                backtestLogEl.innerHTML = backtestWithStatus.map(t => renderTradeLogItem(t, t.divergenceType)).join('');
            }

            // Setup filter buttons
            setupTradeLogFilters();
        }

        // Setup filter button handlers for trade logs
        function setupTradeLogFilters() {
            const filterBtns = document.querySelectorAll('.trade-logs-filters .filter-btn');
            filterBtns.forEach(btn => {
                btn.onclick = () => {
                    // Update active state
                    filterBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    const filter = btn.dataset.filter;

                    // Filter both columns
                    document.querySelectorAll('.trade-log-item').forEach(item => {
                        const divergence = item.dataset.divergence;
                        if (filter === 'all') {
                            item.style.display = '';
                        } else if (filter === 'divergent') {
                            item.style.display = divergence === 'divergent' ? '' : 'none';
                        } else if (filter === 'matching') {
                            item.style.display = divergence === 'matching' ? '' : 'none';
                        }
                    });
                };
            });
        }

        // Render comparison view
        function renderComparisonView(testData, backtestData) {
            const testMetrics = testData.metrics;
            const backtestMetrics = backtestData.metrics;

            const metricsToCompare = [
                { key: 'total_trades', label: 'Total Trades', format: v => v },
                { key: 'winning_trades', label: 'Winning Trades', format: v => v },
                { key: 'losing_trades', label: 'Losing Trades', format: v => v },
                { key: 'total_pnl', label: 'Total P&L', format: v => formatPnL(v) },
                { key: 'win_rate', label: 'Win Rate', format: v => formatPercent(v) },
                { key: 'final_balance', label: 'Final Balance', format: v => (v ?? 0).toFixed(4) + ' BTC' }
            ];

            let matchCount = 0;
            let totalCount = metricsToCompare.length;

            // Render test metrics
            const testMetricsHtml = metricsToCompare.map(m => {
                const testVal = testMetrics[m.key];
                const backtestVal = backtestMetrics[m.key];
                const isMatch = metricsMatch(testVal, backtestVal);
                if (isMatch) matchCount++;

                return `
                    <div class="comparison-metric">
                        <span class="label">${m.label}</span>
                        <span class="value ${isMatch ? 'match' : 'mismatch'}">${m.format(testVal)}</span>
                    </div>
                `;
            }).join('');

            // Render backtest metrics
            const backtestMetricsHtml = metricsToCompare.map(m => {
                const testVal = testMetrics[m.key];
                const backtestVal = backtestMetrics[m.key];
                const isMatch = metricsMatch(testVal, backtestVal);

                return `
                    <div class="comparison-metric">
                        <span class="label">${m.label}</span>
                        <span class="value ${isMatch ? 'match' : 'mismatch'}">
                            ${m.format(backtestVal)}
                            <span class="match-indicator ${isMatch ? 'match' : 'mismatch'}">
                                ${isMatch ? ' Match' : ' Differs'}
                            </span>
                        </span>
                    </div>
                `;
            }).join('');

            document.getElementById('test-metrics').innerHTML = testMetricsHtml;
            document.getElementById('backtest-metrics').innerHTML = backtestMetricsHtml;

            // Update summary
            const parityPercent = Math.round((matchCount / totalCount) * 100);
            document.getElementById('matching-count').textContent = matchCount;
            document.getElementById('matching-count').className = 'number ' + (matchCount > 0 ? 'positive' : 'negative');
            document.getElementById('different-count').textContent = totalCount - matchCount;
            document.getElementById('different-count').className = 'number ' + (totalCount - matchCount > 0 ? 'negative' : 'positive');
            document.getElementById('parity-percent').textContent = parityPercent + '%';
            document.getElementById('parity-percent').className = 'number ' + (parityPercent >= 80 ? 'positive' : 'negative');

            // Update parity badge
            const parityStatus = document.getElementById('parity-status');
            if (parityPercent === 100) {
                parityStatus.textContent = ' PARITY ACHIEVED';
                parityStatus.className = 'parity-badge match';
            } else if (parityPercent >= 80) {
                parityStatus.textContent = '~ PARTIAL MATCH';
                parityStatus.className = 'parity-badge match';
            } else {
                parityStatus.textContent = ' MISMATCH';
                parityStatus.className = 'parity-badge mismatch';
            }

            // Render side-by-side trade logs comparison
            renderTradeLogsComparison(testData, backtestData);
        }

        // Handle session change
        async function handleSessionChange(session) {
            console.log(`[handleSessionChange] Called with session: ${session}`);
            currentSession = session;
            const loadingEl = document.getElementById('loading-state');
            const contentEl = document.getElementById('dashboard-content');
            const comparisonEl = document.getElementById('comparison-container');

            try {
                console.log(`[handleSessionChange] Starting to load session: ${session}`);
                loadingEl.style.display = 'block';
                loadingEl.innerHTML = '<div class="loading">Loading session data...</div>';
                contentEl.style.display = 'none';
                comparisonEl.classList.remove('active');

                if (session === 'compare') {
                    // Load both and show comparison view
                    const { testData, backtestData } = await loadBothSessions();
                    testSessionData = testData;
                    backtestSessionData = backtestData;

                    loadingEl.style.display = 'none';
                    comparisonEl.classList.add('active');
                    contentEl.style.display = 'none';

                    renderComparisonView(testData, backtestData);

                    document.getElementById('timestamp').textContent =
                        `Last updated: ${new Date().toLocaleString()} | Comparing TEST vs BACKTEST sessions`;
                } else {
                    // Load single session and show normal dashboard
                    const data = await loadSessionData(session);
                    currentData = filterDataByPeriod(data, currentPeriod);

                    loadingEl.style.display = 'none';
                    contentEl.style.display = 'block';
                    comparisonEl.classList.remove('active');

                    // Update status indicators
                    document.getElementById('json-status').textContent = 'Loaded successfully';
                    document.getElementById('metrics-status').textContent = '14 metrics calculated';
                    document.getElementById('equity-status').textContent = currentData.equity_curve.length + ' data points';

                    // Render all components
                    renderMetrics(currentData.metrics);
                    renderConfig(currentData.metadata);
                    renderCharts(currentData);
                    renderTrades(currentData.trades);

                    // Update titles and badges
                    const sessionLabel = session === 'test' ? 'TEST' : 'BACKTEST';
                    const candlePeriodLabel = currentCandlePeriod === '1m' ? '1m' : currentCandlePeriod;
                    document.getElementById('chart-title').textContent =
                        `${currentData.metadata.pair} Price (${candlePeriodLabel}) & ${currentData.metadata.bot_name} P&L (${sessionLabel})`;
                    document.getElementById('bot-name-title').textContent =
                        `${currentData.metadata.bot_name} Configuration`;
                    document.getElementById('bot-badge').textContent = sessionLabel;
                    const exitCount = currentData.trades.filter(t => t.exit_time_unix && t.exit_price).length;
                    document.getElementById('trades-badge').textContent = `${currentData.trades.length} entries / ${exitCount} exits`;

                    document.getElementById('timestamp').textContent =
                        `Last updated: ${new Date().toLocaleString()} | ${sessionLabel} Session - ${currentData.metadata.bot_name}`;

                    animateCards();
                }
            } catch (error) {
                loadingEl.innerHTML = `
                    <div class="error-message">
                        <h3>Failed to load session data</h3>
                        <p>${error.message}</p>
                        <p style="margin-top: 10px; font-size: 0.9rem;">
                            Make sure test_session.json and backtest_session.json exist.
                        </p>
                    </div>
                `;
                loadingEl.style.display = 'block';
                contentEl.style.display = 'none';
                comparisonEl.classList.remove('active');
            }
        }

        // Filter data by date range
        function filterDataByPeriod(data, period) {
            if (period === 'all' || !data.trades || data.trades.length === 0) {
                return data;
            }

            const timestamps = data.trades.map(t => t.timestamp_unix);
            const minTime = Math.min(...timestamps);
            const maxTime = Math.max(...timestamps);
            const dayLength = 86400; // seconds in a day

            let startTime, endTime;
            switch (period) {
                case 'day1':
                    startTime = minTime;
                    endTime = minTime + dayLength;
                    break;
                case 'day2':
                    startTime = minTime + dayLength;
                    endTime = minTime + dayLength * 2;
                    break;
                case 'recent':
                    startTime = maxTime - dayLength;
                    endTime = maxTime + 1;
                    break;
                default:
                    return data;
            }

            // Filter trades
            const filteredTrades = data.trades.filter(t =>
                t.timestamp_unix >= startTime && t.timestamp_unix < endTime
            );

            // Filter candles
            const filteredCandles = data.candles ? data.candles.filter(c =>
                c.time >= startTime && c.time < endTime
            ) : [];

            // Filter equity curve
            const filteredEquity = data.equity_curve ? data.equity_curve.filter(e =>
                e.timestamp_unix >= startTime && e.timestamp_unix < endTime
            ) : [];

            // Recalculate metrics for filtered data
            const recalculatedMetrics = recalculateMetrics(filteredTrades, data.metrics);

            return {
                ...data,
                trades: filteredTrades,
                candles: filteredCandles,
                equity_curve: filteredEquity,
                metrics: recalculatedMetrics
            };
        }

        // Recalculate metrics for filtered trades
        function recalculateMetrics(trades, originalMetrics) {
            if (trades.length === 0) {
                return {
                    ...originalMetrics,
                    total_trades: 0,
                    winning_trades: 0,
                    losing_trades: 0,
                    total_pnl: 0,
                    win_rate: 0
                };
            }

            const winningTrades = trades.filter(t => t.pnl > 0);
            const losingTrades = trades.filter(t => t.pnl <= 0);
            const totalPnl = trades.reduce((sum, t) => sum + t.pnl, 0);

            return {
                ...originalMetrics,
                total_trades: trades.length,
                winning_trades: winningTrades.length,
                losing_trades: losingTrades.length,
                total_pnl: totalPnl,
                win_rate: (winningTrades.length / trades.length) * 100,
                avg_win: winningTrades.length > 0
                    ? winningTrades.reduce((s, t) => s + t.pnl, 0) / winningTrades.length
                    : 0,
                avg_loss: losingTrades.length > 0
                    ? losingTrades.reduce((s, t) => s + t.pnl, 0) / losingTrades.length
                    : 0
            };
        }

        // Format number with sign
        function formatPnL(value, decimals = 2) {
            const v = value ?? 0;
            const sign = v >= 0 ? '+' : '';
            return sign + '$' + v.toFixed(decimals);
        }

        // Format percentage
        function formatPercent(value, decimals = 2) {
            return (value ?? 0).toFixed(decimals) + '%';
        }

        // Export trades to CSV (with entry/exit breakdown)
        function exportToCSV(data) {
            if (!data || !data.trades || data.trades.length === 0) {
                alert('No trade data to export');
                return;
            }

            const headers = ['Timestamp', 'Type', 'Side', 'Price', 'Quantity', 'PnL', 'Cumulative PnL'];
            const rows = [];

            data.trades.forEach(t => {
                // Entry row
                rows.push([
                    t.timestamp,
                    'Entry',
                    t.side,
                    t.price,
                    t.quantity,
                    '',
                    ''
                ]);

                // Exit row (if exists)
                if (t.exit_time_unix && t.exit_price) {
                    const exitTimestamp = new Date(t.exit_time_unix * 1000).toISOString().replace('T', ' ').replace('Z', '');
                    rows.push([
                        exitTimestamp,
                        'Exit',
                        t.side,
                        t.exit_price,
                        t.quantity,
                        t.pnl,
                        t.cumulative_pnl
                    ]);
                }
            });

            const csvContent = [
                headers.join(','),
                ...rows.map(row => row.join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${currentBot}_backtest_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
        }

        // Export chart as image
        function exportChartAsImage() {
            const chartContainer = document.getElementById('chart-container');
            const canvas = chartContainer.querySelector('canvas');

            if (!canvas) {
                alert('Chart not ready for export');
                return;
            }

            // Create a temporary canvas with background
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const ctx = tempCanvas.getContext('2d');

            // Fill background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Draw the chart
            ctx.drawImage(canvas, 0, 0);

            // Download
            const link = document.createElement('a');
            link.download = `${currentBot}_chart_${new Date().toISOString().split('T')[0]}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }

        // Initialize dashboard
        async function initDashboard(botName = 'DivergeBot', period = 'all') {
            const loadingEl = document.getElementById('loading-state');
            const contentEl = document.getElementById('dashboard-content');

            try {
                if (loadingEl) {
                    loadingEl.style.display = 'block';
                    loadingEl.innerHTML = '<div class="loading">Loading backtest data...</div>';
                }
                if (contentEl) contentEl.style.display = 'none';

                let data = await loadBacktestData(botName);
                data = filterDataByPeriod(data, period);
                currentData = data;

                // Hide loading, show content
                if (loadingEl) loadingEl.style.display = 'none';
                if (contentEl) contentEl.style.display = 'block';

                // Update status indicators (with null checks)
                const jsonStatus = document.getElementById('json-status');
                const metricsStatus = document.getElementById('metrics-status');
                const equityStatus = document.getElementById('equity-status');
                if (jsonStatus) jsonStatus.textContent = 'Loaded successfully';
                if (metricsStatus) metricsStatus.textContent = '14 metrics calculated';
                if (equityStatus) equityStatus.textContent = data.equity_curve.length + ' data points';

                // Render all components
                renderMetrics(data.metrics);
                renderConfig(data.metadata);
                renderCharts(data);
                renderTrades(data.trades);

                // Update titles and badges (with null checks)
                const candlePeriodLabel = currentCandlePeriod === '1m' ? '1m' : currentCandlePeriod;
                const chartTitle = document.getElementById('chart-title');
                const botNameTitle = document.getElementById('bot-name-title');
                const botBadge = document.getElementById('bot-badge');
                const tradesBadge = document.getElementById('trades-badge');
                const timestamp = document.getElementById('timestamp');

                if (chartTitle) chartTitle.textContent =
                    `${data.metadata.pair} Price (${candlePeriodLabel}) & ${data.metadata.bot_name} P&L`;
                if (botNameTitle) botNameTitle.textContent =
                    `${data.metadata.bot_name} Configuration`;
                if (botBadge) botBadge.textContent = data.metadata.exchange.toUpperCase();
                const exitCount = data.trades.filter(t => t.exit_time_unix && t.exit_price).length;
                if (tradesBadge) tradesBadge.textContent = `${data.trades.length} entries / ${exitCount} exits`;
                if (timestamp) timestamp.textContent =
                    `Last updated: ${new Date().toLocaleString()} | Data: ${data.metadata.bot_name} on ${data.metadata.exchange} ${data.metadata.pair}`;

                // Update active bot card
                updateActiveBotCard(botName);

                // Animate cards
                animateCards();

            } catch (error) {
                if (loadingEl) {
                    loadingEl.innerHTML = `
                        <div class="error-message">
                            <h3>Failed to load backtest data</h3>
                            <p>${error.message}</p>
                            <p style="margin-top: 10px; font-size: 0.9rem;">
                                Make sure backtest_results.json exists and the page is served via HTTP server.
                            </p>
                        </div>
                    `;
                    loadingEl.style.display = 'block';
                }
                if (contentEl) contentEl.style.display = 'none';
            }
        }

        // Update active bot card styling
        function updateActiveBotCard(botName) {
            document.querySelectorAll('.bot-card').forEach(card => {
                card.classList.remove('active');
                if (card.dataset.bot === botName) {
                    card.classList.add('active');
                }
            });
        }

        // Render all 14 metrics
        function renderMetrics(metrics) {
            const grid = document.getElementById('metrics-grid');
            if (!grid) return; // Element not in DOM

            const metricsList = [
                { label: 'Total P&L', value: formatPnL(metrics.total_pnl), positive: metrics.total_pnl >= 0 },
                { label: 'Total Return', value: formatPercent(metrics.total_return_percent), positive: metrics.total_return_percent >= 0 },
                { label: 'Win Rate', value: formatPercent(metrics.win_rate), positive: metrics.win_rate >= 50 },
                { label: 'Sharpe Ratio', value: (metrics.sharpe_ratio ?? 0).toFixed(2), positive: (metrics.sharpe_ratio ?? 0) >= 1 },
                { label: 'Max Drawdown', value: '$' + (metrics.max_drawdown ?? 0).toFixed(2), positive: false },
                { label: 'Max DD %', value: formatPercent(metrics.max_drawdown_percent), positive: false },
                { label: 'Total Trades', value: metrics.total_trades ?? 0, positive: true },
                { label: 'Winning Trades', value: metrics.winning_trades ?? 0, positive: true },
                { label: 'Losing Trades', value: metrics.losing_trades ?? 0, positive: false },
                { label: 'Avg Win', value: formatPnL(metrics.avg_win), positive: true },
                { label: 'Avg Loss', value: formatPnL(metrics.avg_loss), positive: false },
                { label: 'Profit Factor', value: (metrics.profit_factor ?? 0).toFixed(2), positive: (metrics.profit_factor ?? 0) >= 1.5 },
                { label: 'Initial Balance', value: (metrics.initial_balance ?? 0).toFixed(4) + ' BTC', positive: true },
                { label: 'Final Balance', value: (metrics.final_balance ?? 0).toFixed(4) + ' BTC', positive: (metrics.final_balance ?? 0) >= (metrics.initial_balance ?? 0) }
            ];

            grid.innerHTML = metricsList.map(m => `
                <div class="stat stat-sm">
                    <div class="stat-label stat-label-sm">${m.label}</div>
                    <div class="stat-value stat-value-sm ${m.positive ? 'positive' : 'negative'}">${m.value}</div>
                </div>
            `).join('');
        }

        // Render bot configuration
        function renderConfig(metadata) {
            const section = document.getElementById('config-section');
            if (!section) return; // Element not in DOM

            const startDate = new Date(metadata.start_timestamp_unix * 1000).toLocaleDateString('en-US', {
                year: 'numeric', month: 'short', day: 'numeric'
            });
            const endDate = new Date(metadata.end_timestamp_unix * 1000).toLocaleDateString('en-US', {
                year: 'numeric', month: 'short', day: 'numeric'
            });

            section.innerHTML = `
                <div style="margin-bottom: 15px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <div class="stat-label">Backtest Period</div>
                    <div style="color: #fff; margin-top: 5px;">${startDate} - ${endDate}</div>
                </div>
                <div class="config-grid">
                    <div class="config-item">
                        <div class="config-label">Exchange</div>
                        <div class="config-value">${metadata.exchange.toUpperCase()}</div>
                    </div>
                    <div class="config-item">
                        <div class="config-label">Trading Pair</div>
                        <div class="config-value">${metadata.pair}</div>
                    </div>
                    ${metadata.second_pair ? `
                    <div class="config-item">
                        <div class="config-label">Second Pair</div>
                        <div class="config-value">${metadata.second_pair}</div>
                    </div>
                    ` : ''}
                    <div class="config-item">
                        <div class="config-label">Trade Size</div>
                        <div class="config-value">${metadata.trade_size} BTC</div>
                    </div>
                    <div class="config-item">
                        <div class="config-label">Leverage</div>
                        <div class="config-value">${metadata.leverage}x</div>
                    </div>
                    <div class="config-item">
                        <div class="config-label">Initial Balance</div>
                        <div class="config-value">${metadata.initial_balance} BTC</div>
                    </div>
                    ${metadata.ema_period ? `
                    <div class="config-item">
                        <div class="config-label">EMA Period</div>
                        <div class="config-value">${metadata.ema_period}</div>
                    </div>
                    ` : ''}
                    ${metadata.divergence_threshold ? `
                    <div class="config-item">
                        <div class="config-label">Divergence</div>
                        <div class="config-value">${(metadata.divergence_threshold * 100).toFixed(2)}%</div>
                    </div>
                    ` : ''}
                </div>
            `;
        }

        // Generate 1-minute candles from trade data (when session lacks candle data)
        function generateCandlesFromTrades(data) {
            if (!data.trades || data.trades.length === 0) return [];

            // Collect all price points with timestamps
            const pricePoints = [];
            data.trades.forEach(trade => {
                pricePoints.push({ time: trade.timestamp_unix, price: trade.price });
                if (trade.exit_time_unix && trade.exit_price) {
                    pricePoints.push({ time: trade.exit_time_unix, price: trade.exit_price });
                }
            });

            // Add equity curve points if available
            if (data.equity_curve && data.equity_curve.length > 0) {
                // Use first trade price as reference
                const refPrice = pricePoints.length > 0 ? pricePoints[0].price : 0;
                // Note: equity curve doesn't have price, just use trade prices
            }

            if (pricePoints.length === 0) return [];

            // Sort by time
            pricePoints.sort((a, b) => a.time - b.time);

            // Find time range
            const minTime = pricePoints[0].time;
            const maxTime = pricePoints[pricePoints.length - 1].time;

            // Group into 1-minute buckets
            const candles = [];
            const bucketSize = 60; // 1 minute in seconds

            // Round start time down to minute boundary
            let currentBucket = Math.floor(minTime / bucketSize) * bucketSize;
            const endBucket = Math.floor(maxTime / bucketSize) * bucketSize;

            let lastPrice = pricePoints[0].price;
            let priceIdx = 0;

            while (currentBucket <= endBucket) {
                const bucketEnd = currentBucket + bucketSize;

                // Find all prices in this bucket
                const bucketPrices = [];
                while (priceIdx < pricePoints.length && pricePoints[priceIdx].time < bucketEnd) {
                    bucketPrices.push(pricePoints[priceIdx].price);
                    priceIdx++;
                }

                if (bucketPrices.length > 0) {
                    candles.push({
                        time: currentBucket,
                        open: lastPrice,
                        high: Math.max(lastPrice, ...bucketPrices),
                        low: Math.min(lastPrice, ...bucketPrices),
                        close: bucketPrices[bucketPrices.length - 1]
                    });
                    lastPrice = bucketPrices[bucketPrices.length - 1];
                } else {
                    // No trades in this minute - create flat candle
                    candles.push({
                        time: currentBucket,
                        open: lastPrice,
                        high: lastPrice,
                        low: lastPrice,
                        close: lastPrice
                    });
                }

                currentBucket += bucketSize;
            }

            console.log(`Generated ${candles.length} 1m candles from ${pricePoints.length} price points`);
            return candles;
        }

        // Aggregate 1m candles into larger timeframes
        function aggregateCandles(candles, period) {
            console.log(`[aggregateCandles] Input: ${candles?.length || 0} candles, period: ${period}`);
            if (!candles || candles.length === 0) return [];
            if (period === '1m') {
                console.log(`[aggregateCandles] Returning ${candles.length} raw 1m candles`);
                return candles;
            }

            // Period in seconds
            const periodSeconds = {
                '1m': 60,
                '5m': 300,
                '15m': 900,
                '1h': 3600,
                '1d': 86400
            };

            const periodSecs = periodSeconds[period] || 60;

            // Group candles by period
            const groups = {};
            candles.forEach(candle => {
                // Floor timestamp to period boundary
                const periodStart = Math.floor(candle.time / periodSecs) * periodSecs;

                if (!groups[periodStart]) {
                    groups[periodStart] = [];
                }
                groups[periodStart].push(candle);
            });

            // Aggregate each group into a single candle
            const aggregated = Object.keys(groups)
                .map(key => parseInt(key))
                .sort((a, b) => a - b)
                .map(periodStart => {
                    const group = groups[periodStart];
                    // Sort by time to ensure correct order
                    group.sort((a, b) => a.time - b.time);

                    const open = group[0].open;
                    const close = group[group.length - 1].close;
                    const high = Math.max(...group.map(c => c.high));
                    const low = Math.min(...group.map(c => c.low));
                    const volume = group.reduce((sum, c) => sum + (c.volume || 0), 0);

                    return {
                        time: periodStart,
                        open: open,
                        high: high,
                        low: low,
                        close: close,
                        volume: volume
                    };
                });

            console.log(`[aggregateCandles] Output: ${aggregated.length} candles after ${period} aggregation`);
            return aggregated;
        }

        // Render TradingView charts
        function renderCharts(data) {
            // Clear existing charts
            const chartContainer = document.getElementById('chart-container');
            const equityContainer = document.getElementById('equity-chart-container');
            chartContainer.innerHTML = '';
            equityContainer.innerHTML = '';

            // Get container dimensions
            const containerWidth = chartContainer.offsetWidth || chartContainer.clientWidth || 800;
            const containerHeight = chartContainer.offsetHeight || 400;

            mainChart = LightweightCharts.createChart(chartContainer, {
                width: containerWidth,
                height: containerHeight,
                layout: {
                    background: { type: 'solid', color: 'transparent' },
                    textColor: '#8892b0',
                },
                grid: {
                    vertLines: { color: 'rgba(255,255,255,0.05)' },
                    horzLines: { color: 'rgba(255,255,255,0.05)' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: 'rgba(255,255,255,0.1)',
                    autoScale: true,
                },
                timeScale: {
                    borderColor: 'rgba(255,255,255,0.1)',
                    timeVisible: true,
                    fixLeftEdge: false,
                    fixRightEdge: false,
                },
                handleScroll: {
                    mouseWheel: true,
                    pressedMouseMove: true,
                    horzTouchDrag: true,
                    vertTouchDrag: true,
                },
                handleScale: {
                    axisPressedMouseMove: true,
                    mouseWheel: true,
                    pinch: true,
                },
            });

            // Store raw candles for aggregation
            if (data.candles && data.candles.length > 0) {
                rawCandles = data.candles;
            }

            // Add candlestick series with aggregated candles
            if (data.candles && data.candles.length > 0) {
                const candleSeries = mainChart.addCandlestickSeries({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderDownColor: '#ef5350',
                    borderUpColor: '#26a69a',
                    wickDownColor: '#ef5350',
                    wickUpColor: '#26a69a',
                });

                // Apply aggregation based on current period
                const displayCandles = aggregateCandles(data.candles, currentCandlePeriod);
                safeSetData(candleSeries, displayCandles, 'backtestCandleChart');

                // Add trade markers - both entry AND exit markers
                if (data.trades && data.trades.length > 0) {
                    const markers = [];

                    // Helper to find closest candle to a timestamp
                    const findClosestCandle = (timestamp) => {
                        return data.candles.reduce((prev, curr) => {
                            return Math.abs(curr.time - timestamp) < Math.abs(prev.time - timestamp) ? curr : prev;
                        });
                    };

                    data.trades.forEach(trade => {
                        // ENTRY marker - arrow shape
                        const entryCandle = findClosestCandle(trade.timestamp_unix);
                        markers.push({
                            time: entryCandle.time,
                            position: trade.side === 'long' ? 'belowBar' : 'aboveBar',
                            color: trade.side === 'long' ? '#2196F3' : '#FF9800', // Blue for long entry, orange for short entry
                            shape: trade.side === 'long' ? 'arrowUp' : 'arrowDown',
                            text: '', // No text to prevent overlap on clustered trades
                        });

                        // EXIT marker - circle shape (if exit data exists)
                        if (trade.exit_time_unix && trade.exit_price) {
                            const exitCandle = findClosestCandle(trade.exit_time_unix);
                            markers.push({
                                time: exitCandle.time,
                                position: trade.side === 'long' ? 'aboveBar' : 'belowBar', // Opposite of entry
                                color: trade.pnl >= 0 ? '#00c853' : '#ff5252', // Green for profit, red for loss
                                shape: 'circle',
                                text: '', // No text to prevent overlap
                            });
                        }
                    });

                    // Sort markers by time (required by Lightweight Charts)
                    markers.sort((a, b) => a.time - b.time);
                    candleSeries.setMarkers(markers);
                }
            }

            mainChart.timeScale().fitContent();
            // Ensure price scale auto-fits the data range
            mainChart.priceScale('right').applyOptions({ autoScale: true });

            // Equity curve chart
            const equityWidth = equityContainer.offsetWidth || equityContainer.clientWidth || 800;
            const equityHeight = equityContainer.offsetHeight || 250;

            equityChart = LightweightCharts.createChart(equityContainer, {
                width: equityWidth,
                height: equityHeight,
                layout: {
                    background: { type: 'solid', color: 'transparent' },
                    textColor: '#8892b0',
                },
                grid: {
                    vertLines: { color: 'rgba(255,255,255,0.05)' },
                    horzLines: { color: 'rgba(255,255,255,0.05)' },
                },
                rightPriceScale: {
                    borderColor: 'rgba(255,255,255,0.1)',
                },
                timeScale: {
                    borderColor: 'rgba(255,255,255,0.1)',
                    timeVisible: true,
                },
                handleScroll: {
                    mouseWheel: true,
                    pressedMouseMove: true,
                    horzTouchDrag: true,
                    vertTouchDrag: true,
                },
                handleScale: {
                    axisPressedMouseMove: true,
                    mouseWheel: true,
                    pinch: true,
                },
            });

            // Equity line
            const equitySeries = equityChart.addLineSeries({
                color: '#00d4ff',
                lineWidth: 2,
            });

            const equityData = data.equity_curve.map(p => ({
                time: Math.floor(p.timestamp_unix),
                value: p.equity
            }));

            if (equityData.length > 0) {
                safeSetData(equitySeries, equityData, 'backtestEquityChart');
            }

            // Drawdown area
            const drawdownSeries = equityChart.addAreaSeries({
                topColor: 'rgba(255,82,82,0.4)',
                bottomColor: 'rgba(255,82,82,0.0)',
                lineColor: '#ff5252',
                lineWidth: 1,
                priceScaleId: 'drawdown',
            });

            const drawdownData = data.equity_curve.map(p => ({
                time: Math.floor(p.timestamp_unix),
                value: -p.drawdown
            }));

            if (drawdownData.length > 0) {
                safeSetData(drawdownSeries, drawdownData, 'backtestDrawdownChart');
            }

            equityChart.priceScale('drawdown').applyOptions({
                scaleMargins: { top: 0.8, bottom: 0 },
            });

            equityChart.timeScale().fitContent();

            // Apply adaptive time formatting for zoom
            setupAdaptiveTimeFormat(equityChart);

            // Handle resize
            const handleResize = () => {
                const chartWidth = chartContainer.offsetWidth || chartContainer.clientWidth;
                const eqWidth = equityContainer.offsetWidth || equityContainer.clientWidth;
                if (chartWidth > 0 && mainChart) {
                    mainChart.applyOptions({ width: chartWidth });
                }
                if (eqWidth > 0 && equityChart) {
                    equityChart.applyOptions({ width: eqWidth });
                }
            };

            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 250);
        }

        // Render trades table with entry and exit rows
        function renderTrades(trades) {
            const tradesTable = document.getElementById('trades-table');
            if (!tradesTable) return; // Element not in DOM
            const tbody = tradesTable.querySelector('tbody');
            if (!tbody) return;

            if (!trades || trades.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #8892b0;">No trades in selected period</td></tr>';
                return;
            }

            // Create rows for both entries and exits
            const rows = [];
            trades.forEach((trade, index) => {
                // Entry row
                const entryTime = new Date(trade.timestamp_unix * 1000).toLocaleString('en-US', {
                    month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                });
                const entryType = trade.side === 'long' ? 'Long Entry' : 'Short Entry';
                const entryColor = trade.side === 'long' ? '#2196F3' : '#FF9800';

                rows.push({
                    timestamp: trade.timestamp_unix,
                    html: `
                        <tr style="border-left: 3px solid ${entryColor};">
                            <td>${entryTime}</td>
                            <td style="color: ${entryColor}; font-weight: 500;">
                                ${trade.side === 'long' ? '&#x25B2;' : '&#x25BC;'} ${entryType}
                            </td>
                            <td>$${(trade.price ?? 0).toFixed(1)}</td>
                            <td>${trade.quantity ?? 0}</td>
                            <td style="color: #8892b0;">-</td>
                            <td style="color: #8892b0;">-</td>
                        </tr>
                    `
                });

                // Exit row (if exit data exists)
                if (trade.exit_time_unix && trade.exit_price) {
                    const exitTime = new Date(trade.exit_time_unix * 1000).toLocaleString('en-US', {
                        month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                    });
                    const exitType = trade.side === 'long' ? 'Close Long' : 'Close Short';
                    const exitColor = trade.pnl >= 0 ? '#00c853' : '#ff5252';
                    const profitSign = trade.pnl >= 0 ? '+' : '';

                    rows.push({
                        timestamp: trade.exit_time_unix,
                        html: `
                            <tr style="border-left: 3px solid ${exitColor};">
                                <td>${exitTime}</td>
                                <td style="color: ${exitColor}; font-weight: 500;">
                                    &#x25CF; ${exitType}
                                </td>
                                <td>$${(trade.exit_price ?? 0).toFixed(1)}</td>
                                <td>${trade.quantity ?? 0}</td>
                                <td class="${(trade.pnl ?? 0) >= 0 ? 'positive' : 'negative'}">${profitSign}$${(trade.pnl ?? 0).toFixed(2)}</td>
                                <td class="${(trade.cumulative_pnl ?? 0) >= 0 ? 'positive' : 'negative'}">${(trade.cumulative_pnl ?? 0) >= 0 ? '+' : ''}$${(trade.cumulative_pnl ?? 0).toFixed(2)}</td>
                            </tr>
                        `
                    });
                }
            });

            // Sort rows by timestamp
            rows.sort((a, b) => a.timestamp - b.timestamp);
            tbody.innerHTML = rows.map(r => r.html).join('');
        }

        // Animate cards on load
        function animateCards() {
            document.querySelectorAll('.card').forEach((card, i) => {
                card.style.opacity = '0';
                card.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    card.style.transition = 'opacity 0.5s, transform 0.5s';
                    card.style.opacity = '1';
                    card.style.transform = 'translateY(0)';
                }, i * 100);
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            console.log('[setupEventListeners] Setting up event listeners');

            // Live Test Control buttons (with null checks)
            const startBtn = document.getElementById('btn-start-test');
            console.log('[setupEventListeners] Start button found:', !!startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', (e) => {
                    console.log('[btn-start-test] CLICK EVENT FIRED');
                    e.preventDefault();
                    startLiveTest();
                });
            }
            const stopBtn = document.getElementById('btn-stop-backtest');
            if (stopBtn) stopBtn.addEventListener('click', stopAndBacktest);

            // Session selector dropdown
            const sessionSelector = document.getElementById('session-selector');
            if (sessionSelector) {
                sessionSelector.addEventListener('change', (e) => {
                    console.log(`[session-selector] Change event fired, value: ${e.target.value}`);
                    handleSessionChange(e.target.value);
                });
            }

            // Bot selector dropdown
            const botSelector = document.getElementById('bot-selector');
            if (botSelector) {
                botSelector.addEventListener('change', (e) => {
                    currentBot = e.target.value;
                    if (currentSession === 'compare') {
                        handleSessionChange('compare');
                    } else {
                        initDashboard(currentBot, currentPeriod);
                    }
                });
            }

            // Strategy selector for live test - drives dashboard mode
            const strategySelector = document.getElementById('strategy-selector');
            if (strategySelector) strategySelector.addEventListener('change', async (e) => {
                currentStrategy = e.target.value;

                // Switch dashboard mode based on strategy selection
                if (currentStrategy === 'none') {
                    // Mode A: Live market only
                    document.getElementById('live-strategy').textContent = 'None';
                    document.getElementById('btn-start-test').disabled = true;
                    document.getElementById('btn-start-test').classList.add('disabled');
                    updateStrategyDescription('none');
                    clearIndicators();
                    await switchDashboardMode('market');
                } else {
                    // Mode B: Strategy selected - show trade overlays + equity curve
                    document.getElementById('live-strategy').textContent = currentStrategy;
                    document.getElementById('btn-start-test').disabled = false;
                    document.getElementById('btn-start-test').classList.remove('disabled');
                    updateStrategyDescription(currentStrategy);
                    updateChartIndicators(currentStrategy);
                    await switchDashboardMode('strategy');
                }

                // Update chart title if we have data loaded
                if (currentData && currentData.metadata) {
                    const candlePeriodLabel = currentCandlePeriod;
                    const sessionLabel = currentSession === 'test' ? ' (TEST)' : '';
                    const strategyLabel = currentStrategy === 'none' ? '' : ` & ${currentStrategy} P&L`;
                    document.getElementById('chart-title').textContent =
                        `${currentData.metadata.pair} Price (${candlePeriodLabel})${strategyLabel}${sessionLabel}`;
                }
                console.log(`[strategy-selector] Strategy changed to: ${currentStrategy}, mode: ${currentStrategy === 'none' ? 'market' : 'strategy'}`);
            });

            // Date range selector
            const dateSelector = document.getElementById('date-selector');
            if (dateSelector) {
                dateSelector.addEventListener('change', (e) => {
                    currentPeriod = e.target.value;
                    if (currentSession !== 'compare') {
                        initDashboard(currentBot, currentPeriod);
                    }
                });
            }

            // Candle period selector
            const candlePeriodSelector = document.getElementById('candle-period-selector');
            if (candlePeriodSelector) {
                candlePeriodSelector.addEventListener('change', (e) => {
                    currentCandlePeriod = e.target.value;
                    console.log(`[Period Change] Selected: ${currentCandlePeriod}, has data: ${!!currentData}, candles: ${currentData?.candles?.length || 0}`);
                    if (currentSession !== 'compare' && currentData) {
                        renderCharts(currentData);
                        // Update chart title with new period - use currentStrategy if test is running
                        const candlePeriodLabel = currentCandlePeriod;
                        const sessionLabel = currentSession === 'test' ? ' (TEST)' : '';
                        const botName = (liveTestRunning && currentStrategy && currentStrategy !== 'none')
                            ? currentStrategy
                            : currentData.metadata.bot_name;
                        const chartTitle = document.getElementById('chart-title');
                        if (chartTitle) {
                            chartTitle.textContent =
                                `${currentData.metadata.pair} Price (${candlePeriodLabel}) & ${botName} P&L${sessionLabel}`;
                        }
                    }
                });
            }

            // Bot cards click
            document.querySelectorAll('.bot-card').forEach(card => {
                card.addEventListener('click', () => {
                    const botName = card.dataset.bot;
                    const botSelectorEl = document.getElementById('bot-selector');
                    if (botSelectorEl) botSelectorEl.value = botName;
                    currentBot = botName;
                    initDashboard(currentBot, currentPeriod);
                });
            });

            // Export CSV button
            const exportCsvBtn = document.getElementById('export-csv-btn');
            if (exportCsvBtn) {
                exportCsvBtn.addEventListener('click', () => {
                    exportToCSV(currentData);
                });
            }

            // Export Chart button
            const exportChartBtn = document.getElementById('export-chart-btn');
            if (exportChartBtn) {
                exportChartBtn.addEventListener('click', () => {
                    exportChartAsImage();
                });
            }
        }

        // Initialize on page load
        console.log('[INIT] Starting initialization sequence...');
        setupEventListeners();
        console.log('[INIT] setupEventListeners done');
        initDashboard();
        console.log('[INIT] initDashboard done');
        initViewToggle(); // Enable view toggle between Backtest and Live Market
        console.log('[INIT] initViewToggle done');
        initLiveMarketControls(); // Setup live market data controls
        console.log('[INIT] initLiveMarketControls done');
        initPeriodDropdown(); // Setup professional period dropdown
        console.log('[INIT] initPeriodDropdown done');
        initChartPeriodBar(); // Setup bottom time range buttons
        console.log('[INIT] initChartPeriodBar done');
        initTabBar(); // Setup bottom tab bar navigation
        console.log('[INIT] initTabBar done');
        initProBotControls(); // Setup pro bot controls
        console.log('[INIT] initProBotControls done');
        initSessionManagement(); // Setup session management (Phase 2)
        console.log('[INIT] initSessionManagement done - ALL INIT COMPLETE');

        // Tab bar navigation
        function initTabBar() {
            document.querySelectorAll('.tab-item').forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active from all tabs and contents
                    document.querySelectorAll('.tab-item').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    // Activate clicked tab and its content
                    tab.classList.add('active');
                    const tabId = 'tab-' + tab.dataset.tab;
                    const content = document.getElementById(tabId);
                    if (content) content.classList.add('active');
                });
            });
        }

        // Pro bot controls initialization
        function initProBotControls() {
            console.log('[initProBotControls] >>> FUNCTION CALLED <<<');
            const strategyPro = document.getElementById('strategy-selector-pro');
            const startPro = document.getElementById('btn-start-test-pro');
            const stopPro = document.getElementById('btn-stop-backtest-pro');
            console.log(`[initProBotControls] Elements found - strategyPro: ${!!strategyPro}, startPro: ${!!startPro}, stopPro: ${!!stopPro}`);

            if (strategyPro) {
                console.log('[initProBotControls] Adding change listener to strategy-selector-pro');
                // Add both change and input listeners for debugging
                strategyPro.addEventListener('input', (e) => {
                    console.log(`[Pro Controls INPUT] Value: ${e.target.value}`);
                });
                strategyPro.addEventListener('change', async (e) => {
                    console.log('[CHANGE] ========== HANDLER ENTERED ==========');
                    const strategy = e.target.value;
                    console.log(`[CHANGE] Step 1: strategy value = "${strategy}"`);

                    // Sync with legacy selector
                    const legacySelector = document.getElementById('strategy-selector');
                    if (legacySelector) legacySelector.value = strategy;
                    console.log('[CHANGE] Step 2: synced legacy selector');

                    // Enable/disable start button
                    if (startPro) {
                        startPro.disabled = (strategy === 'none');
                        console.log(`[CHANGE] Step 3: button disabled = ${strategy === 'none'}`);
                    }

                    // Update current strategy
                    currentStrategy = strategy;
                    console.log(`[CHANGE] Step 4: currentStrategy set to "${currentStrategy}"`);

                    // Load trade overlays and metrics if strategy selected
                    console.log(`[CHANGE] Step 5: checking if strategy !== 'none': ${strategy !== 'none'}`);
                    if (strategy !== 'none') {
                        console.log('[CHANGE] Step 6: INSIDE if block - will call functions');
                        try {
                            console.log('[CHANGE] Step 7: calling updateChartIndicators...');
                            updateChartIndicators(strategy);
                            console.log('[CHANGE] Step 8: updateChartIndicators done');

                            console.log('[CHANGE] Step 9: calling loadProMetrics...');
                            loadProMetrics(strategy);
                            console.log('[CHANGE] Step 10: loadProMetrics started (async)');

                            console.log('[CHANGE] Step 11: calling loadTradeOverlays...');
                            await loadTradeOverlays();
                            console.log('[CHANGE] Step 12: loadTradeOverlays DONE');

                            console.log('[CHANGE] Step 13: calling loadBotsTabTradeLogs...');
                            await loadBotsTabTradeLogs();
                            console.log('[CHANGE] Step 14: loadBotsTabTradeLogs DONE');
                        } catch (err) {
                            console.error('[CHANGE] ERROR in handler:', err);
                        }
                    } else {
                        console.log('[CHANGE] Step 6b: strategy is none, clearing overlays');
                        clearTradeOverlays();
                    }
                    console.log('[CHANGE] ========== HANDLER COMPLETE ==========');
                });
            }

            if (startPro) {
                startPro.addEventListener('click', () => {
                    if (typeof startLiveTest === 'function') {
                        startLiveTest();
                        document.getElementById('test-stats-pro').style.display = 'flex';
                    }
                });
            }

            if (stopPro) {
                stopPro.addEventListener('click', () => {
                    if (typeof stopAndBacktest === 'function') {
                        stopAndBacktest();
                    }
                });
            }
        }

        // Load metrics for pro panel
        async function loadProMetrics(strategy) {
            try {
                const data = await loadBacktestData(strategy);
                if (data && data.metrics) {
                    const m = data.metrics;
                    const setMetric = (id, val) => {
                        const el = document.getElementById(id);
                        if (el) el.textContent = val;
                    };
                    setMetric('metric-winrate', (m.win_rate || 0).toFixed(1) + '%');
                    setMetric('metric-pf', (m.profit_factor || 0).toFixed(2));
                    setMetric('metric-pnl', '$' + (m.total_pnl || 0).toFixed(2));
                    setMetric('metric-trades', m.total_trades || 0);
                    setMetric('metric-avgtrade', '$' + ((m.total_pnl || 0) / (m.total_trades || 1)).toFixed(2));
                    setMetric('metric-dd', (m.max_drawdown_percent || 0).toFixed(1) + '%');
                }
            } catch (err) {
                console.error('[loadProMetrics] Error:', err);
            }
        }

        // Load trade logs for the Your Bots tab
        async function loadBotsTabTradeLogs() {
            console.log('[loadBotsTabTradeLogs] >>> CALLED <<<');
            try {
                // Try backtest session first
                console.log(`[loadBotsTabTradeLogs] Fetching from: ${CONTROL_API_URL}/session/backtest`);
                const response = await fetch(`${CONTROL_API_URL}/session/backtest`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                console.log(`[loadBotsTabTradeLogs] Response status: ${response.status}`);
                if (!response.ok) {
                    if (response.status === 401) {
                        console.warn('[loadBotsTabTradeLogs] 401 - API key may be invalid or expired');
                    }
                    console.log('[loadBotsTabTradeLogs] ABORT: No backtest data available');
                    return;
                }

                const data = await response.json();
                console.log(`[loadBotsTabTradeLogs] Data received - success: ${data.success}, trades: ${data.trades?.length || 0}`);

                // Update the backtest trade log in Your Bots tab
                const backtestLogEl = document.getElementById('backtest-trades-log');
                const backtestCountEl = document.getElementById('backtest-trades-count');
                console.log(`[loadBotsTabTradeLogs] DOM elements - backtestLogEl: ${!!backtestLogEl}, backtestCountEl: ${!!backtestCountEl}`);

                // Handle no session data - show helpful message
                if (!data.success || !data.trades || data.trades.length === 0) {
                    console.log('[loadBotsTabTradeLogs] No active session data');
                    if (backtestCountEl) {
                        backtestCountEl.textContent = 'No session';
                        backtestCountEl.style.color = '#8b949e';
                    }
                    if (backtestLogEl) {
                        backtestLogEl.innerHTML = '<div class="no-session-msg" style="color: #8b949e; padding: 12px; text-align: center; font-size: 11px;">No active session<br><span style="color: #58a6ff;">Run a backtest to see trade data</span></div>';
                    }
                    return;
                }

                const trades = data.trades;
                console.log(`[loadBotsTabTradeLogs] Processing ${trades.length} trades`);

                if (backtestCountEl) {
                    backtestCountEl.textContent = `${trades.length} trades`;
                    backtestCountEl.style.color = '#3fb950';
                    console.log(`[loadBotsTabTradeLogs] Updated count to: ${trades.length} trades`);
                }

                if (backtestLogEl) {
                    // Render each trade
                    backtestLogEl.innerHTML = trades.map(trade => {
                        const entryTime = new Date(trade.timestamp_unix * 1000).toLocaleTimeString();
                        const exitTime = trade.exit_time_unix ? new Date(trade.exit_time_unix * 1000).toLocaleTimeString() : '--';
                        const pnl = trade.pnl || 0;
                        const pnlClass = pnl >= 0 ? 'pnl-positive' : 'pnl-negative';
                        const sideClass = trade.side === 'long' ? 'side-long' : 'side-short';

                        return `
                            <div class="trade-log-item">
                                <div class="trade-log-time">${entryTime}</div>
                                <div class="trade-log-action">
                                    <span class="${sideClass}">${trade.side?.toUpperCase() || 'UNKNOWN'}</span>
                                    @ ${trade.entry_price?.toFixed(1) || '--'}
                                </div>
                                <div class="trade-log-details">
                                    <span class="${pnlClass}">$${pnl.toFixed(2)}</span>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            } catch (err) {
                console.error('[loadBotsTabTradeLogs] Error:', err);
            }
        }

        // Default to Market mode (no strategy selected)
        (async function initLiveMarketView() {
            // Set initial strategy to 'none'
            currentStrategy = 'none';

            // Disable start button initially (no strategy selected)
            const startBtn = document.getElementById('btn-start-test');
            if (startBtn) {
                startBtn.disabled = true;
                startBtn.classList.add('disabled');
            }

            // Update strategy display
            const liveStrategyEl = document.getElementById('live-strategy');
            if (liveStrategyEl) liveStrategyEl.textContent = 'None';
            updateStrategyDescription('none');

            // Hide backtest controls (but keep live-test-panel visible)
            document.querySelectorAll('.control-group').forEach(el => el.style.display = 'none');
            const exportButtons = document.querySelector('.export-buttons');
            if (exportButtons) exportButtons.style.display = 'none';
            const liveTradeFeed = document.getElementById('live-trade-feed');
            if (liveTradeFeed) liveTradeFeed.style.display = 'none';

            // Hide equity curve container (market mode)
            const equityCurveContainer = document.getElementById('equity-curve-container');
            if (equityCurveContainer) equityCurveContainer.style.display = 'none';

            // Hide backtest content
            const dashboardContent = document.getElementById('dashboard-content');
            if (dashboardContent) dashboardContent.style.display = 'none';

            // Initialize chart and load data
            initLiveMarketChart();
            await loadLiveMarketData();

            // Connect WebSocket for real-time updates (polling removed - WebSocket only)
            connectLiveMarketWebSocket();
        })();

        checkInitialTestStatus(); // Check if a live test is already running
        initWebSocket(); // Connect to WebSocket for real-time trade streaming
    </script>
</body>
</html>
