<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HM Trading Dashboard</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Roboto Mono', -apple-system, BlinkMacSystemFont, monospace;
            background: #0d1117;
            color: #c9d1d9;
            min-height: 100vh;
            font-size: 12px;
            -webkit-tap-highlight-color: transparent;
            overflow-x: hidden;
        }

        /* === BITMEX-STYLE HEADER === */
        .trading-header {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            background: #161b22;
            border-bottom: 1px solid #30363d;
            gap: 16px;
            flex-wrap: wrap;
        }
        .instrument-dropdown {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .instrument-dropdown:hover { background: rgba(255,255,255,0.05); }
        .instrument-name {
            font-size: 15px;
            font-weight: 700;
            color: #fff;
        }
        .instrument-type {
            font-size: 12px;
            color: #8b949e;
            margin-left: 4px;
        }
        .instrument-badges {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }
        .badge-sm {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 2px;
            font-weight: 600;
        }
        .badge-btc { background: #f7931a; color: #000; }
        .badge-leverage { background: #3fb950; color: #000; }
        .price-section {
            display: flex;
            flex-direction: column;
            margin-left: 16px;
        }
        .price-main {
            font-size: 22px;
            font-weight: 700;
            color: #3fb950;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .price-main.down { color: #f85149; }
        .price-arrow { font-size: 14px; }
        .price-change {
            font-size: 12px;
            color: #f85149;
        }
        .price-change.positive { color: #3fb950; }
        .header-stats {
            display: flex;
            gap: 20px;
            margin-left: auto;
            font-size: 11px;
        }
        .header-stat {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }
        .header-stat-label {
            color: #8b949e;
            font-size: 10px;
        }
        .header-stat-value {
            color: #c9d1d9;
            font-weight: 500;
        }
        .header-stat-value.positive { color: #3fb950; }
        .header-stat-value.negative { color: #f85149; }

        /* === MAIN TRADING LAYOUT === */
        .trading-main {
            display: grid;
            grid-template-columns: 1fr 320px;
            height: 55vh; /* Reduced to fit better */
            gap: 1px;
            background: #30363d;
        }
        .chart-section {
            background: #0d1117;
            display: flex;
            flex-direction: column;
            height: 55vh; /* Match trading-main height */
            overflow: hidden; /* Clip chart canvas to prevent overlap with tab bar */
            position: relative;
        }
        .chart-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #161b22;
            border-bottom: 1px solid #30363d;
        }
        .period-dropdown {
            position: relative;
        }
        .period-btn {
            background: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .period-btn:hover { background: #30363d; }
        .period-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 4px;
            z-index: 1000;
            display: none;
            min-width: 100px;
        }
        .period-menu.show { display: block; }
        .period-option {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
        }
        .period-option:hover { background: #21262d; }
        .period-option.active { color: #00d4ff; }

        /* === OHLC DISPLAY === */
        .ohlc-display {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 4px 12px;
            background: #0d1117;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
        }
        .ohlc-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .ohlc-label {
            color: #8b949e;
        }
        .ohlc-value {
            color: #c9d1d9;
        }
        .ohlc-value.up { color: #3fb950; }
        .ohlc-value.down { color: #f85149; }

        /* === BOTTOM PERIOD SELECTOR === */
        .chart-period-bar {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 4px;
            padding: 6px 12px;
            background: #161b22;
            border-top: 1px solid #30363d;
            position: relative;
            z-index: 50; /* Above chart canvas */
        }
        .chart-period-btn {
            padding: 4px 10px;
            background: transparent;
            border: 1px solid #30363d;
            border-radius: 4px;
            color: #8b949e;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .chart-period-btn:hover {
            background: #21262d;
            color: #c9d1d9;
        }
        .chart-period-btn.active {
            background: #238636;
            border-color: #238636;
            color: #ffffff;
        }

        .chart-container-pro {
            flex: 1;
            min-height: 0;
        }
        #live-price-chart-container {
            width: 100%;
            height: 100%;
        }

        /* === RIGHT PANEL (ORDERBOOK + TRADES) === */
        .right-panel {
            background: #0d1117;
            display: flex;
            flex-direction: column;
            height: 55vh; /* Match chart height */
            overflow: hidden;
        }
        .panel-section {
            display: flex;
            flex-direction: column;
            min-height: 0;
            border-bottom: 1px solid #30363d;
        }
        .panel-section:first-child {
            flex: 2; /* Order book gets 2/3 of space */
        }
        .panel-section:last-child {
            flex: 1; /* Trades gets 1/3 of space */
        }
        .panel-section:last-child { border-bottom: none; }
        .panel-header {
            padding: 8px 12px;
            background: #161b22;
            font-size: 11px;
            font-weight: 600;
            color: #8b949e;
            text-transform: uppercase;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 4px;
        }
        /* Order book should show all rows without scrollbar */
        .panel-section:first-child .panel-content {
            overflow-y: visible;
        }

        /* === ORDERBOOK STYLES === */
        .orderbook-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 2px 8px;
            font-size: 11px;
            position: relative;
        }
        .orderbook-row.header {
            color: #8b949e;
            font-weight: 500;
            padding: 6px 8px;
            border-bottom: 1px solid #30363d;
        }
        .orderbook-row.bid .ob-price { color: #3fb950; }
        .orderbook-row.ask .ob-price { color: #f85149; }
        .ob-price { text-align: left; }
        .ob-size { text-align: right; }
        .ob-total { text-align: right; color: #8b949e; }
        .orderbook-row .depth-bar {
            position: absolute;
            top: 0;
            bottom: 0;
            right: 0;
            opacity: 0.15;
        }
        .orderbook-row.bid .depth-bar { background: #3fb950; }
        .orderbook-row.ask .depth-bar { background: #f85149; }
        .spread-row {
            text-align: center;
            padding: 6px;
            background: #161b22;
            font-size: 11px;
            color: #8b949e;
        }

        /* === RECENT TRADES STYLES === */
        .trade-row {
            display: grid;
            grid-template-columns: 70px 50px 1fr 80px;
            padding: 3px 8px;
            font-size: 11px;
        }
        .trade-row.header {
            color: #8b949e;
            font-weight: 500;
            padding: 6px 8px;
            border-bottom: 1px solid #30363d;
        }
        .trade-row.buy .trade-side { color: #3fb950; }
        .trade-row.sell .trade-side { color: #f85149; }
        .trade-time { color: #8b949e; }
        .trade-price { text-align: right; }
        .trade-size { text-align: right; }

        /* === BOTTOM TAB BAR === */
        .tab-bar {
            display: flex;
            background: #161b22;
            border-top: 1px solid #30363d;
            border-bottom: 1px solid #30363d;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            position: relative;
            z-index: 100; /* Ensure tab bar is above chart canvas */
        }
        .tab-bar::-webkit-scrollbar { height: 0; }
        .tab-item {
            padding: 10px 16px;
            color: #8b949e;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tab-item:hover { color: #c9d1d9; background: rgba(255,255,255,0.05); }
        .tab-item.active { color: #00d4ff; border-bottom-color: #00d4ff; }
        .tab-count { opacity: 0.7; }
        .tab-content { display: none; background: #0d1117; min-height: 200px; }
        .tab-content.active { display: block; }

        /* === YOUR BOTS TAB === */
        .bots-container { padding: 0; display: flex; flex-direction: column; gap: 0; }
        .bots-table { width: 100%; }
        .bots-table-header {
            display: grid;
            grid-template-columns: 120px 1fr 150px 120px 100px;
            padding: 10px 16px;
            background: #161b22;
            border-bottom: 1px solid #30363d;
            font-size: 12px;
            color: #8b949e;
        }
        .bots-table-body { min-height: 100px; }
        .bot-row {
            display: grid;
            grid-template-columns: 120px 1fr 150px 120px 100px;
            padding: 12px 16px;
            border-bottom: 1px solid #21262d;
            font-size: 13px;
            align-items: center;
        }
        .bot-row:hover { background: rgba(255,255,255,0.02); }
        .bot-status { display: flex; align-items: center; gap: 6px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-dot.running { background: #3fb950; animation: pulse 1.5s infinite; }
        .status-dot.stopped { background: #8b949e; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .add-bot-row {
            display: flex;
            gap: 12px;
            padding: 12px 16px;
            background: #161b22;
            border-top: 1px solid #30363d;
        }
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
        .running-bot-stats {
            display: flex;
            gap: 24px;
            padding: 12px 16px;
            background: rgba(63,185,80,0.1);
            border: 1px solid #3fb950;
            border-radius: 4px;
            margin: 12px 16px;
            align-items: center;
        }
        .bot-controls-card {
            display: flex; gap: 16px; align-items: flex-end; flex-wrap: wrap;
            padding: 16px; background: #161b22; border-radius: 8px; border: 1px solid #30363d;
        }
        .control-item { display: flex; flex-direction: column; gap: 6px; }
        .control-item label { font-size: 11px; color: #8b949e; text-transform: uppercase; }
        .pro-select {
            background: #21262d; border: 1px solid #30363d; color: #c9d1d9;
            padding: 8px 12px; border-radius: 4px; font-size: 13px; min-width: 180px;
            cursor: pointer;
            -webkit-appearance: menulist;
            -moz-appearance: menulist;
            appearance: menulist;
        }
        .pro-select:focus {
            outline: 2px solid #00d4ff;
            outline-offset: 1px;
        }
        .button-group { display: flex; gap: 8px; }
        .btn-pro {
            padding: 8px 16px; border-radius: 4px; font-size: 12px; font-weight: 500;
            cursor: pointer; border: none; transition: all 0.2s;
        }
        .btn-start-pro { background: #238636; color: #fff; }
        .btn-start-pro:hover:not(:disabled) { background: #2ea043; }
        .btn-start-pro:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-stop-pro { background: #da3633; color: #fff; }
        .btn-stop-pro:hover:not(:disabled) { background: #f85149; }
        .btn-stop-pro:disabled { opacity: 0.5; cursor: not-allowed; }
        .test-stats-row { display: flex; gap: 24px; margin-left: auto; }
        .test-stat { display: flex; flex-direction: column; align-items: center; }
        .test-stat .stat-label { font-size: 10px; color: #8b949e; text-transform: uppercase; }
        .test-stat .stat-value { font-size: 16px; font-weight: 600; color: #c9d1d9; }
        .test-stat .stat-value.positive { color: #3fb950; }
        .test-stat .stat-value.negative { color: #f85149; }

        /* Metrics + Equity Row */
        .metrics-equity-row { display: grid; grid-template-columns: 1fr 2fr; gap: 16px; }
        @media (max-width: 900px) { .metrics-equity-row { grid-template-columns: 1fr; } }
        .panel-card {
            background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 16px;
        }
        .panel-title {
            font-size: 13px; font-weight: 600; color: #c9d1d9; margin-bottom: 12px;
            display: flex; align-items: center; gap: 8px;
        }
        .metrics-grid-pro { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
        .metric-item { display: flex; flex-direction: column; gap: 4px; }
        .metric-label { font-size: 11px; color: #8b949e; }
        .metric-value { font-size: 16px; font-weight: 600; color: #c9d1d9; }
        .metric-value.positive { color: #3fb950; }
        .metric-value.negative { color: #f85149; }
        .equity-chart-pro { height: 200px; background: #0d1117; border-radius: 4px; }

        /* Trade Logs */
        .logs-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        @media (max-width: 768px) { .logs-row { grid-template-columns: 1fr; } }
        .log-column { background: #161b22; border: 1px solid #30363d; border-radius: 8px; overflow: hidden; }
        .log-header {
            padding: 10px 12px; display: flex; justify-content: space-between;
            align-items: center; font-size: 12px; border-bottom: 1px solid #30363d;
        }
        .log-header.test { background: rgba(0,212,255,0.1); }
        .log-header.backtest { background: rgba(138,43,226,0.1); }
        .log-badge { padding: 2px 8px; border-radius: 3px; font-size: 10px; font-weight: 600; }
        .log-header.test .log-badge { background: #00d4ff; color: #000; }
        .log-header.backtest .log-badge { background: #8b5cf6; color: #fff; }
        .log-list { max-height: 250px; overflow-y: auto; padding: 8px; }
        .log-item { padding: 8px; border-bottom: 1px solid #21262d; font-size: 12px; }
        .log-item:last-child { border-bottom: none; }
        .log-item.divergent { background: rgba(248,81,73,0.1); }
        .no-data { color: #8b949e; text-align: center; padding: 20px; font-size: 12px; }

        /* Legacy container styles for compatibility */
        .container { max-width: 100%; margin: 0; padding: 0; }
        header { display: none; } /* Hide old header */
        .subtitle { color: #8b949e; font-size: 11px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 24px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 40px rgba(0,212,255,0.1);
        }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            flex-wrap: wrap;
            gap: 10px;
        }
        .card-title { font-size: 1.3rem; font-weight: 600; }
        .badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .badge-success { background: rgba(0,200,83,0.2); color: #00c853; }
        .badge-warning { background: rgba(255,193,7,0.2); color: #ffc107; }
        .badge-info { background: rgba(0,212,255,0.2); color: #00d4ff; }
        .badge-real { background: rgba(123,44,191,0.3); color: #c77dff; }
        .stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .stat-grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
        .stat-grid-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; }
        .stat {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
        }
        .stat-sm { padding: 12px; }
        .stat-label { color: #8892b0; font-size: 0.85rem; margin-bottom: 5px; }
        .stat-label-sm { font-size: 0.75rem; }
        .stat-value { font-size: 1.4rem; font-weight: 600; }
        .stat-value-sm { font-size: 1.1rem; }
        .stat-value.positive { color: #00c853; }
        .stat-value.negative { color: #ff5252; }
        .test-list { list-style: none; }
        .test-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .test-item:last-child { border-bottom: none; }
        .test-name { display: flex; align-items: center; gap: 10px; }
        .test-icon { font-size: 1.2rem; }
        .test-status { font-size: 0.85rem; font-weight: 500; }
        .passed { color: #00c853; }
        .failed { color: #ff5252; }
        .skipped { color: #ffc107; }
        .bot-card { margin-bottom: 15px; cursor: pointer; padding: 10px; border-radius: 8px; transition: background 0.2s; }
        .bot-card:hover { background: rgba(255,255,255,0.05); }
        .bot-card.active { background: rgba(0,212,255,0.15); border: 1px solid rgba(0,212,255,0.3); }
        .bot-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }
        .bot-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
        }
        .bot-icon.pair { background: rgba(123,44,191,0.3); }
        .bot-icon.saz { background: rgba(0,212,255,0.3); }
        .bot-icon.sd { background: rgba(255,193,7,0.3); }
        .bot-icon.diverge { background: rgba(0,200,83,0.3); }
        .bot-desc { color: #8892b0; font-size: 0.9rem; margin-top: 5px; }
        .progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s;
        }
        .timestamp {
            color: #8892b0;
            font-size: 0.85rem;
            text-align: center;
            margin-top: 30px;
        }
        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #00d4ff;
        }
        .full-width { grid-column: 1 / -1; }
        #chart-container, #equity-chart-container {
            width: 100%;
            height: 400px;
            border-radius: 8px;
            overflow: hidden;
            touch-action: pan-x pan-y;
        }
        #equity-chart-container { height: 250px; }
        .chart-legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }
        .trade-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .trade-table th, .trade-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .trade-table th {
            color: #8892b0;
            font-weight: 500;
            font-size: 0.85rem;
        }
        .trade-table tr:hover {
            background: rgba(255,255,255,0.05);
        }
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #8892b0;
        }
        .error-message {
            background: rgba(255,82,82,0.2);
            border: 1px solid rgba(255,82,82,0.5);
            padding: 20px;
            border-radius: 8px;
            color: #ff5252;
            text-align: center;
        }
        /* Error Toast for API failures */
        .error-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,82,82,0.95);
            border: 1px solid #ff5252;
            border-radius: 8px;
            padding: 16px 20px;
            color: #fff;
            font-size: 0.95rem;
            max-width: 400px;
            z-index: 10000;
            box-shadow: 0 4px 20px rgba(255,82,82,0.4);
            display: none;
            animation: slideIn 0.3s ease-out;
        }
        .error-toast.show { display: block; }
        .error-toast-title {
            font-weight: 600;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .error-toast-message { opacity: 0.9; font-size: 0.9rem; }
        .error-toast-close {
            position: absolute;
            top: 8px;
            right: 10px;
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 1.2rem;
            opacity: 0.7;
        }
        .error-toast-close:hover { opacity: 1; }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .config-item {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
        }
        .config-label { color: #8892b0; font-size: 0.75rem; }
        .config-value { color: #fff; font-size: 0.9rem; margin-top: 3px; }

        /* Controls Bar */
        .controls-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-label {
            color: #8892b0;
            font-size: 0.85rem;
        }
        .control-select {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            padding: 10px 15px;
            font-size: 0.9rem;
            cursor: pointer;
            min-width: 160px;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%238892b0' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 35px;
        }
        .control-select:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .control-select option {
            background: #1a1a2e;
            color: #fff;
        }

        /* Export Buttons */
        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .btn {
            background: rgba(0,212,255,0.2);
            border: 1px solid rgba(0,212,255,0.4);
            border-radius: 8px;
            color: #00d4ff;
            padding: 10px 18px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            touch-action: manipulation;
        }
        .btn:hover {
            background: rgba(0,212,255,0.3);
            transform: translateY(-1px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-icon {
            font-size: 1rem;
        }

        /* Mobile Improvements */
        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .subtitle { font-size: 1rem; }
            .grid { grid-template-columns: 1fr; }
            .stat-grid { grid-template-columns: 1fr; }
            .stat-grid-3, .stat-grid-4 { grid-template-columns: repeat(2, 1fr); }
            #chart-container { height: 350px; }
            #equity-chart-container { height: 220px; }
            .card { padding: 18px; }
            .card-title { font-size: 1.1rem; }
            .trade-table { font-size: 0.85rem; }
            .trade-table th, .trade-table td { padding: 8px 5px; }
            .controls-bar { flex-direction: column; }
            .control-group { width: 100%; }
            .control-select { width: 100%; }
            .export-buttons { width: 100%; justify-content: center; }
            .btn { flex: 1; justify-content: center; min-width: 120px; }
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            h1 { font-size: 1.6rem; }
            header { padding: 20px 0; }
            #chart-container { height: 280px; }
            #equity-chart-container { height: 180px; }
            .stat-grid-3, .stat-grid-4 { grid-template-columns: 1fr; }
            .config-grid { grid-template-columns: repeat(2, 1fr); }
            .card-header { flex-direction: column; align-items: flex-start; }
            .chart-legend { justify-content: center; }
            .legend-item { font-size: 0.8rem; }
            .legend-color { width: 12px; height: 12px; }
        }

        /* Touch-friendly scrolling for trade table */
        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }
        .table-wrapper::-webkit-scrollbar {
            height: 6px;
        }
        .table-wrapper::-webkit-scrollbar-track {
            background: transparent;
        }
        .table-wrapper::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }

        /* Session Comparison Styles */
        .comparison-container {
            display: none;
        }
        .comparison-container.active {
            display: block;
        }
        .comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0,212,255,0.1);
            border-radius: 8px;
            border: 1px solid rgba(0,212,255,0.3);
        }
        .comparison-title {
            font-size: 1.2rem;
            color: #00d4ff;
        }
        .parity-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .parity-badge.match {
            background: rgba(0,200,83,0.2);
            color: #00c853;
            border: 1px solid rgba(0,200,83,0.3);
        }
        .parity-badge.mismatch {
            background: rgba(255,82,82,0.2);
            color: #ff5252;
            border: 1px solid rgba(255,82,82,0.3);
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        .session-column {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
        }
        .session-column.test {
            border-color: rgba(0,212,255,0.3);
        }
        .session-column.backtest {
            border-color: rgba(123,44,191,0.3);
        }
        .session-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .session-label .badge {
            font-size: 0.9rem;
            padding: 6px 14px;
        }
        .session-label .session-name {
            font-size: 1.1rem;
            font-weight: 600;
        }
        .comparison-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .comparison-metric:last-child {
            margin-bottom: 0;
        }
        .comparison-metric .label {
            color: #8892b0;
            font-size: 0.9rem;
        }
        .comparison-metric .value {
            font-weight: 600;
            font-size: 1.1rem;
        }
        .comparison-metric .value.match {
            color: #00c853;
        }
        .comparison-metric .value.mismatch {
            color: #ff5252;
        }
        .match-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            margin-left: 10px;
        }
        .match-indicator.match {
            background: rgba(0,200,83,0.2);
            color: #00c853;
        }
        .match-indicator.mismatch {
            background: rgba(255,82,82,0.2);
            color: #ff5252;
        }
        .comparison-summary {
            margin-top: 20px;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
        }
        .summary-title {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #00d4ff;
        }
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        .summary-item {
            text-align: center;
            padding: 15px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
        }
        .summary-item .number {
            font-size: 2rem;
            font-weight: 700;
        }
        .summary-item .number.positive {
            color: #00c853;
        }
        .summary-item .number.negative {
            color: #ff5252;
        }
        .summary-item .label {
            color: #8892b0;
            font-size: 0.85rem;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .comparison-grid {
                grid-template-columns: 1fr;
            }
            .summary-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Trade Logs Comparison Styles */
        .trade-logs-comparison {
            margin-top: 30px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 20px;
        }
        .trade-logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .trade-logs-title {
            font-size: 1.2rem;
            color: #00d4ff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .trade-logs-filters {
            display: flex;
            gap: 10px;
        }
        .filter-btn {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.2);
            background: transparent;
            color: #8892b0;
            transition: all 0.2s;
        }
        .filter-btn:hover {
            background: rgba(255,255,255,0.1);
        }
        .filter-btn.active {
            background: rgba(0,212,255,0.2);
            border-color: rgba(0,212,255,0.5);
            color: #00d4ff;
        }
        .trade-logs-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .trade-log-column {
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        .trade-log-column.test {
            border-color: rgba(0,212,255,0.3);
        }
        .trade-log-column.backtest {
            border-color: rgba(123,44,191,0.3);
        }
        .trade-log-header {
            padding: 12px 15px;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .trade-log-header .badge {
            font-size: 0.75rem;
            padding: 4px 10px;
        }
        .trade-log-header .count {
            margin-left: auto;
            color: #8892b0;
            font-size: 0.85rem;
        }
        .trade-log-list {
            max-height: 500px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }
        .trade-log-list::-webkit-scrollbar {
            width: 6px;
        }
        .trade-log-list::-webkit-scrollbar-track {
            background: transparent;
        }
        .trade-log-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
        .trade-log-item {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .trade-log-item:last-child {
            border-bottom: none;
        }
        .trade-log-item.divergent {
            background: rgba(255,82,82,0.1);
            border-left: 3px solid #ff5252;
        }
        .trade-log-item.matching {
            background: rgba(0,200,83,0.05);
            border-left: 3px solid rgba(0,200,83,0.3);
        }
        .trade-log-time {
            font-size: 0.8rem;
            color: #8892b0;
        }
        .trade-log-action {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .trade-log-action .side-long {
            color: #2196F3;
        }
        .trade-log-action .side-short {
            color: #FF9800;
        }
        .trade-log-action .exit {
            color: #8892b0;
        }
        .trade-log-details {
            display: flex;
            gap: 15px;
            font-size: 0.85rem;
            color: #8892b0;
        }
        .trade-log-details .pnl-positive {
            color: #00c853;
        }
        .trade-log-details .pnl-negative {
            color: #ff5252;
        }
        .divergence-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            background: rgba(255,82,82,0.2);
            color: #ff5252;
        }
        .no-trades-msg {
            padding: 30px;
            text-align: center;
            color: #8892b0;
        }
        @media (max-width: 768px) {
            .trade-logs-container {
                grid-template-columns: 1fr;
            }
        }

        /* Live Test Control Panel Styles */
        .live-test-panel {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(0,212,255,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .live-test-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .live-test-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #00d4ff;
        }
        .live-test-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .live-test-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .live-test-select {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            padding: 12px 15px;
            font-size: 0.95rem;
            min-width: 180px;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%238892b0' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 35px;
        }
        .live-test-select:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .live-test-select option {
            background: #1a1a2e;
            color: #fff;
        }
        .strategy-description {
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: rgba(255,255,255,0.7);
            padding: 8px 12px;
            font-size: 0.8rem;
            line-height: 1.4;
            margin-top: 8px;
            max-width: 350px;
        }
        .btn-start {
            background: rgba(0,200,83,0.2);
            border: 1px solid rgba(0,200,83,0.4);
            color: #00c853;
            padding: 12px 24px;
            font-size: 0.95rem;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-start:hover:not(:disabled) {
            background: rgba(0,200,83,0.3);
            transform: translateY(-1px);
        }
        .btn-start:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-stop {
            background: rgba(255,82,82,0.2);
            border: 1px solid rgba(255,82,82,0.4);
            color: #ff5252;
            padding: 12px 24px;
            font-size: 0.95rem;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-stop:hover:not(:disabled) {
            background: rgba(255,82,82,0.3);
            transform: translateY(-1px);
        }
        .btn-stop:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .live-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            min-width: 200px;
        }
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: none;
        }
        .status-indicator.ready {
            background: #8892b0;
        }
        .status-indicator.running {
            background: #00c853;
            animation: pulse 1.5s infinite;
        }
        .status-indicator.backtesting {
            background: #ffc107;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .status-text {
            font-size: 0.9rem;
            color: #fff;
        }

        /* Real-time Stats Display */
        .live-stats {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,200,83,0.1);
            border: 1px solid rgba(0,200,83,0.3);
            border-radius: 8px;
        }
        .live-stats.active {
            display: block;
        }
        .live-stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }
        .live-stat-item {
            text-align: center;
        }
        .live-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #fff;
        }
        .live-stat-value.positive {
            color: #00c853;
        }
        .live-stat-value.negative {
            color: #ff5252;
        }
        .live-stat-label {
            font-size: 0.8rem;
            color: #8892b0;
            margin-top: 4px;
        }

        @media (max-width: 768px) {
            .live-test-controls {
                flex-direction: column;
                align-items: stretch;
            }
            .live-test-select {
                width: 100%;
            }
            .btn-start, .btn-stop {
                width: 100%;
                justify-content: center;
            }
            .live-status {
                justify-content: center;
            }
            .live-stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Live Trade Feed Styles */
        .live-trade-feed {
            display: none;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(123,44,191,0.4);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow: hidden;
        }
        .live-trade-feed.active {
            display: block;
        }
        .live-trade-feed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .live-trade-feed-title {
            font-size: 1rem;
            font-weight: 600;
            color: #c77dff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .ws-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: #8892b0;
        }
        .ws-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff5252;
        }
        .ws-dot.connected {
            background: #00c853;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .live-trade-list {
            max-height: 220px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }
        .live-trade-list::-webkit-scrollbar {
            width: 6px;
        }
        .live-trade-list::-webkit-scrollbar-track {
            background: transparent;
        }
        .live-trade-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
        .live-trade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            margin-bottom: 6px;
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        .live-trade-item.long {
            border-left: 3px solid #2196F3;
        }
        .live-trade-item.short {
            border-left: 3px solid #FF9800;
        }
        .live-trade-info {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .live-trade-side {
            font-weight: 600;
            font-size: 0.85rem;
        }
        .live-trade-side.long { color: #2196F3; }
        .live-trade-side.short { color: #FF9800; }
        .live-trade-price {
            color: #fff;
            font-size: 0.9rem;
        }
        .live-trade-time {
            color: #8892b0;
            font-size: 0.8rem;
        }
        .no-trades-message {
            text-align: center;
            color: #8892b0;
            padding: 30px;
            font-size: 0.9rem;
        }

        /* Live Market Data Section Styles */
        #live-market-content {
            display: none;
        }
        #live-market-content.active {
            display: block;
        }
        #dashboard-content.hidden {
            display: none !important;
        }
        .market-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .market-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .market-control-label {
            color: #8892b0;
            font-size: 0.9rem;
        }
        .market-select {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        .market-select:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .refresh-btn {
            padding: 8px 16px;
            background: rgba(0,212,255,0.2);
            border: 1px solid rgba(0,212,255,0.3);
            color: #00d4ff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .refresh-btn:hover {
            background: rgba(0,212,255,0.3);
        }
        .refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #live-price-chart-container {
            width: 100%;
            height: 400px;
            border-radius: 8px;
            overflow: hidden;
        }
        .market-data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        @media (max-width: 900px) {
            .market-data-grid {
                grid-template-columns: 1fr;
            }
        }
        .orderbook-container {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
        }
        .orderbook-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .orderbook-title {
            font-weight: 600;
            color: #fff;
        }
        .orderbook-spread {
            color: #8892b0;
            font-size: 0.85rem;
        }
        .orderbook-sides {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .orderbook-side {
            font-size: 0.85rem;
        }
        .orderbook-side-header {
            display: flex;
            justify-content: space-between;
            color: #8892b0;
            padding-bottom: 5px;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .orderbook-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            position: relative;
        }
        .orderbook-row .price {
            font-weight: 500;
        }
        .orderbook-row .amount {
            color: #8892b0;
        }
        .orderbook-side.bids .price { color: #00c853; }
        .orderbook-side.asks .price { color: #ff5252; }
        .orderbook-row .bar {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            opacity: 0.15;
        }
        .orderbook-side.bids .bar { background: #00c853; }
        .orderbook-side.asks .bar { background: #ff5252; }
        .trades-container {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        .trades-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .trades-title {
            font-weight: 600;
            color: #fff;
        }
        .trades-table {
            width: 100%;
            font-size: 0.85rem;
        }
        .trades-table th {
            text-align: left;
            color: #8892b0;
            font-weight: 500;
            padding: 5px 0;
        }
        .trades-table td {
            padding: 4px 0;
        }
        .trades-table .side-buy { color: #00c853; }
        .trades-table .side-sell { color: #ff5252; }
        .market-price-display {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-left: auto;
        }
        .current-price {
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
        }
        .price-change {
            font-size: 0.9rem;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: help;
        }
        .price-change .change-label {
            opacity: 0.7;
            font-size: 0.8rem;
        }
        .price-change.positive {
            background: rgba(0,200,83,0.2);
            color: #00c853;
        }
        .price-change.negative {
            background: rgba(255,82,82,0.2);
            color: #ff5252;
        }
    </style>
</head>
<body>
    <!-- Error Toast for API failures -->
    <div id="error-toast" class="error-toast">
        <button class="error-toast-close" onclick="hideErrorToast()">&times;</button>
        <div class="error-toast-title"> <span id="error-toast-title">Error</span></div>
        <div class="error-toast-message" id="error-toast-message">An error occurred</div>
    </div>

    <!-- BitMEX-Style Header -->
    <div class="trading-header">
        <div class="instrument-dropdown" id="instrument-dropdown">
            <span class="instrument-name" id="header-instrument">BTCUSD</span>
            <span class="instrument-type">Perpetual</span>
            <span style="color: #8b949e;"></span>
        </div>
        <div class="instrument-badges">
            <span class="badge-sm badge-btc">BTC</span>
            <span class="badge-sm badge-leverage">100X</span>
        </div>
        <div class="price-section">
            <div class="price-main" id="header-price">
                <span id="price-value">--</span>
                <span class="price-arrow" id="price-arrow"></span>
            </div>
            <div class="price-change" id="header-change">-0.00%</div>
        </div>
        <div class="header-stats">
            <div class="header-stat">
                <span class="header-stat-label">Mark Price</span>
                <span class="header-stat-value" id="header-mark">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">24H Volume</span>
                <span class="header-stat-value" id="header-volume">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">Funding Rate</span>
                <span class="header-stat-value" id="header-funding">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">Next Funding</span>
                <span class="header-stat-value" id="header-next-funding">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">High Price</span>
                <span class="header-stat-value positive" id="header-high">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">Low Price</span>
                <span class="header-stat-value negative" id="header-low">--</span>
            </div>
            <div class="header-stat">
                <span class="header-stat-label">Open Interest</span>
                <span class="header-stat-value" id="header-oi">--</span>
            </div>
        </div>
    </div>

    <!-- Main Trading Layout -->
    <div class="trading-main">
        <!-- Chart Section (Left ~70%) -->
        <div class="chart-section">
            <div class="chart-toolbar">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <select id="market-selector" class="period-btn" style="min-width: 140px;">
                        <option value="xbtusd">BTC/USD</option>
                        <option value="ethusd">ETH/USD</option>
                        <option value="solusd">SOL/USD</option>
                        <option value="xrpusd">XRP/USD</option>
                    </select>
                    <div class="period-dropdown">
                        <button class="period-btn" id="period-btn">
                            <span id="period-label">5m</span>
                            <span></span>
                        </button>
                        <div class="period-menu" id="period-menu">
                            <div class="period-option" data-period="1m">1m</div>
                            <div class="period-option active" data-period="5m">5m</div>
                            <div class="period-option" data-period="15m">15m</div>
                            <div class="period-option" data-period="1h">1h</div>
                            <div class="period-option" data-period="4h">4h</div>
                            <div class="period-option" data-period="1d">1D</div>
                        </div>
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="color: #8b949e; font-size: 11px;" id="candle-count">-- candles</span>
                    <span class="instrument-badge" id="live-indicator"> LIVE</span>
                </div>
            </div>
            <!-- OHLC Display -->
            <div class="ohlc-display">
                <div class="ohlc-item">
                    <span class="ohlc-label">O</span>
                    <span class="ohlc-value" id="ohlc-open">--</span>
                </div>
                <div class="ohlc-item">
                    <span class="ohlc-label">H</span>
                    <span class="ohlc-value" id="ohlc-high">--</span>
                </div>
                <div class="ohlc-item">
                    <span class="ohlc-label">L</span>
                    <span class="ohlc-value" id="ohlc-low">--</span>
                </div>
                <div class="ohlc-item">
                    <span class="ohlc-label">C</span>
                    <span class="ohlc-value" id="ohlc-close">--</span>
                </div>
                <div class="ohlc-item" style="margin-left: 12px;">
                    <span class="ohlc-label">Vol</span>
                    <span class="ohlc-value" id="ohlc-volume">--</span>
                </div>
            </div>
            <div class="chart-container-pro">
                <div id="live-price-chart-container"></div>
            </div>
            <!-- Bottom Period Selector -->
            <div class="chart-period-bar">
                <button class="chart-period-btn" data-range="1y">1y</button>
                <button class="chart-period-btn" data-range="1m">1m</button>
                <button class="chart-period-btn" data-range="5d">5d</button>
                <button class="chart-period-btn active" data-range="1d">1d</button>
                <button class="chart-period-btn" data-range="5h">5h</button>
            </div>
        </div>

        <!-- Right Panel (Orderbook + Trades) -->
        <div class="right-panel">
            <!-- Orderbook -->
            <div class="panel-section" style="flex: 1.2;">
                <div class="panel-header">
                    <span>Order Book</span>
                    <span id="orderbook-spread-header">Spread: --</span>
                </div>
                <div class="panel-content" id="orderbook-panel">
                    <div class="orderbook-row header">
                        <span class="ob-price">Price</span>
                        <span class="ob-size">Size</span>
                        <span class="ob-total">Total</span>
                    </div>
                    <div id="orderbook-asks-pro"></div>
                    <div class="spread-row" id="spread-row">Spread: -- (0.00%)</div>
                    <div id="orderbook-bids-pro"></div>
                </div>
            </div>

            <!-- Recent Trades -->
            <div class="panel-section" style="flex: 0.8;">
                <div class="panel-header">
                    <span>Recent Trades</span>
                    <span id="trades-count">0</span>
                </div>
                <div class="panel-content" id="trades-panel">
                    <div class="trade-row header">
                        <span class="trade-time">Time</span>
                        <span class="trade-side">Side</span>
                        <span class="trade-price">Price</span>
                        <span class="trade-size">Size</span>
                    </div>
                    <div id="recent-trades-pro"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Tab Bar -->
    <div class="tab-bar">
        <div class="tab-item active" data-tab="bots">Your Bots</div>
    </div>

    <!-- Tab Contents -->

    <!-- YOUR BOTS TAB -->
    <div id="tab-bots" class="tab-content active">
        <div class="bots-container">
            <!-- Bots Table Header -->
            <div class="bots-table">
                <div class="bots-table-header">
                    <span class="col-account">Account</span>
                    <span class="col-name">Name</span>
                    <span class="col-strategy">Strategy</span>
                    <span class="col-status">Status</span>
                    <span class="col-action">Action</span>
                </div>
                <div class="bots-table-body" id="bots-table-body">
                    <!-- Bot rows will be inserted here -->
                </div>
            </div>

            <!-- Add New Bot Row -->
            <div class="add-bot-row">
                <label for="strategy-selector-pro" class="visually-hidden">Select trading strategy</label>
                <select id="strategy-selector-pro" class="pro-select" aria-label="Select trading strategy" title="Select a trading strategy">
                    <option value="none" selected>Select Strategy...</option>
                    <option value="TestBot">TestBot</option>
                    <option value="DivergeBot">DivergeBot</option>
                    <option value="SazBot">SazBot</option>
                    <option value="SDBot">SDBot</option>
                    <option value="PairTradeBot">PairTradeBot</option>
                </select>
                <button id="btn-start-test-pro" class="btn-pro btn-start-pro" disabled aria-label="Start selected bot"> Start Bot</button>
            </div>

            <!-- Running Bot Stats (shown when test running) -->
            <div class="running-bot-stats" id="test-stats-pro" style="display: none;">
                <div class="test-stat">
                    <span class="stat-label">Duration</span>
                    <span class="stat-value" id="test-duration-pro">00:00:00</span>
                </div>
                <div class="test-stat">
                    <span class="stat-label">Trades</span>
                    <span class="stat-value" id="test-trades-pro">0</span>
                </div>
                <div class="test-stat">
                    <span class="stat-label">P&L</span>
                    <span class="stat-value" id="test-pnl-pro">$0.00</span>
                </div>
                <button id="btn-stop-backtest-pro" class="btn-pro btn-stop-pro"> Stop & Backtest</button>
            </div>

            <!-- Metrics + Equity Row -->
            <div class="metrics-equity-row">
                <div class="panel-card">
                    <div class="panel-title"> Performance Metrics</div>
                    <div class="metrics-grid-pro">
                        <div class="metric-item">
                            <span class="metric-label">Win Rate</span>
                            <span class="metric-value" id="metric-winrate">--</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Profit Factor</span>
                            <span class="metric-value" id="metric-pf">--</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Total P&L</span>
                            <span class="metric-value" id="metric-pnl">--</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Total Trades</span>
                            <span class="metric-value" id="metric-trades">--</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Avg Trade</span>
                            <span class="metric-value" id="metric-avgtrade">--</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Max Drawdown</span>
                            <span class="metric-value" id="metric-dd">--</span>
                        </div>
                    </div>
                </div>
                <div class="panel-card">
                    <div class="panel-title"> Equity Curve</div>
                    <div id="equity-curve-pro" class="equity-chart-pro"></div>
                </div>
            </div>

            <!-- Trade Logs Comparison -->
            <div class="panel-card">
                <div class="panel-title">
                     Trade Logs Comparison
                    <span class="divergence-badge" id="divergence-badge-pro" style="display: none; margin-left: auto; background: #f85149; color: #fff; padding: 2px 8px; border-radius: 10px; font-size: 11px;">0 divergences</span>
                </div>
                <div class="logs-row">
                    <div class="log-column">
                        <div class="log-header test">
                            <span class="log-badge">LIVE TEST</span>
                            <span id="test-log-count">0 trades</span>
                        </div>
                        <div class="log-list" id="test-log-list">
                            <div class="no-data">No live test data</div>
                        </div>
                    </div>
                    <div class="log-column">
                        <div class="log-header backtest">
                            <span class="log-badge">BACKTEST</span>
                            <span id="backtest-log-count">0 trades</span>
                        </div>
                        <div class="log-list" id="backtest-log-list">
                            <div class="no-data">No backtest data</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden legacy controls for JS compatibility -->
    <div style="display: none;">
        <select id="session-selector">
            <option value="backtest">Backtest</option>
            <option value="test">Test</option>
        </select>
        <select id="bot-selector">
            <option value="DivergeBot">DivergeBot</option>
        </select>
        <select id="date-selector">
            <option value="all">All</option>
        </select>
        <select id="candle-period-selector">
            <option value="5m">5m</option>
        </select>
        <select id="market-period-selector">
            <option value="5m">5m</option>
        </select>
    </div>

    <div class="container" style="display: none;">

        <!-- Live Test Control Panel -->
        <div class="live-test-panel" id="live-test-panel">
            <div class="live-test-header">
                <span class="live-test-title"> Live Test Control</span>
                <span class="live-test-badge badge-info" title="Backend API that manages bot processes and data collection">API Connected</span>
            </div>
            <div class="live-test-controls">
                <select id="strategy-selector" class="live-test-select">
                    <option value="none" selected> Live Market Only</option>
                    <option value="TestBot">TestBot</option>
                    <option value="DivergeBot">DivergeBot</option>
                    <option value="SazBot">SazBot</option>
                    <option value="SDBot">SDBot</option>
                    <option value="PairTradeBot">PairTradeBot</option>
                </select>
                <div id="strategy-description" class="strategy-description" title="Strategy description">
                    Live market data only. Select a strategy to view trade overlays and backtest results.
                </div>
                <button id="btn-start-test" class="btn-start disabled" disabled>
                    <span></span> Start Live Test
                </button>
                <script>
                    // Immediately attach click handler after button is created
                    (function() {
                        var btn = document.getElementById('btn-start-test');
                        if (btn) {
                            btn.addEventListener('click', function() {
                                console.log('[BUTTON CLICK] Handler fired, calling startLiveTest()');
                                this.style.border = '3px solid lime';
                                this.innerHTML = '<span></span> Starting...';
                                // Call the actual function (defined later in script)
                                if (typeof startLiveTest === 'function') {
                                    startLiveTest();
                                } else {
                                    console.error('[BUTTON CLICK] startLiveTest not defined yet!');
                                }
                            });
                            console.log('[INIT] Button click handler attached immediately');
                        }
                    })();
                </script>
                <button id="btn-stop-backtest" class="btn-stop" disabled>
                    <span></span> Stop & Backtest
                </button>
                <div class="live-status">
                    <div id="status-indicator" class="status-indicator ready"></div>
                    <span id="status-text" class="status-text">Ready</span>
                </div>
            </div>
            <!-- Real-time stats (shown when test is running) -->
            <div id="live-stats" class="live-stats">
                <div class="live-stats-grid">
                    <div class="live-stat-item">
                        <div id="live-trades" class="live-stat-value">0</div>
                        <div class="live-stat-label">Trades</div>
                    </div>
                    <div class="live-stat-item">
                        <div id="live-pnl" class="live-stat-value">$0.00</div>
                        <div class="live-stat-label">Running P&L</div>
                    </div>
                    <div class="live-stat-item">
                        <div id="live-duration" class="live-stat-value">00:00</div>
                        <div class="live-stat-label">Duration</div>
                    </div>
                    <div class="live-stat-item">
                        <div id="live-strategy" class="live-stat-value">-</div>
                        <div class="live-stat-label">Strategy</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Live Trade Feed (WebSocket-powered) -->
        <div id="live-trade-feed" class="live-trade-feed">
            <div class="live-trade-feed-header">
                <span class="live-trade-feed-title">
                    <span></span> Live Trade Feed
                </span>
                <div class="ws-status">
                    <div id="ws-dot" class="ws-dot"></div>
                    <span id="ws-status-text">Disconnected</span>
                </div>
            </div>
            <div id="live-trade-list" class="live-trade-list">
                <div class="no-trades-message">Waiting for trades...</div>
            </div>
        </div>

        <!-- Loading/Error State -->
        <div id="loading-state" class="card full-width" style="margin-bottom: 20px;">
            <div class="loading">Loading backtest data...</div>
        </div>

        <!-- Session Comparison View -->
        <div id="comparison-container" class="comparison-container">
            <div class="comparison-header">
                <span class="comparison-title"> Session Comparison: TEST vs BACKTEST</span>
                <span id="parity-status" class="parity-badge match"> PARITY ACHIEVED</span>
            </div>

            <div class="comparison-grid">
                <!-- Test Session Column -->
                <div class="session-column test">
                    <div class="session-label">
                        <span class="badge badge-info">TEST</span>
                        <span class="session-name">Test Session</span>
                    </div>
                    <div id="test-metrics">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Backtest Session Column -->
                <div class="session-column backtest">
                    <div class="session-label">
                        <span class="badge badge-real">BACKTEST</span>
                        <span class="session-name">Backtest Session</span>
                    </div>
                    <div id="backtest-metrics">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>

            <div class="comparison-summary">
                <div class="summary-title">Comparison Summary</div>
                <div class="summary-grid">
                    <div class="summary-item">
                        <div id="matching-count" class="number positive">0</div>
                        <div class="label">Matching Metrics</div>
                    </div>
                    <div class="summary-item">
                        <div id="different-count" class="number negative">0</div>
                        <div class="label">Different Metrics</div>
                    </div>
                    <div class="summary-item">
                        <div id="parity-percent" class="number positive">0%</div>
                        <div class="label">Parity Rate</div>
                    </div>
                </div>
            </div>

            <!-- Side-by-Side Trade Logs Comparison -->
            <div class="trade-logs-comparison">
                <div class="trade-logs-header">
                    <div class="trade-logs-title">
                         Trade Decision Logs
                        <span id="divergence-count" class="divergence-indicator" style="display: none;">0 divergences</span>
                    </div>
                    <div class="trade-logs-filters">
                        <button class="filter-btn active" data-filter="all">All Trades</button>
                        <button class="filter-btn" data-filter="divergent">Divergences Only</button>
                        <button class="filter-btn" data-filter="matching">Matching Only</button>
                    </div>
                </div>
                <div class="trade-logs-container">
                    <!-- Test Trades Column -->
                    <div class="trade-log-column test">
                        <div class="trade-log-header">
                            <span class="badge badge-info">TEST</span>
                            <span>Live Test Trades</span>
                            <span id="test-trades-count" class="count">0 trades</span>
                        </div>
                        <div id="test-trades-log" class="trade-log-list">
                            <div class="no-trades-msg">No trades available</div>
                        </div>
                    </div>
                    <!-- Backtest Trades Column -->
                    <div class="trade-log-column backtest">
                        <div class="trade-log-header">
                            <span class="badge badge-real">BACKTEST</span>
                            <span>Backtest Trades</span>
                            <span id="backtest-trades-count" class="count">0 trades</span>
                        </div>
                        <div id="backtest-trades-log" class="trade-log-list">
                            <div class="no-trades-msg">No trades available</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Live Market Data Section -->
        <div id="live-market-content" class="active" style="display: block;">
            <div class="market-controls">
                <div class="market-control-group">
                    <span class="market-control-label">Market:</span>
                    <select id="market-selector" class="market-select">
                        <option value="xbtusd">BTC/USD (XBTUSD)</option>
                        <option value="ethusd">ETH/USD (ETHUSD)</option>
                        <option value="solusd">SOL/USD (SOLUSD)</option>
                        <option value="xrpusd">XRP/USD (XRPUSD)</option>
                        <option value="dogeusd">DOGE/USD (DOGEUSD)</option>
                    </select>
                </div>
                <div class="market-control-group">
                    <span class="market-control-label">Period:</span>
                    <select id="market-period-selector" class="market-select">
                        <option value="1m">1 Minute</option>
                        <option value="5m" selected>5 Minutes</option>
                        <option value="15m">15 Minutes</option>
                        <option value="1h">1 Hour</option>
                        <option value="4h">4 Hours</option>
                        <option value="1d">1 Day</option>
                        <option value="1w">1 Week</option>
                    </select>
                </div>
                <button id="refresh-market-btn" class="refresh-btn"> Refresh</button>
                <div class="market-price-display">
                    <span id="current-market-price" class="current-price">--</span>
                    <span id="price-change-badge" class="price-change" title="Price change from first to last candle in loaded data">
                        <span class="change-label">Period:</span> <span id="price-change-value">--</span>
                    </span>
                </div>
            </div>

            <!-- Live Price Chart -->
            <div class="card full-width" style="margin-bottom: 20px;">
                <div class="card-header">
                    <span class="card-title" id="live-chart-title">BTC/USD Live Price</span>
                    <span class="badge badge-info">LIVE DATA</span>
                </div>
                <div id="live-price-chart-container"></div>
                <div class="chart-legend" id="price-chart-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #26a69a;"></div>
                        <span>Price Candles</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2962FF;"></div>
                        <span>Volume</span>
                    </div>
                </div>
                <!-- Trade overlay legend (shown in strategy mode) -->
                <div class="chart-legend" id="trade-overlay-legend" style="display: none; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2196F3;"></div>
                        <span>Long Entry</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF9800;"></div>
                        <span>Short Entry</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00c853;"></div>
                        <span>Profit Exit</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff5252;"></div>
                        <span>Loss Exit</span>
                    </div>
                </div>
            </div>

            <!-- Equity Curve Chart (shown in strategy mode) -->
            <div id="equity-curve-container" class="card full-width" style="display: none; margin-bottom: 20px;">
                <div class="card-header">
                    <span class="card-title" id="equity-chart-title">Equity Curve</span>
                    <span class="badge badge-success" id="equity-badge">STRATEGY</span>
                </div>
                <div id="equity-curve-chart-container" style="height: 200px;"></div>
                <div class="chart-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4caf50;"></div>
                        <span>Equity</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff5252;"></div>
                        <span>Drawdown</span>
                    </div>
                </div>
            </div>

            <!-- Orderbook and Trades Grid -->
            <div class="market-data-grid">
                <div class="card">
                    <div class="orderbook-container">
                        <div class="orderbook-header">
                            <span class="orderbook-title"> Order Book</span>
                            <span id="orderbook-spread" class="orderbook-spread">Spread: --</span>
                        </div>
                        <div class="orderbook-sides">
                            <div class="orderbook-side bids">
                                <div class="orderbook-side-header">
                                    <span>Price</span>
                                    <span>Amount</span>
                                </div>
                                <div id="orderbook-bids"></div>
                            </div>
                            <div class="orderbook-side asks">
                                <div class="orderbook-side-header">
                                    <span>Price</span>
                                    <span>Amount</span>
                                </div>
                                <div id="orderbook-asks"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <div class="trades-container">
                        <div class="trades-header">
                            <span class="trades-title"> Recent Trades</span>
                            <span id="trades-count" style="color: #8892b0; font-size: 0.85rem;">0 trades</span>
                        </div>
                        <table class="trades-table">
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Side</th>
                                    <th>Price</th>
                                    <th>Amount</th>
                                </tr>
                            </thead>
                            <tbody id="trades-tbody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div id="dashboard-content" style="display: none;">
            <!-- TradingView Chart Section -->
            <div class="card full-width" style="margin-bottom: 20px;">
                <div class="card-header">
                    <span class="card-title" id="chart-title">BTC/USD Price & Bot P&L</span>
                    <span class="badge badge-real">C++ BACKTEST DATA</span>
                </div>
                <div id="chart-container"></div>
                <div class="chart-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #26a69a;"></div>
                        <span>BTC/USD Candles</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2196F3; clip-path: polygon(50% 0%, 0% 100%, 100% 100%);"></div>
                        <span>Long Entry</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF9800; clip-path: polygon(0% 0%, 100% 0%, 50% 100%);"></div>
                        <span>Short Entry</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00c853; border-radius: 50%;"></div>
                        <span>Exit (Profit)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff5252; border-radius: 50%;"></div>
                        <span>Exit (Loss)</span>
                    </div>
                </div>
            </div>

            <div class="grid">
                <!-- All 14 Performance Metrics -->
                <div class="card full-width">
                    <div class="card-header">
                        <span class="card-title">Performance Metrics</span>
                        <span class="badge badge-success" id="metrics-badge">14 Metrics</span>
                    </div>
                    <div class="stat-grid-4" id="metrics-grid">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <!-- Equity Curve with Drawdown -->
                <div class="card full-width">
                    <div class="card-header">
                        <span class="card-title">Equity Curve & Drawdown</span>
                        <span class="badge badge-info" id="equity-badge">Live</span>
                    </div>
                    <div id="equity-chart-container"></div>
                    <div class="chart-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #00d4ff;"></div>
                            <span>Equity (BTC)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff5252;"></div>
                            <span>Drawdown</span>
                        </div>
                    </div>
                </div>

                <!-- Bot Configuration -->
                <div class="card">
                    <div class="card-header">
                        <span class="card-title" id="bot-name-title">Bot Configuration</span>
                        <span class="badge badge-info" id="bot-badge">Config</span>
                    </div>
                    <div id="config-section">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <!-- Trading Bots Overview (Clickable) -->
                <div class="card">
                    <div class="card-header">
                        <span class="card-title">Trading Bots</span>
                        <span class="badge badge-info">Click to Switch</span>
                    </div>
                    <div class="bot-card active" data-bot="DivergeBot">
                        <div class="bot-header">
                            <div class="bot-icon diverge"></div>
                            <div>
                                <strong>DivergeBot</strong>
                                <div class="bot-desc">Price ratio divergence trading</div>
                            </div>
                        </div>
                    </div>
                    <div class="bot-card" data-bot="SazBot">
                        <div class="bot-header">
                            <div class="bot-icon saz"></div>
                            <div>
                                <strong>SazBot</strong>
                                <div class="bot-desc">Order book imbalance analysis</div>
                            </div>
                        </div>
                    </div>
                    <div class="bot-card" data-bot="SDBot">
                        <div class="bot-header">
                            <div class="bot-icon sd"></div>
                            <div>
                                <strong>SDBot</strong>
                                <div class="bot-desc">Standard deviation mean reversion</div>
                            </div>
                        </div>
                    </div>
                    <div class="bot-card" data-bot="PairTradeBot">
                        <div class="bot-header">
                            <div class="bot-icon pair"></div>
                            <div>
                                <strong>PairTradeBot</strong>
                                <div class="bot-desc">Statistical arbitrage using Bollinger Bands</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Unit Tests Results -->
                <div class="card">
                    <div class="card-header">
                        <span class="card-title">Unit Tests</span>
                        <span class="badge badge-success">15/15 Passed</span>
                    </div>
                    <ul class="test-list">
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> test_types</span>
                            <span class="test-status passed">4 tests passed</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> test_order_book</span>
                            <span class="test-status passed">3 tests passed</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> test_indicators</span>
                            <span class="test-status passed">4 tests passed</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> test_scheduler</span>
                            <span class="test-status passed">3 tests passed</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> test_bots</span>
                            <span class="test-status passed">9 tests passed</span>
                        </li>
                    </ul>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 100%; background: linear-gradient(90deg, #00c853, #00d4ff);"></div>
                    </div>
                </div>

                <!-- System Status -->
                <div class="card">
                    <div class="card-header">
                        <span class="card-title">System Status</span>
                        <span class="badge badge-success">Healthy</span>
                    </div>
                    <div class="stat-grid">
                        <div class="stat">
                            <div class="stat-label">Build Status</div>
                            <div class="stat-value passed"> Passing</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">C++ Standard</div>
                            <div class="stat-value">C++20</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">CMake Version</div>
                            <div class="stat-value">3.20+</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Data Source</div>
                            <div class="stat-value">JSON</div>
                        </div>
                    </div>
                </div>

                <!-- Recent Trades Table -->
                <div class="card full-width">
                    <div class="card-header">
                        <span class="card-title">Trade Activity</span>
                        <span class="badge badge-info" id="trades-badge">0 trades</span>
                    </div>
                    <div class="table-wrapper">
                        <table class="trade-table" id="trades-table">
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Type</th>
                                    <th>Price</th>
                                    <th>Qty</th>
                                    <th>P&L</th>
                                    <th>Cumulative</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Integration Tests -->
                <div class="card full-width">
                    <div class="card-header">
                        <span class="card-title">Integration & Backtest Tests</span>
                        <span class="badge badge-success">C++ JSON Output</span>
                    </div>
                    <ul class="test-list">
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> JSON Data Loader</span>
                            <span class="test-status passed" id="json-status">Loading...</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> TradingView Chart</span>
                            <span class="test-status passed">Lightweight Charts v4</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> Backtest Metrics</span>
                            <span class="test-status passed" id="metrics-status">Loading...</span>
                        </li>
                        <li class="test-item">
                            <span class="test-name"><span class="test-icon"></span> Equity Curve</span>
                            <span class="test-status passed" id="equity-status">Loading...</span>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <p class="timestamp" id="timestamp">Last updated: Loading...</p>
    </div>

    <script>
        // Global state
        let currentData = null;
        let testSessionData = null;
        let backtestSessionData = null;
        let mainChart = null;
        let equityChart = null;
        let currentBot = 'DivergeBot';
        let currentPeriod = 'all';
        let currentSession = 'backtest';
        let currentCandlePeriod = '1m';
        let rawCandles = null; // Store original 1m candles

        // Live Test Control State
        const CONTROL_API_URL = 'https://agent-company.atamatch.com:8443';
        const CONTROL_API_KEY = 'hm-trading-dev-key-2025';
        let liveTestRunning = false;
        let liveTestPollingInterval = null;
        let liveTestStartTime = null;
        let currentStrategy = 'TestBot';

        // Bot configurations for display
        const botConfigs = {
            DivergeBot: { icon: '', color: '#00c853', desc: 'Price ratio divergence trading' },
            SazBot: { icon: '', color: '#00d4ff', desc: 'Order book imbalance analysis' },
            SDBot: { icon: '', color: '#ffc107', desc: 'Standard deviation mean reversion' },
            PairTradeBot: { icon: '', color: '#7b2cbf', desc: 'Statistical arbitrage' }
        };

        // Error Toast Functions
        function showErrorToast(title, message, duration = 8000) {
            const toast = document.getElementById('error-toast');
            const titleEl = document.getElementById('error-toast-title');
            const messageEl = document.getElementById('error-toast-message');

            titleEl.textContent = title;
            messageEl.textContent = message;
            toast.classList.add('show');

            // Auto-hide after duration
            if (duration > 0) {
                setTimeout(() => hideErrorToast(), duration);
            }
        }

        function hideErrorToast() {
            document.getElementById('error-toast').classList.remove('show');
        }

        // ==========================================
        // LIVE MARKET DATA FUNCTIONS
        // ==========================================

        let liveMarketChart = null;
        let liveMarketCandleSeries = null;
        let currentMarket = 'xbtusd';
        let currentMarketPeriod = '5m';
        let liveMarketRefreshInterval = null;

        // Live forming candle state
        let formingCandle = null;  // { time, open, high, low, close, volume }
        let lastCandleData = [];   // Store the historical candles for reference

        // Lazy loading state for historical candles
        let earliestCandleTime = null;  // Track earliest loaded candle timestamp
        let isLoadingOlderCandles = false;  // Prevent concurrent fetches
        let archiveMinTime = null;  // Track archive data availability

        // Period duration in seconds
        const PERIOD_SECONDS = {
            '1m': 60,
            '5m': 300,
            '15m': 900,
            '1h': 3600,
            '4h': 14400,
            '1d': 86400,
            '1w': 604800
        };

        // Get the start time for a candle period containing the given timestamp
        function getPeriodStartTime(timestamp, period) {
            const periodSecs = PERIOD_SECONDS[period] || 300;
            return Math.floor(timestamp / periodSecs) * periodSecs;
        }

        // Initialize or update the forming candle from a trade
        function updateFormingCandle(trade) {
            if (!liveMarketCandleSeries) return;

            // Get raw timestamp, defaulting to current time in seconds
            const rawTimestamp = trade.timestamp || Math.floor(Date.now() / 1000);
            // Convert milliseconds to seconds if needed (timestamps > year 2033 are likely in ms)
            const tradeTime = rawTimestamp > 9999999999 ? Math.floor(rawTimestamp / 1000) : rawTimestamp;
            const price = trade.price;
            const amount = trade.amount || 0;
            const periodStart = getPeriodStartTime(tradeTime, currentMarketPeriod);

            // Check if we need to start a new candle (period rolled over)
            if (formingCandle && periodStart > formingCandle.time) {
                // Period ended - the forming candle is now frozen (already in the chart)
                // Start a new forming candle
                formingCandle = {
                    time: periodStart,
                    open: price,
                    high: price,
                    low: price,
                    close: price,
                    volume: amount
                };
                console.log('[LiveCandle] New period started:', new Date(periodStart * 1000).toISOString());
            } else if (!formingCandle) {
                // First trade - initialize forming candle
                formingCandle = {
                    time: periodStart,
                    open: price,
                    high: price,
                    low: price,
                    close: price,
                    volume: amount
                };
                console.log('[LiveCandle] Initialized forming candle:', formingCandle);
            } else {
                // Update existing forming candle
                formingCandle.high = Math.max(formingCandle.high, price);
                formingCandle.low = Math.min(formingCandle.low, price);
                formingCandle.close = price;
                formingCandle.volume += amount;
            }

            // Update the chart with the forming candle
            try {
                liveMarketCandleSeries.update({
                    time: formingCandle.time,
                    open: formingCandle.open,
                    high: formingCandle.high,
                    low: formingCandle.low,
                    close: formingCandle.close
                });
            } catch (err) {
                console.error('[LiveCandle] Update error:', err);
            }
        }

        // Initialize forming candle from loaded historical data
        function initFormingCandleFromData(candles) {
            if (!candles || candles.length === 0) return;

            const lastCandle = candles[candles.length - 1];
            const now = Math.floor(Date.now() / 1000);
            const currentPeriodStart = getPeriodStartTime(now, currentMarketPeriod);

            // If the last candle is from the current period, use it as the forming candle
            if (lastCandle.time === currentPeriodStart) {
                formingCandle = {
                    time: lastCandle.time,
                    open: lastCandle.open,
                    high: lastCandle.high,
                    low: lastCandle.low,
                    close: lastCandle.close,
                    volume: lastCandle.volume || 0
                };
                console.log('[LiveCandle] Restored forming candle from data:', formingCandle);
            } else {
                // Last candle is from a previous period, create a new forming candle
                // Use the last candle's close as the starting point
                formingCandle = {
                    time: currentPeriodStart,
                    open: lastCandle.close,
                    high: lastCandle.close,
                    low: lastCandle.close,
                    close: lastCandle.close,
                    volume: 0
                };
                console.log('[LiveCandle] Created new forming candle from last close:', formingCandle);

                // Add this forming candle to the chart
                try {
                    liveMarketCandleSeries.update({
                        time: formingCandle.time,
                        open: formingCandle.open,
                        high: formingCandle.high,
                        low: formingCandle.low,
                        close: formingCandle.close
                    });
                } catch (err) {
                    console.error('[LiveCandle] Init update error:', err);
                }
            }
        }

        const MARKET_NAMES = {
            'xbtusd': 'BTC/USD',
            'ethusd': 'ETH/USD',
            'solusd': 'SOL/USD',
            'xrpusd': 'XRP/USD',
            'dogeusd': 'DOGE/USD'
        };

        // Strategy descriptions for the Live Test Control panel
        const STRATEGY_DESCRIPTIONS = {
            'none': 'Live market data only. Select a strategy to view trade overlays and backtest results.',
            'TestBot': 'Simple test strategy that trades every 60 seconds for verification purposes.',
            'DivergeBot': 'Arbitrage strategy that detects price divergence between BTC/USD and BTC/USDT markets.',
            'SazBot': 'Order book imbalance strategy analyzing bid/ask ratios at multiple depth levels (1%-25%).',
            'SDBot': 'Supply/demand zone trading based on detecting significant price runs and zone boundaries.',
            'PairTradeBot': 'Statistical arbitrage using mean reversion between correlated trading pairs.'
        };

        // Strategy indicator configurations
        const STRATEGY_INDICATORS = {
            'TestBot': [], // Simple - no indicators
            'DivergeBot': [
                { type: 'ema', period: 20, color: '#ff9800', label: 'EMA 20' }
            ],
            'SazBot': [
                { type: 'ema', period: 20, color: '#2196f3', label: 'EMA 20' },
                { type: 'ema', period: 50, color: '#ff9800', label: 'EMA 50' }
            ],
            'SDBot': [
                { type: 'ema', period: 20, color: '#2196f3', label: 'EMA 20' },
                { type: 'ema', period: 50, color: '#ff9800', label: 'EMA 50' },
                { type: 'bollinger', period: 20, stdDev: 2, color: '#9c27b0', label: 'BB' }
            ],
            'PairTradeBot': [
                { type: 'ema', period: 20, color: '#2196f3', label: 'EMA 20' },
                { type: 'ema', period: 50, color: '#ff9800', label: 'EMA 50' }
            ]
        };

        // Indicator line series for live market chart
        let indicatorSeries = {}; // { 'ema_20': lineSeries, 'ema_50': lineSeries, etc. }
        let currentStrategyIndicators = 'TestBot';

        // Calculate EMA from candle data
        function calculateEMA(candles, period) {
            if (!candles || candles.length < period) return [];
            const k = 2 / (period + 1);
            const emaData = [];

            // Initialize with SMA for first period
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += candles[i].close;
            }
            let ema = sum / period;
            emaData.push({ time: candles[period - 1].time, value: ema });

            // Calculate EMA for remaining candles
            for (let i = period; i < candles.length; i++) {
                ema = candles[i].close * k + ema * (1 - k);
                emaData.push({ time: candles[i].time, value: ema });
            }
            return emaData;
        }

        // Calculate Bollinger Bands from candle data
        function calculateBollingerBands(candles, period, stdDev) {
            if (!candles || candles.length < period) return { upper: [], middle: [], lower: [] };

            const upper = [], middle = [], lower = [];

            for (let i = period - 1; i < candles.length; i++) {
                // Calculate SMA
                let sum = 0;
                for (let j = i - period + 1; j <= i; j++) {
                    sum += candles[j].close;
                }
                const sma = sum / period;

                // Calculate standard deviation
                let sqSum = 0;
                for (let j = i - period + 1; j <= i; j++) {
                    sqSum += Math.pow(candles[j].close - sma, 2);
                }
                const std = Math.sqrt(sqSum / period);

                const time = candles[i].time;
                middle.push({ time, value: sma });
                upper.push({ time, value: sma + stdDev * std });
                lower.push({ time, value: sma - stdDev * std });
            }

            return { upper, middle, lower };
        }

        // Clear all indicator series from chart
        function clearIndicators() {
            for (const key in indicatorSeries) {
                if (indicatorSeries[key] && liveMarketChart) {
                    try {
                        liveMarketChart.removeSeries(indicatorSeries[key]);
                    } catch (e) {
                        console.warn('[Indicators] Error removing series:', key, e);
                    }
                }
            }
            indicatorSeries = {};
        }

        // Update indicators for the selected strategy
        function updateChartIndicators(strategy) {
            if (!liveMarketChart || !lastCandleData.length) return;

            // Clear existing indicators
            clearIndicators();

            const indicators = STRATEGY_INDICATORS[strategy] || [];
            currentStrategyIndicators = strategy;

            if (indicators.length === 0) {
                console.log('[Indicators] No indicators for', strategy);
                return;
            }

            console.log('[Indicators] Adding indicators for', strategy, ':', indicators.length);

            for (const config of indicators) {
                if (config.type === 'ema') {
                    const emaData = calculateEMA(lastCandleData, config.period);
                    if (emaData.length > 0) {
                        const series = liveMarketChart.addLineSeries({
                            color: config.color,
                            lineWidth: 1,
                            title: config.label,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                        series.setData(emaData);
                        indicatorSeries[`ema_${config.period}`] = series;
                        console.log(`[Indicators] Added EMA ${config.period} with ${emaData.length} points`);
                    }
                } else if (config.type === 'bollinger') {
                    const bb = calculateBollingerBands(lastCandleData, config.period, config.stdDev);
                    if (bb.upper.length > 0) {
                        // Upper band
                        const upperSeries = liveMarketChart.addLineSeries({
                            color: config.color,
                            lineWidth: 1,
                            lineStyle: 2, // Dashed
                            title: 'BB Upper',
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                        upperSeries.setData(bb.upper);
                        indicatorSeries['bb_upper'] = upperSeries;

                        // Lower band
                        const lowerSeries = liveMarketChart.addLineSeries({
                            color: config.color,
                            lineWidth: 1,
                            lineStyle: 2, // Dashed
                            title: 'BB Lower',
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                        lowerSeries.setData(bb.lower);
                        indicatorSeries['bb_lower'] = lowerSeries;

                        console.log(`[Indicators] Added Bollinger Bands with ${bb.upper.length} points`);
                    }
                }
            }
        }

        // Update strategy description when selector changes
        function updateStrategyDescription(strategy) {
            const descEl = document.getElementById('strategy-description');
            if (descEl) {
                descEl.textContent = STRATEGY_DESCRIPTIONS[strategy] || 'No description available.';
            }
        }

        // Current dashboard mode ('market' = no strategy, 'strategy' = strategy selected)
        let currentDashboardMode = 'market';

        // Switch dashboard mode based on strategy selection
        // Mode A (market): Live price chart + orderbook + recent trades
        // Mode B (strategy): Price chart with trade overlays + equity curve
        async function switchDashboardMode(mode) {
            const dashboardContent = document.getElementById('dashboard-content');
            const liveMarketContent = document.getElementById('live-market-content');
            const sessionControl = document.getElementById('session-control');
            const exportButtons = document.querySelector('.export-buttons');
            const liveTestPanel = document.getElementById('live-test-panel');
            const liveTradeFeed = document.getElementById('live-trade-feed');
            const equityCurveContainer = document.getElementById('equity-curve-container');
            const tradeOverlayLegend = document.getElementById('trade-overlay-legend');

            currentDashboardMode = mode;

            if (mode === 'market') {
                // Mode A: No strategy selected - show live market view
                if (dashboardContent) {
                    dashboardContent.style.display = 'none';
                    dashboardContent.classList.add('hidden');
                }
                if (liveMarketContent) {
                    liveMarketContent.classList.add('active');
                    liveMarketContent.style.display = 'block';
                }

                // Hide backtest controls
                document.querySelectorAll('.control-group').forEach(el => el.style.display = 'none');
                if (exportButtons) exportButtons.style.display = 'none';
                if (liveTradeFeed) liveTradeFeed.style.display = 'none';
                if (equityCurveContainer) equityCurveContainer.style.display = 'none';
                if (tradeOverlayLegend) tradeOverlayLegend.style.display = 'none';

                // Initialize live market chart
                if (!liveMarketChart) initLiveMarketChart();
                await loadLiveMarketData();
                liveMarketRefreshInterval = setInterval(loadLiveMarketData, 300000);
                connectLiveMarketWebSocket();

                // Clear trade overlays from chart
                clearTradeOverlays();

                // Update chart title
                const chartTitle = document.getElementById('live-chart-title');
                if (chartTitle) chartTitle.textContent = 'BTC/USD Live Price';

            } else if (mode === 'strategy') {
                // Mode B: Strategy selected - show price chart with trade overlays + equity curve
                if (dashboardContent) {
                    dashboardContent.style.display = 'none';
                    dashboardContent.classList.add('hidden');
                }
                if (liveMarketContent) {
                    liveMarketContent.classList.add('active');
                    liveMarketContent.style.display = 'block';
                }

                // Keep live market chart but add trade overlays
                if (!liveMarketChart) initLiveMarketChart();
                await loadLiveMarketData();
                liveMarketRefreshInterval = setInterval(loadLiveMarketData, 300000);
                connectLiveMarketWebSocket();

                // Show equity curve container and trade overlay legend
                if (equityCurveContainer) equityCurveContainer.style.display = 'block';
                if (tradeOverlayLegend) tradeOverlayLegend.style.display = 'flex';

                // Hide other controls
                document.querySelectorAll('.control-group').forEach(el => el.style.display = 'none');
                if (exportButtons) exportButtons.style.display = 'none';
                if (liveTradeFeed) liveTradeFeed.style.display = 'none';

                // Load trade overlays for selected strategy
                await loadTradeOverlays();

                // Load equity curve
                await loadEquityCurve();

                // Update chart title with strategy
                const chartTitle = document.getElementById('live-chart-title');
                if (chartTitle) chartTitle.textContent = `BTC/USD Price with ${currentStrategy} Trades`;
            }
        }

        // Initialize mode switching based on strategy selector
        function initViewToggle() {
            // Mode is now driven by strategy selector
            // This function is kept for backwards compatibility
            // Actual mode switching happens in strategy selector change handler
        }

        // Clear trade overlay markers from the live market chart
        function clearTradeOverlays() {
            if (liveMarketCandleSeries) {
                liveMarketCandleSeries.setMarkers([]);
            }
        }

        // Load and display trade overlays on the live market chart
        async function loadTradeOverlays() {
            console.log('[Trade Overlays] >>> loadTradeOverlays() CALLED <<<');
            console.log(`[Trade Overlays] liveMarketCandleSeries exists: ${!!liveMarketCandleSeries}`);
            console.log(`[Trade Overlays] lastCandleData length: ${lastCandleData?.length || 0}`);
            console.log(`[Trade Overlays] currentStrategy: ${currentStrategy}`);

            if (!liveMarketCandleSeries || !lastCandleData.length) {
                console.log('[Trade Overlays] ABORT: No candle series or candle data available');
                return;
            }
            if (currentStrategy === 'none') {
                console.log('[Trade Overlays] ABORT: Strategy is none, clearing overlays');
                clearTradeOverlays();
                return;
            }

            let trades = [];

            try {
                // Try live test session first
                console.log(`[Trade Overlays] Fetching: ${CONTROL_API_URL}/session/test`);
                const testResponse = await fetch(`${CONTROL_API_URL}/session/test`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                console.log(`[Trade Overlays] /session/test status: ${testResponse.status}`);
                if (testResponse.ok) {
                    const testData = await testResponse.json();
                    if (testData.success && testData.trades && testData.trades.length > 0) {
                        trades = testData.trades;
                        console.log(`[Trade Overlays] Loaded ${trades.length} trades from live test session`);
                    }
                } else if (testResponse.status === 401) {
                    console.warn('[Trade Overlays] /session/test 401 - API key may be invalid');
                }

                // If no live test trades, try backtest session
                if (trades.length === 0) {
                    console.log(`[Trade Overlays] Fetching: ${CONTROL_API_URL}/session/backtest`);
                    const backtestResponse = await fetch(`${CONTROL_API_URL}/session/backtest`, {
                        headers: { 'x-api-key': CONTROL_API_KEY }
                    });
                    console.log(`[Trade Overlays] /session/backtest status: ${backtestResponse.status}`);
                    if (backtestResponse.ok) {
                        const backtestData = await backtestResponse.json();
                        if (backtestData.success && backtestData.trades && backtestData.trades.length > 0) {
                            trades = backtestData.trades;
                            console.log(`[Trade Overlays] Loaded ${trades.length} trades from backtest session`);
                        }
                    } else if (backtestResponse.status === 401) {
                        console.warn('[Trade Overlays] /session/backtest 401 - API key may be invalid');
                    }
                }

                if (trades.length === 0) {
                    console.log('[Trade Overlays] No active session - run a backtest to see trade arrows on chart');
                    clearTradeOverlays();
                    return;
                }

                const markers = [];

                // Helper to find closest candle to a timestamp
                const findClosestCandle = (timestamp) => {
                    return lastCandleData.reduce((prev, curr) => {
                        return Math.abs(curr.time - timestamp) < Math.abs(prev.time - timestamp) ? curr : prev;
                    });
                };

                trades.forEach(trade => {
                    // ENTRY marker - arrow shape
                    const entryTime = trade.timestamp_unix || trade.entry_time_unix;
                    if (entryTime) {
                        const entryCandle = findClosestCandle(entryTime);
                        markers.push({
                            time: entryCandle.time,
                            position: trade.side === 'long' ? 'belowBar' : 'aboveBar',
                            color: trade.side === 'long' ? '#2196F3' : '#FF9800', // Blue for long, orange for short
                            shape: trade.side === 'long' ? 'arrowUp' : 'arrowDown',
                            text: '' // No text to prevent overlap
                        });
                    }

                    // EXIT marker - circle shape (if exit data exists)
                    if (trade.exit_time_unix && trade.exit_price) {
                        const exitCandle = findClosestCandle(trade.exit_time_unix);
                        markers.push({
                            time: exitCandle.time,
                            position: trade.side === 'long' ? 'aboveBar' : 'belowBar',
                            color: trade.pnl >= 0 ? '#00c853' : '#ff5252', // Green for profit, red for loss
                            shape: 'circle',
                            text: ''
                        });
                    }
                });

                // Sort markers by time (required by Lightweight Charts)
                markers.sort((a, b) => a.time - b.time);
                liveMarketCandleSeries.setMarkers(markers);
                console.log(`[Trade Overlays] Displayed ${markers.length} markers for ${trades.length} trades`);

            } catch (err) {
                console.error('[Trade Overlays] Error loading trades:', err);
            }
        }

        // Equity curve chart instance
        let equityCurveChart = null;
        let equitySeries = null;
        let drawdownSeries = null;

        // Load and display equity curve in the separate chart
        async function loadEquityCurve() {
            const container = document.getElementById('equity-curve-chart-container');
            if (!container) return;

            if (currentStrategy === 'none') {
                // Clear equity curve in market mode
                if (equityCurveChart) {
                    equityCurveChart.remove();
                    equityCurveChart = null;
                    equitySeries = null;
                    drawdownSeries = null;
                }
                return;
            }

            try {
                // Fetch equity curve data from session/test endpoint
                const response = await fetch(`${CONTROL_API_URL}/session/test`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (!response.ok) {
                    console.log('[Equity Curve] No test session data available');
                    return;
                }

                const data = await response.json();
                if (!data.success || !data.equity_curve || data.equity_curve.length === 0) {
                    console.log('[Equity Curve] No equity curve data');
                    // Show empty state
                    if (!equityCurveChart) {
                        initEquityCurveChart(container);
                    }
                    if (equitySeries) equitySeries.setData([]);
                    if (drawdownSeries) drawdownSeries.setData([]);
                    return;
                }

                // Initialize chart if not exists
                if (!equityCurveChart) {
                    initEquityCurveChart(container);
                }

                // Format equity curve data for Lightweight Charts
                const equityData = data.equity_curve.map(point => ({
                    time: point.timestamp_unix,
                    value: point.equity
                }));

                // Format drawdown data (inverted to show below zero line)
                const drawdownData = data.equity_curve.map(point => ({
                    time: point.timestamp_unix,
                    value: -(point.drawdown || 0) / 100  // Negative percentage as decimal
                }));

                equitySeries.setData(equityData);
                drawdownSeries.setData(drawdownData);

                // Update title with strategy name
                const titleEl = document.getElementById('equity-chart-title');
                if (titleEl) titleEl.textContent = `${currentStrategy} Equity Curve`;

                equityCurveChart.timeScale().fitContent();
                console.log(`[Equity Curve] Loaded ${equityData.length} points`);

            } catch (err) {
                console.error('[Equity Curve] Error loading data:', err);
            }
        }

        // Initialize the equity curve chart
        function initEquityCurveChart(container) {
            equityCurveChart = LightweightCharts.createChart(container, {
                layout: { background: { type: 'solid', color: 'transparent' }, textColor: '#8892b0' },
                grid: { vertLines: { color: 'rgba(255,255,255,0.05)' }, horzLines: { color: 'rgba(255,255,255,0.05)' } },
                timeScale: { timeVisible: true, secondsVisible: false, borderColor: 'rgba(255,255,255,0.1)' },
                rightPriceScale: { borderColor: 'rgba(255,255,255,0.1)', autoScale: true },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                height: 200
            });

            equitySeries = equityCurveChart.addLineSeries({
                color: '#4caf50',
                lineWidth: 2,
                priceScaleId: 'right'
            });

            drawdownSeries = equityCurveChart.addAreaSeries({
                topColor: 'rgba(255, 82, 82, 0.4)',
                bottomColor: 'rgba(255, 82, 82, 0.1)',
                lineColor: '#ff5252',
                lineWidth: 1,
                priceScaleId: 'left'
            });

            // Configure left scale for drawdown
            equityCurveChart.applyOptions({
                leftPriceScale: {
                    visible: true,
                    borderColor: 'rgba(255,255,255,0.1)',
                    autoScale: true
                }
            });

            // Resize observer
            const resizeObserver = new ResizeObserver(() => {
                equityCurveChart.applyOptions({ width: container.clientWidth });
            });
            resizeObserver.observe(container);
        }

        // Volume series for live market chart
        let liveMarketVolumeSeries = null;

        // Initialize live market chart
        function initLiveMarketChart() {
            const container = document.getElementById('live-price-chart-container');
            if (!container) return;

            liveMarketChart = LightweightCharts.createChart(container, {
                layout: { background: { type: 'solid', color: 'transparent' }, textColor: '#8892b0' },
                grid: { vertLines: { color: 'rgba(255,255,255,0.05)' }, horzLines: { color: 'rgba(255,255,255,0.05)' } },
                timeScale: { timeVisible: true, secondsVisible: false, borderColor: 'rgba(255,255,255,0.1)' },
                rightPriceScale: { borderColor: 'rgba(255,255,255,0.1)', autoScale: true, scaleMargins: { top: 0.1, bottom: 0.25 } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal }
            });

            liveMarketCandleSeries = liveMarketChart.addCandlestickSeries({
                upColor: '#26a69a', downColor: '#ef5350', borderVisible: false,
                wickUpColor: '#26a69a', wickDownColor: '#ef5350'
            });

            // Add volume histogram series below the candlesticks
            liveMarketVolumeSeries = liveMarketChart.addHistogramSeries({
                color: '#26a69a',
                priceFormat: { type: 'volume' },
                priceScaleId: 'volume',
            });

            // Configure volume scale to appear at the bottom
            liveMarketChart.priceScale('volume').applyOptions({
                scaleMargins: { top: 0.85, bottom: 0 },
                borderVisible: false,
            });

            // Subscribe to crosshair move for OHLC display
            liveMarketChart.subscribeCrosshairMove((param) => {
                updateOHLCDisplay(param);
            });

            const resizeObserver = new ResizeObserver(() => {
                liveMarketChart.applyOptions({ width: container.clientWidth });
            });
            resizeObserver.observe(container);

            // Subscribe to visible range changes for lazy loading
            liveMarketChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
                if (!logicalRange || !lastCandleData.length || isLoadingOlderCandles) return;

                // Check if user has scrolled near the left edge (first 10% of visible range)
                const visibleBarsCount = logicalRange.to - logicalRange.from;
                const leftEdgeThreshold = Math.max(5, Math.floor(visibleBarsCount * 0.1));

                // If logicalRange.from is close to 0, user is at the start of data
                if (logicalRange.from < leftEdgeThreshold) {
                    loadOlderCandles();
                }
            });
        }

        // Update OHLC display on crosshair move
        function updateOHLCDisplay(param) {
            const openEl = document.getElementById('ohlc-open');
            const highEl = document.getElementById('ohlc-high');
            const lowEl = document.getElementById('ohlc-low');
            const closeEl = document.getElementById('ohlc-close');
            const volumeEl = document.getElementById('ohlc-volume');

            if (!openEl || !highEl || !lowEl || !closeEl) return;

            if (!param || !param.time || !param.seriesData) {
                // Reset to latest candle when crosshair is not on chart
                if (lastCandleData && lastCandleData.length > 0) {
                    const latest = lastCandleData[lastCandleData.length - 1];
                    openEl.textContent = formatPrice(latest.open);
                    highEl.textContent = formatPrice(latest.high);
                    lowEl.textContent = formatPrice(latest.low);
                    closeEl.textContent = formatPrice(latest.close);
                    if (volumeEl) volumeEl.textContent = formatVolume(latest.volume || 0);

                    // Set colors based on candle direction
                    const isUp = latest.close >= latest.open;
                    const color = isUp ? 'up' : 'down';
                    [openEl, highEl, lowEl, closeEl].forEach(el => {
                        el.classList.remove('up', 'down');
                        el.classList.add(color);
                    });
                }
                return;
            }

            // Get candle data at crosshair position
            const candleData = param.seriesData.get(liveMarketCandleSeries);
            if (candleData) {
                openEl.textContent = formatPrice(candleData.open);
                highEl.textContent = formatPrice(candleData.high);
                lowEl.textContent = formatPrice(candleData.low);
                closeEl.textContent = formatPrice(candleData.close);

                // Get volume data
                const volumeData = param.seriesData.get(liveMarketVolumeSeries);
                if (volumeEl && volumeData) {
                    volumeEl.textContent = formatVolume(volumeData.value || 0);
                }

                // Set colors based on candle direction
                const isUp = candleData.close >= candleData.open;
                const color = isUp ? 'up' : 'down';
                [openEl, highEl, lowEl, closeEl].forEach(el => {
                    el.classList.remove('up', 'down');
                    el.classList.add(color);
                });
            }
        }

        // Format price for OHLC display
        function formatPrice(price) {
            if (price >= 10000) return price.toFixed(1);
            if (price >= 1000) return price.toFixed(2);
            if (price >= 1) return price.toFixed(4);
            return price.toFixed(6);
        }

        // Format volume for OHLC display
        function formatVolume(volume) {
            if (volume >= 1000000) return (volume / 1000000).toFixed(2) + 'M';
            if (volume >= 1000) return (volume / 1000).toFixed(1) + 'K';
            return volume.toFixed(0);
        }

        // Update volume series with candle data
        function updateVolumeSeries(candles) {
            if (!liveMarketVolumeSeries || !candles || candles.length === 0) return;

            // Check if we have real volume data
            const hasVolume = candles.some(c => c.volume && c.volume > 0);
            console.log(`[Volume] Has real volume data: ${hasVolume}, candles: ${candles.length}`);

            const volumeData = candles.map(c => {
                // Use real volume if available, otherwise generate synthetic volume based on price movement
                let volume = c.volume || 0;
                if (!hasVolume) {
                    // Generate synthetic volume: larger moves = more volume
                    const priceRange = Math.abs(c.high - c.low);
                    const avgPrice = (c.high + c.low) / 2;
                    volume = priceRange / avgPrice * 1000000; // Synthetic volume based on volatility
                }
                return {
                    time: c.time,
                    value: volume,
                    color: c.close >= c.open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                };
            });

            liveMarketVolumeSeries.setData(volumeData);
            console.log(`[Volume] Set ${volumeData.length} volume bars`);
        }

        // Load older candles when user scrolls left
        async function loadOlderCandles() {
            if (isLoadingOlderCandles || !earliestCandleTime) return;

            // Check if we've already loaded all available archive data
            if (archiveMinTime && earliestCandleTime <= archiveMinTime) {
                console.log('[LazyLoad] Already at archive start, no more data available');
                return;
            }

            isLoadingOlderCandles = true;
            const chartTitle = document.getElementById('live-chart-title');
            const originalTitle = chartTitle?.textContent || '';

            try {
                // Show loading indicator
                if (chartTitle) {
                    chartTitle.textContent = originalTitle.replace(')', '   Loading older...)').replace('))', ')');
                }

                // Calculate time range to fetch (go back by period-appropriate amount)
                const periodSeconds = PERIOD_SECONDS[currentMarketPeriod] || 300;
                const candlesToFetch = 200; // Fetch ~200 candles at a time
                const fetchDuration = candlesToFetch * periodSeconds;

                const endTime = earliestCandleTime - 1; // Just before our earliest
                const startTime = endTime - fetchDuration;

                console.log(`[LazyLoad] Fetching older candles: ${new Date(startTime * 1000).toISOString()} to ${new Date(endTime * 1000).toISOString()}`);

                const response = await fetch(
                    `${CONTROL_API_URL}/api/prices?market=${currentMarket}&period=${currentMarketPeriod}&startTime=${startTime}&endTime=${endTime}&source=archive`,
                    { headers: { 'x-api-key': CONTROL_API_KEY } }
                );

                if (!response.ok) throw new Error('Failed to fetch older candles');
                const data = await response.json();

                if (data.success && data.candles && data.candles.length > 0) {
                    const olderCandles = data.candles.map(c => ({
                        time: c.time, open: c.open, high: c.high, low: c.low, close: c.close,
                        volume: c.volume || 0
                    }));

                    // Filter out any duplicates (candles we already have)
                    const existingTimes = new Set(lastCandleData.map(c => c.time));
                    const newCandles = olderCandles.filter(c => !existingTimes.has(c.time));

                    if (newCandles.length > 0) {
                        // Prepend new candles to existing data
                        lastCandleData = [...newCandles, ...lastCandleData];
                        // Sort by time to ensure correct order
                        lastCandleData.sort((a, b) => a.time - b.time);

                        // Update earliest time
                        earliestCandleTime = lastCandleData[0].time;

                        // Update chart with all data
                        liveMarketCandleSeries.setData(lastCandleData);

                        // Update volume series
                        updateVolumeSeries(lastCandleData);

                        // Re-calculate and update indicators with new data
                        updateChartIndicators(currentStrategyIndicators);

                        console.log(`[LazyLoad] Added ${newCandles.length} older candles, total: ${lastCandleData.length}`);

                        // Update title with new candle count
                        if (chartTitle) {
                            chartTitle.textContent = `${MARKET_NAMES[currentMarket]} Price ( Archive  ${lastCandleData.length} candles   Live)`;
                        }
                    } else {
                        console.log('[LazyLoad] No new candles in response (all duplicates)');
                        // Restore original title
                        if (chartTitle) chartTitle.textContent = originalTitle;
                    }
                } else {
                    console.log('[LazyLoad] No older data available');
                    // Restore original title
                    if (chartTitle) chartTitle.textContent = originalTitle;
                }
            } catch (err) {
                console.error('[LazyLoad] Error:', err);
                // Restore original title
                if (chartTitle) chartTitle.textContent = originalTitle;
            } finally {
                isLoadingOlderCandles = false;
            }
        }

        // Fetch archive info to know the available data range
        async function fetchArchiveInfo(market) {
            try {
                const response = await fetch(
                    `${CONTROL_API_URL}/api/archive/info?market=${market}`,
                    { headers: { 'x-api-key': CONTROL_API_KEY } }
                );
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.archive?.available) {
                        archiveMinTime = data.archive.minTime;
                        console.log(`[Archive] Data available from ${new Date(archiveMinTime * 1000).toISOString()}`);
                    }
                }
            } catch (err) {
                console.error('[Archive] Error fetching archive info:', err);
            }
        }

        // Load all live market data
        async function loadLiveMarketData() {
            const refreshBtn = document.getElementById('refresh-market-btn');
            if (refreshBtn) { refreshBtn.disabled = true; refreshBtn.textContent = ' Loading...'; }
            try {
                await Promise.all([loadPriceData(), loadOrderbookData(), loadTradesData()]);
            } catch (err) { console.error('Error loading market data:', err); }
            finally { if (refreshBtn) { refreshBtn.disabled = false; refreshBtn.textContent = ' Refresh'; } }
        }

        // Load price/candle data
        async function loadPriceData() {
            const chartTitle = document.getElementById('live-chart-title');
            const priceDisplay = document.getElementById('current-market-price');

            // Show loading state
            chartTitle.textContent = `${MARKET_NAMES[currentMarket]} Price ( Loading...)`;
            priceDisplay.textContent = '...';

            try {
                // Use hybrid source to combine archive (historical) + MySQL (recent) data
                const response = await fetch(`${CONTROL_API_URL}/api/prices?market=${currentMarket}&period=${currentMarketPeriod}&limit=500&source=hybrid`,
                    { headers: { 'x-api-key': CONTROL_API_KEY } });
                if (!response.ok) throw new Error('Failed to fetch prices');
                const data = await response.json();
                if (data.success && data.candles && data.candles.length > 0) {
                    const candles = data.candles.map(c => ({
                        time: c.time, open: c.open, high: c.high, low: c.low, close: c.close,
                        volume: c.volume || 0
                    }));
                    lastCandleData = candles; // Store for reference
                    earliestCandleTime = candles[0].time; // Track earliest for lazy loading
                    liveMarketCandleSeries.setData(candles);

                    // Update volume series
                    updateVolumeSeries(candles);

                    // Update OHLC display with latest candle
                    updateOHLCDisplay(null);

                    // Fetch archive info for lazy loading bounds (don't await, do in background)
                    fetchArchiveInfo(currentMarket);

                    // Update chart indicators for selected strategy
                    const selectedStrategy = document.getElementById('strategy-selector')?.value || 'TestBot';
                    updateChartIndicators(selectedStrategy);

                    // Show only recent data (scroll to right) instead of all data
                    // This prevents large time gaps from compressing the visible candles
                    const lastTime = candles[candles.length - 1].time;
                    // Scale visible range based on period for appropriate candle count
                    const hoursToShowByPeriod = {
                        '1m': 6,      // 360 candles
                        '5m': 6,      // 72 candles
                        '15m': 12,    // 48 candles
                        '1h': 24,     // 24 candles
                        '4h': 96,     // 24 candles (4 days)
                        '1d': 720,    // 30 candles (30 days)
                        '1w': 2520    // 15 candles (105 days)
                    };
                    const hoursToShow = hoursToShowByPeriod[currentMarketPeriod] || 6;
                    const visibleFrom = lastTime - (hoursToShow * 3600);
                    liveMarketChart.timeScale().setVisibleRange({
                        from: visibleFrom,
                        to: lastTime + 300 // Small buffer for forming candle
                    });

                    // Force price scale to auto-fit the visible data
                    liveMarketChart.priceScale('right').applyOptions({
                        autoScale: true,
                        scaleMargins: { top: 0.1, bottom: 0.1 }
                    });

                    // Initialize the forming candle from loaded data
                    initFormingCandleFromData(candles);

                    const lastCandle = data.candles[data.candles.length - 1];
                    const firstCandle = data.candles[0];
                    priceDisplay.textContent = formatMarketPrice(lastCandle.close, currentMarket);
                    const change = ((lastCandle.close - firstCandle.open) / firstCandle.open * 100).toFixed(2);
                    const changeBadge = document.getElementById('price-change-badge');
                    const changeValue = document.getElementById('price-change-value');
                    changeValue.textContent = `${change >= 0 ? '+' : ''}${change}%`;
                    changeBadge.className = `price-change ${change >= 0 ? 'positive' : 'negative'}`;

                    // Update professional trading header
                    updateTradingHeader(lastCandle.close, parseFloat(change));

                    // Calculate 24h high/low from candles
                    const high24h = Math.max(...data.candles.map(c => c.high));
                    const low24h = Math.min(...data.candles.map(c => c.low));
                    const highEl = document.getElementById('header-high');
                    const lowEl = document.getElementById('header-low');
                    if (highEl) highEl.textContent = formatMarketPrice(high24h, currentMarket);
                    if (lowEl) lowEl.textContent = formatMarketPrice(low24h, currentMarket);

                    // Update candle count in toolbar
                    const candleCountEl = document.getElementById('candle-count');
                    if (candleCountEl) candleCountEl.textContent = `${data.candles.length} candles`;

                    // Show data source and candle count
                    const sourceLabels = { 'archive': ' Archive', 'mysql': ' Live', 'hybrid': ' Combined' };
                    const sourceLabel = sourceLabels[data.source] || data.source;
                    chartTitle.textContent = `${MARKET_NAMES[currentMarket]} Price (${sourceLabel}  ${data.candleCount || data.candles.length} candles   Live)`;
                } else {
                    chartTitle.textContent = `${MARKET_NAMES[currentMarket]} Price (No data)`;
                    priceDisplay.textContent = '--';
                }
            } catch (err) {
                console.error('Error loading price data:', err);
                chartTitle.textContent = `${MARKET_NAMES[currentMarket]} Price (Error)`;
                priceDisplay.textContent = '--';
            }
        }

        // Load orderbook data
        async function loadOrderbookData() {
            const spreadEl = document.getElementById('orderbook-spread');
            spreadEl.textContent = 'Loading...';

            try {
                const response = await fetch(`${CONTROL_API_URL}/api/orderbook?market=${currentMarket}&depth=12`,
                    { headers: { 'x-api-key': CONTROL_API_KEY } });
                if (!response.ok) throw new Error('Failed to fetch orderbook');
                const data = await response.json();
                if (data.success) {
                    // Use professional orderbook rendering
                    renderOrderbookPro(data.bids || [], data.asks || []);
                    if (data.bids?.length && data.asks?.length) {
                        const spread = data.asks[0].price - data.bids[0].price;
                        const spreadPct = (spread / data.asks[0].price * 100).toFixed(3);
                        if (spreadEl) spreadEl.textContent = `Spread: ${formatMarketPrice(spread, currentMarket)} (${spreadPct}%)`;
                    } else {
                        if (spreadEl) spreadEl.textContent = 'No data';
                    }
                }
            } catch (err) {
                console.error('Error loading orderbook:', err);
                spreadEl.textContent = 'Error loading';
            }
        }

        // Render orderbook (legacy + pro)
        function renderOrderbook(bids, asks) {
            // Render pro orderbook
            renderOrderbookPro(bids, asks);

            // Legacy orderbook rendering
            const bidsContainer = document.getElementById('orderbook-bids');
            const asksContainer = document.getElementById('orderbook-asks');
            if (!bidsContainer || !asksContainer) return;

            const allAmounts = [...bids, ...asks].map(o => o.amount);
            const maxAmount = Math.max(...allAmounts);
            bidsContainer.innerHTML = bids.slice(0, 10).map(bid => {
                const barWidth = (bid.amount / maxAmount * 100).toFixed(1);
                return `<div class="orderbook-row"><span class="bar" style="width: ${barWidth}%"></span><span class="price">${formatMarketPrice(bid.price, currentMarket)}</span><span class="amount">${formatMarketAmount(bid.amount)}</span></div>`;
            }).join('');
            asksContainer.innerHTML = asks.slice(0, 10).map(ask => {
                const barWidth = (ask.amount / maxAmount * 100).toFixed(1);
                return `<div class="orderbook-row"><span class="bar" style="width: ${barWidth}%"></span><span class="price">${formatMarketPrice(ask.price, currentMarket)}</span><span class="amount">${formatMarketAmount(ask.amount)}</span></div>`;
            }).join('');
        }

        // Load trades data
        async function loadTradesData() {
            const countEl = document.getElementById('trades-count');
            countEl.textContent = 'Loading...';

            try {
                const response = await fetch(`${CONTROL_API_URL}/api/trades?market=${currentMarket}&limit=50`,
                    { headers: { 'x-api-key': CONTROL_API_KEY } });
                if (!response.ok) throw new Error('Failed to fetch trades');
                const data = await response.json();
                if (data.success && data.trades) {
                    renderLiveMarketTrades(data.trades);
                    countEl.textContent = `${data.trades.length} trades`;
                } else {
                    countEl.textContent = 'No trades';
                }
            } catch (err) {
                console.error('Error loading trades:', err);
                countEl.textContent = 'Error';
            }
        }

        // Render live market trades (renamed to avoid collision with backtest renderTrades)
        function renderLiveMarketTrades(trades) {
            // Update professional trades panel
            renderTradesPro(trades);

            // Legacy table update
            const tbody = document.getElementById('trades-tbody');
            if (tbody) {
                tbody.innerHTML = trades.map(trade => {
                    const time = new Date(trade.timestamp * 1000).toLocaleTimeString();
                    const sideClass = trade.side === 'buy' ? 'side-buy' : 'side-sell';
                    return `<tr><td>${time}</td><td class="${sideClass}">${trade.side.toUpperCase()}</td><td>${formatMarketPrice(trade.price, currentMarket)}</td><td>${formatMarketAmount(trade.amount)}</td></tr>`;
                }).join('');
            }
        }

        // Format price based on market
        function formatMarketPrice(price, market) {
            if (market === 'dogeusd' || market === 'xrpusd') return price.toFixed(4);
            else if (market === 'solusd') return price.toFixed(2);
            return price.toFixed(1);
        }

        // Format amount
        function formatMarketAmount(amount) {
            if (amount >= 1000000) return (amount / 1000000).toFixed(2) + 'M';
            if (amount >= 1000) return (amount / 1000).toFixed(1) + 'K';
            return amount.toString();
        }

        // === PROFESSIONAL UI FUNCTIONS ===

        // Update header with current price and stats
        function updateTradingHeader(price, change24h = null) {
            const priceValueEl = document.getElementById('price-value');
            const priceMainEl = document.getElementById('header-price');
            const priceArrowEl = document.getElementById('price-arrow');
            const changeEl = document.getElementById('header-change');
            const markEl = document.getElementById('header-mark');

            if (priceValueEl && price) {
                // Format with comma separators
                const formattedPrice = price.toLocaleString('en-US', { minimumFractionDigits: 1, maximumFractionDigits: 1 });
                priceValueEl.textContent = formattedPrice;
            }

            if (priceMainEl && change24h !== null) {
                priceMainEl.className = 'price-main' + (change24h >= 0 ? '' : ' down');
            }

            if (priceArrowEl && change24h !== null) {
                priceArrowEl.textContent = change24h >= 0 ? '' : '';
            }

            if (changeEl && change24h !== null) {
                const changePercent = Math.abs(change24h).toFixed(2);
                changeEl.textContent = (change24h >= 0 ? '+' : '-') + changePercent + '%';
                changeEl.className = 'price-change' + (change24h >= 0 ? ' positive' : '');
            }

            if (markEl && price) {
                markEl.textContent = price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }

            // Update instrument name based on market
            const instrumentEl = document.getElementById('header-instrument');
            if (instrumentEl) {
                const names = { xbtusd: 'BTCUSD', ethusd: 'ETHUSD', solusd: 'SOLUSD', xrpusd: 'XRPUSD', dogeusd: 'DOGEUSD' };
                instrumentEl.textContent = names[currentMarket] || 'BTCUSD';
            }
        }

        // Render orderbook in professional format
        function renderOrderbookPro(bids, asks) {
            const bidsContainer = document.getElementById('orderbook-bids-pro');
            const asksContainer = document.getElementById('orderbook-asks-pro');
            const spreadRow = document.getElementById('spread-row');
            const spreadHeader = document.getElementById('orderbook-spread-header');

            if (!bidsContainer || !asksContainer) return;

            // Calculate totals and max for depth bars
            let bidTotal = 0, askTotal = 0;
            const bidRows = bids.slice(0, 12).map(b => { bidTotal += b.amount; return { ...b, total: bidTotal }; });
            const askRows = asks.slice(0, 12).reverse().map(a => { askTotal += a.amount; return { ...a, total: askTotal }; }).reverse();
            const maxTotal = Math.max(bidTotal, askTotal);

            // Render asks (sells) - reversed so lowest at bottom
            asksContainer.innerHTML = askRows.map(ask => {
                const depth = (ask.total / maxTotal * 100).toFixed(0);
                return `<div class="orderbook-row ask">
                    <span class="depth-bar" style="width: ${depth}%"></span>
                    <span class="ob-price">${formatMarketPrice(ask.price, currentMarket)}</span>
                    <span class="ob-size">${formatMarketAmount(ask.amount)}</span>
                    <span class="ob-total">${formatMarketAmount(ask.total)}</span>
                </div>`;
            }).join('');

            // Spread
            if (bids.length && asks.length) {
                const spread = asks[0].price - bids[0].price;
                const spreadPercent = (spread / asks[0].price * 100).toFixed(3);
                if (spreadRow) spreadRow.textContent = `Spread: ${formatMarketPrice(spread, currentMarket)} (${spreadPercent}%)`;
                if (spreadHeader) spreadHeader.textContent = `Spread: ${spreadPercent}%`;
            }

            // Render bids (buys)
            bidsContainer.innerHTML = bidRows.map(bid => {
                const depth = (bid.total / maxTotal * 100).toFixed(0);
                return `<div class="orderbook-row bid">
                    <span class="depth-bar" style="width: ${depth}%"></span>
                    <span class="ob-price">${formatMarketPrice(bid.price, currentMarket)}</span>
                    <span class="ob-size">${formatMarketAmount(bid.amount)}</span>
                    <span class="ob-total">${formatMarketAmount(bid.total)}</span>
                </div>`;
            }).join('');
            // Note: Don't call renderOrderbook here - it already calls us (avoid circular call)
        }

        // Render trades in professional format
        function renderTradesPro(trades) {
            const container = document.getElementById('recent-trades-pro');
            const countEl = document.getElementById('trades-count');
            if (!container) return;

            container.innerHTML = trades.slice(0, 30).map(trade => {
                const time = new Date(trade.timestamp * 1000).toLocaleTimeString('en-US', { hour12: false });
                const side = trade.side === 'buy' ? 'BUY' : 'SELL';
                return `<div class="trade-row ${trade.side}">
                    <span class="trade-time">${time}</span>
                    <span class="trade-side">${side}</span>
                    <span class="trade-price">${formatMarketPrice(trade.price, currentMarket)}</span>
                    <span class="trade-size">${formatMarketAmount(trade.amount)}</span>
                </div>`;
            }).join('');

            if (countEl) countEl.textContent = trades.length;
        }

        // Initialize period dropdown
        function initPeriodDropdown() {
            const btn = document.getElementById('period-btn');
            const menu = document.getElementById('period-menu');
            const label = document.getElementById('period-label');

            if (!btn || !menu) return;

            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                menu.classList.toggle('show');
            });

            document.addEventListener('click', () => menu.classList.remove('show'));

            menu.querySelectorAll('.period-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    const period = opt.dataset.period;
                    currentMarketPeriod = period;
                    if (label) label.textContent = period;
                    menu.querySelectorAll('.period-option').forEach(o => o.classList.remove('active'));
                    opt.classList.add('active');
                    menu.classList.remove('show');
                    formingCandle = null;
                    earliestCandleTime = null;
                    isLoadingOlderCandles = false;
                    clearIndicators();
                    loadPriceData();
                });
            });
        }

        // Initialize bottom period selector (time range buttons)
        function initChartPeriodBar() {
            const buttons = document.querySelectorAll('.chart-period-btn');
            if (!buttons.length) return;

            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const range = btn.dataset.range;
                    if (!range || !lastCandleData || lastCandleData.length === 0) return;

                    // Update active state
                    buttons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Calculate time range based on selection
                    const lastTime = lastCandleData[lastCandleData.length - 1].time;
                    let hoursBack;

                    switch (range) {
                        case '1y': hoursBack = 24 * 365; break;
                        case '1m': hoursBack = 24 * 30; break;
                        case '5d': hoursBack = 24 * 5; break;
                        case '1d': hoursBack = 24; break;
                        case '5h': hoursBack = 5; break;
                        default: hoursBack = 24;
                    }

                    const visibleFrom = lastTime - (hoursBack * 3600);
                    liveMarketChart.timeScale().setVisibleRange({
                        from: visibleFrom,
                        to: lastTime + 300
                    });
                });
            });
        }

        // Initialize live market controls
        function initLiveMarketControls() {
            const marketSelector = document.getElementById('market-selector');
            const periodSelector = document.getElementById('market-period-selector');
            const refreshBtn = document.getElementById('refresh-market-btn');
            if (marketSelector) marketSelector.addEventListener('change', (e) => {
                currentMarket = e.target.value;
                formingCandle = null; // Reset forming candle on market change
                earliestCandleTime = null; // Reset lazy loading state
                archiveMinTime = null;
                isLoadingOlderCandles = false;
                clearIndicators(); // Clear indicators before loading new data
                loadLiveMarketData();
                subscribeToMarket(currentMarket);
            });
            if (periodSelector) periodSelector.addEventListener('change', (e) => {
                currentMarketPeriod = e.target.value;
                formingCandle = null; // Reset forming candle on period change
                earliestCandleTime = null; // Reset lazy loading state
                isLoadingOlderCandles = false;
                clearIndicators(); // Clear indicators before loading new data
                loadPriceData();
            });
            if (refreshBtn) refreshBtn.addEventListener('click', loadLiveMarketData);
        }

        // ==========================================
        // LIVE MARKET WEBSOCKET
        // ==========================================
        let liveMarketWs = null;
        let liveMarketWsReconnectTimer = null;

        function connectLiveMarketWebSocket() {
            if (liveMarketWs && liveMarketWs.readyState === WebSocket.OPEN) return;

            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsHost = CONTROL_API_URL.replace(/^https?:/, wsProtocol);
            const wsUrl = `${wsHost}/trades/stream`;

            console.log('[LiveMarket WS] Connecting to:', wsUrl);
            liveMarketWs = new WebSocket(wsUrl);

            liveMarketWs.onopen = () => {
                console.log('[LiveMarket WS] Connected');
                subscribeToMarket(currentMarket);
            };

            liveMarketWs.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'market_update') {
                        handleMarketUpdate(data);
                    }
                } catch (err) {
                    console.error('[LiveMarket WS] Parse error:', err);
                }
            };

            liveMarketWs.onclose = () => {
                console.log('[LiveMarket WS] Disconnected, reconnecting in 5s...');
                liveMarketWsReconnectTimer = setTimeout(connectLiveMarketWebSocket, 5000);
            };

            liveMarketWs.onerror = (err) => {
                console.error('[LiveMarket WS] Error:', err);
            };
        }

        function subscribeToMarket(market) {
            if (liveMarketWs && liveMarketWs.readyState === WebSocket.OPEN) {
                liveMarketWs.send(JSON.stringify({ type: 'subscribe', channel: 'market', market: market }));
                console.log('[LiveMarket WS] Subscribed to:', market);
            }
        }

        function handleMarketUpdate(data) {
            // Update price display
            if (data.price) {
                const priceEl = document.getElementById('current-market-price');
                if (priceEl) priceEl.textContent = formatMarketPrice(data.price.value, data.market);

                // Update professional trading header
                updateTradingHeader(data.price.value, data.price.change24h || null);

                // Update forming candle with current price if we have one
                if (data.price.value && formingCandle) {
                    updateFormingCandle({
                        price: data.price.value,
                        timestamp: data.price.timestamp || Math.floor(Date.now() / 1000),
                        amount: 0
                    });
                }
            }

            // Update orderbook (professional version)
            if (data.orderbook) {
                renderOrderbookPro(data.orderbook.bids || [], data.orderbook.asks || []);
                if (data.orderbook.bids?.length && data.orderbook.asks?.length) {
                    const spread = data.orderbook.asks[0].price - data.orderbook.bids[0].price;
                    const spreadPct = (spread / data.orderbook.asks[0].price * 100).toFixed(3);
                    const legacySpread = document.getElementById('orderbook-spread');
                    if (legacySpread) legacySpread.textContent = `Spread: ${formatMarketPrice(spread, data.market)} (${spreadPct}%)`;
                }
            }

            // Update trades and forming candle
            if (data.trades && data.trades.length > 0) {
                renderLiveMarketTrades(data.trades);

                // Update forming candle with the most recent trade
                const latestTrade = data.trades[0]; // Assuming trades are sorted newest first
                if (latestTrade && latestTrade.price) {
                    updateFormingCandle({
                        price: latestTrade.price,
                        timestamp: latestTrade.timestamp || Math.floor(Date.now() / 1000),
                        amount: latestTrade.amount || 0
                    });
                }
            }
        }

        function disconnectLiveMarketWebSocket() {
            if (liveMarketWsReconnectTimer) {
                clearTimeout(liveMarketWsReconnectTimer);
                liveMarketWsReconnectTimer = null;
            }
            if (liveMarketWs) {
                liveMarketWs.close();
                liveMarketWs = null;
            }
        }

        // ==========================================
        // LIVE TEST CONTROL FUNCTIONS
        // ==========================================

        // Update UI based on live test state
        function updateLiveTestUI(state) {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const startBtn = document.getElementById('btn-start-test');
            const stopBtn = document.getElementById('btn-stop-backtest');
            const liveStats = document.getElementById('live-stats');
            const strategySelector = document.getElementById('strategy-selector');

            if (state === 'ready') {
                statusIndicator.className = 'status-indicator ready';
                statusText.textContent = 'Ready';
                startBtn.disabled = false;
                stopBtn.disabled = true;
                liveStats.classList.remove('active');
                strategySelector.disabled = false;
                // Reset Performance Metrics badge when test stops
                const metricsBadge = document.getElementById('metrics-badge');
                if (metricsBadge) metricsBadge.textContent = '14 Metrics';
            } else if (state === 'running') {
                statusIndicator.className = 'status-indicator running';
                statusText.textContent = 'Running...';
                startBtn.disabled = true;
                stopBtn.disabled = false;
                liveStats.classList.add('active');
                strategySelector.disabled = true;
            } else if (state === 'backtesting') {
                statusIndicator.className = 'status-indicator backtesting';
                statusText.textContent = 'Backtesting...';
                startBtn.disabled = true;
                stopBtn.disabled = true;
                liveStats.classList.remove('active');
                strategySelector.disabled = true;
            }
        }

        // Format duration from milliseconds
        function formatDuration(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Update live stats display
        function updateLiveStats(data) {
            // Use tradeCount from API (not trades)
            const tradeCount = data.tradeCount || 0;
            const liveTrades = document.getElementById('live-trades');
            if (liveTrades) liveTrades.textContent = tradeCount;
            // Also update pro UI
            const testTradesPro = document.getElementById('test-trades-pro');
            if (testTradesPro) testTradesPro.textContent = tradeCount;

            // Use totalPnl from API (not pnl)
            const pnl = data.totalPnl || 0;
            const pnlElement = document.getElementById('live-pnl');
            if (pnlElement) {
                pnlElement.textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
                pnlElement.className = 'live-stat-value ' + (pnl >= 0 ? 'positive' : 'negative');
            }
            // Also update pro UI
            const testPnlPro = document.getElementById('test-pnl-pro');
            if (testPnlPro) {
                testPnlPro.textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
                testPnlPro.className = pnl >= 0 ? 'stat-value positive' : 'stat-value negative';
            }

            if (liveTestStartTime) {
                const duration = Date.now() - liveTestStartTime;
                const durationStr = formatDuration(duration);
                const liveDuration = document.getElementById('live-duration');
                if (liveDuration) liveDuration.textContent = durationStr;
                // Also update pro UI
                const testDurationPro = document.getElementById('test-duration-pro');
                if (testDurationPro) testDurationPro.textContent = durationStr;
            }

            const liveStrategy = document.getElementById('live-strategy');
            if (liveStrategy) liveStrategy.textContent = currentStrategy;
        }

        // Flag to prevent double-clicking during API call
        let isStartingTest = false;

        // Start live test (uses archive replay for deterministic parity testing)
        async function startLiveTest() {
            const btn = document.getElementById('btn-start-test');
            console.log('[startLiveTest] Function called');

            // Prevent double-clicking
            if (isStartingTest || liveTestRunning) {
                console.log('[startLiveTest] Already starting or running, ignoring click');
                btn.innerHTML = '<span></span> Please wait...';
                return;
            }
            isStartingTest = true;

            btn.innerHTML = '<span>1</span> Getting strategy...';

            const strategy = document.getElementById('strategy-selector').value;
            console.log('[startLiveTest] Strategy:', strategy);
            currentStrategy = strategy;

            try {
                console.log('[startLiveTest] Updating UI to running state');
                btn.innerHTML = '<span>2</span> Updating UI...';
                updateLiveTestUI('running');
                liveTestStartTime = Date.now();

                // Use /test/start for archive replay (deterministic, enables parity with backtest)
                const url = `${CONTROL_API_URL}/test/start`;
                console.log('[startLiveTest] Fetching:', url);
                console.log('[startLiveTest] API Key:', CONTROL_API_KEY ? 'present' : 'MISSING');
                btn.innerHTML = '<span>3</span> Calling API...';

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'x-api-key': CONTROL_API_KEY },
                    body: JSON.stringify({ strategy: strategy })
                });
                console.log('[startLiveTest] Response received:', response.status, response.statusText);
                btn.innerHTML = '<span>4</span> Got response: ' + response.status;

                const result = await response.json();

                if (!response.ok) {
                    // Parse error from API response body
                    const errorMsg = result.error || result.message || `HTTP ${response.status}`;
                    throw new Error(errorMsg);
                }
                console.log('[startLiveTest] Live test started:', result);
                btn.innerHTML = '<span></span> Started!';
                btn.style.border = '3px solid lime';

                liveTestRunning = true;
                isStartingTest = false;
                startPolling();
                console.log('[startLiveTest] Polling started');

            } catch (error) {
                console.error('[startLiveTest] FAILED:', error);
                btn.innerHTML = '<span></span> Start Live Test';
                btn.style.border = '';
                isStartingTest = false;
                updateLiveTestUI('ready');

                // Show error toast to user
                showErrorToast(
                    'Failed to Start Test',
                    error.message || 'Could not connect to the Control API. Please check if the backend is running.',
                    10000
                );
            }
        }

        // Stop live test and trigger backtest (uses same archive time range for parity)
        async function stopAndBacktest() {
            try {
                updateLiveTestUI('backtesting');
                stopPolling();

                // Use /test/stop-and-backtest to ensure backtest uses SAME archive time range as test
                // This is critical for achieving 100% parity
                const response = await fetch(`${CONTROL_API_URL}/test/stop-and-backtest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'x-api-key': CONTROL_API_KEY }
                });

                if (!response.ok) {
                    throw new Error(`Stop and backtest failed: HTTP ${response.status}`);
                }

                const result = await response.json();
                console.log('Stop and backtest completed:', result);

                liveTestRunning = false;
                liveTestStartTime = null;

                // Wait a moment for backtest to complete
                await new Promise(resolve => setTimeout(resolve, 3000));

                // Switch to comparison view to show TEST vs BACKTEST
                document.getElementById('session-selector').value = 'compare';
                await handleSessionChange('compare');

                // Update UI to show comparison is ready
                updateLiveTestUI('ready');

            } catch (error) {
                console.error('Failed to stop test or run backtest:', error);
                updateLiveTestUI('ready');
                liveTestRunning = false;
                showErrorToast(
                    'Backtest Failed',
                    error.message || 'Could not stop test or run backtest. Please try again.',
                    10000
                );
            }
        }

        // Poll for live test status
        let lastMetricsRefresh = 0;
        const METRICS_REFRESH_INTERVAL = 5000; // Refresh Performance Metrics every 5 seconds

        async function pollLiveTestStatus() {
            if (!liveTestRunning) return;

            try {
                const response = await fetch(`${CONTROL_API_URL}/test/status`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const status = await response.json();

                // Update the running status text
                const statusText = document.getElementById('status-text');
                statusText.textContent = `Running: ${status.tradeCount || 0} trades`;

                // Update live stats
                updateLiveStats(status);

                // Periodically refresh Performance Metrics panel with live test data
                const now = Date.now();
                if (now - lastMetricsRefresh > METRICS_REFRESH_INTERVAL) {
                    lastMetricsRefresh = now;
                    refreshPerformanceMetricsFromLiveTest();
                }

                // Check if test is still running
                if (!status.running && liveTestRunning) {
                    // Test was stopped externally
                    liveTestRunning = false;
                    stopPolling();
                    updateLiveTestUI('ready');
                }

            } catch (error) {
                console.warn('Status poll failed:', error.message);
                // Don't stop polling on transient errors
            }
        }

        // Refresh Performance Metrics panel with current live test data
        async function refreshPerformanceMetricsFromLiveTest() {
            try {
                const response = await fetch(`${CONTROL_API_URL}/session/test`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });
                if (!response.ok) return;

                const data = await response.json();
                if (data.success && data.metrics) {
                    // Add fallback values for missing metrics
                    const metrics = data.metrics;
                    metrics.initial_balance = metrics.initial_balance ?? 1.0;
                    metrics.final_balance = metrics.final_balance ?? (metrics.initial_balance + (metrics.total_pnl / 100));
                    metrics.total_return_percent = metrics.total_return_percent ?? metrics.total_pnl;
                    metrics.max_drawdown_percent = metrics.max_drawdown_percent ?? 0;
                    metrics.sharpe_ratio = metrics.sharpe_ratio ?? 0;
                    metrics.profit_factor = metrics.profit_factor ?? (metrics.winning_trades > 0 && metrics.losing_trades > 0 ?
                        Math.abs(metrics.avg_win * metrics.winning_trades) / Math.abs(metrics.avg_loss * metrics.losing_trades) : 0);
                    metrics.max_drawdown = metrics.max_drawdown ?? 0;

                    // Update Performance Metrics panel
                    renderMetrics(metrics);

                    // Update metrics badge to show live indicator
                    const badge = document.getElementById('metrics-badge');
                    if (badge) badge.textContent = ' LIVE';

                    // Update equity curve status from live test data
                    const equityStatus = document.getElementById('equity-status');
                    if (equityStatus && data.equity_curve) {
                        equityStatus.textContent = data.equity_curve.length + ' data points';
                    }

                    // Update Trade Activity badge
                    const tradesBadge = document.getElementById('trades-badge');
                    if (tradesBadge && data.trades) {
                        const exitCount = data.trades.filter(t => t.exit_time_unix && t.exit_price).length;
                        tradesBadge.textContent = `${data.trades.length} entries / ${exitCount} exits`;
                    }

                    // Refresh equity curve chart if in strategy mode
                    if (typeof currentDashboardMode !== 'undefined' && currentDashboardMode === 'strategy') {
                        await loadEquityCurve();
                        await loadTradeOverlays();
                    }

                    // Update chart title with correct strategy name during live test
                    const chartTitle = document.getElementById('chart-title');
                    if (chartTitle && data.metadata?.bot_name) {
                        const candlePeriodLabel = currentCandlePeriod || '1m';
                        chartTitle.textContent = `BTC/USD Price (${candlePeriodLabel}) & ${data.metadata.bot_name} P&L (TEST)`;
                    }

                    console.log('[LiveTest] Refreshed - trades:', metrics.total_trades, 'P&L:', metrics.total_pnl, 'Equity points:', data.equity_curve?.length || 0);
                }
            } catch (err) {
                console.warn('[LiveTest] Failed to refresh Performance Metrics:', err.message);
            }
        }

        // Start polling for status updates
        function startPolling() {
            if (liveTestPollingInterval) {
                clearInterval(liveTestPollingInterval);
            }
            // Poll every 2 seconds
            liveTestPollingInterval = setInterval(pollLiveTestStatus, 2000);
            // Also poll immediately
            pollLiveTestStatus();
        }

        // Stop polling
        function stopPolling() {
            if (liveTestPollingInterval) {
                clearInterval(liveTestPollingInterval);
                liveTestPollingInterval = null;
            }
        }

        // Check initial test status on page load
        async function checkInitialTestStatus() {
            try {
                const response = await fetch(`${CONTROL_API_URL}/test/status`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                if (response.ok) {
                    const status = await response.json();

                    if (status.running) {
                        // Test is already running - resume polling
                        liveTestRunning = true;
                        liveTestStartTime = status.startTime ? status.startTime * 1000 : Date.now();
                        currentStrategy = status.strategy || 'Unknown';
                        document.getElementById('strategy-selector').value = currentStrategy;
                        updateLiveTestUI('running');
                        startPolling();
                    } else {
                        // No test running - enable the start button
                        updateLiveTestUI('ready');
                    }
                } else {
                    // API error - still enable buttons for manual attempt
                    updateLiveTestUI('ready');
                }
            } catch (error) {
                // API not available - still enable buttons (user will see error when they click)
                console.log('Control API not available:', error.message);
                updateLiveTestUI('ready');
            }
        }

        // ==========================================
        // END LIVE TEST CONTROL FUNCTIONS
        // ==========================================

        // ==========================================
        // WEBSOCKET - Real-time trade streaming
        // ==========================================

        let tradeWebSocket = null;
        let wsReconnectAttempts = 0;
        const WS_MAX_RECONNECT = 5;
        const WS_RECONNECT_DELAY = 3000;
        let liveTrades = [];

        // Connect to WebSocket for live trade streaming
        function connectTradeWebSocket() {
            // Use secure websocket if page is HTTPS, otherwise regular
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            // The Control API host (same as CONTROL_API_URL but with ws protocol)
            const wsHost = CONTROL_API_URL.replace(/^https?:/, wsProtocol);
            const wsUrl = `${wsHost}/trades/stream`;

            console.log('[WS] Connecting to:', wsUrl);

            try {
                tradeWebSocket = new WebSocket(wsUrl);

                tradeWebSocket.onopen = () => {
                    console.log('[WS] Connected');
                    wsReconnectAttempts = 0;
                    updateWsStatus(true);
                };

                tradeWebSocket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleWsMessage(message);
                    } catch (err) {
                        console.error('[WS] Failed to parse message:', err);
                    }
                };

                tradeWebSocket.onclose = (event) => {
                    console.log('[WS] Disconnected:', event.code, event.reason);
                    updateWsStatus(false);

                    // Attempt reconnect if not a clean close
                    if (wsReconnectAttempts < WS_MAX_RECONNECT) {
                        wsReconnectAttempts++;
                        console.log(`[WS] Reconnecting in ${WS_RECONNECT_DELAY}ms (attempt ${wsReconnectAttempts})`);
                        setTimeout(connectTradeWebSocket, WS_RECONNECT_DELAY);
                    }
                };

                tradeWebSocket.onerror = (error) => {
                    console.error('[WS] Error:', error);
                    updateWsStatus(false);
                };

            } catch (err) {
                console.error('[WS] Failed to create WebSocket:', err);
                updateWsStatus(false);
            }
        }

        // Handle incoming WebSocket messages
        function handleWsMessage(message) {
            console.log('[WS] Received:', message.type);

            switch (message.type) {
                case 'status':
                    // Server status update
                    if (message.marketRunning) {
                        showLiveTradeFeed(true);
                    }
                    break;

                case 'trades':
                    // Full trade list (sent on connect)
                    liveTrades = message.trades || [];
                    renderLiveTrades();
                    break;

                case 'new_trades':
                    // New trades to add
                    const newTrades = message.trades || [];
                    if (newTrades.length > 0) {
                        liveTrades = [...liveTrades, ...newTrades];
                        renderLiveTrades(newTrades);
                        // Update live trades count
                        document.getElementById('live-trades').textContent = liveTrades.length;
                    }
                    break;

                case 'market_started':
                    showLiveTradeFeed(true);
                    liveTrades = [];
                    renderLiveTrades();
                    break;

                case 'market_stopped':
                    // Keep feed visible but stop updates
                    break;
            }
        }

        // Update WebSocket connection status indicator
        function updateWsStatus(connected) {
            const dot = document.getElementById('ws-dot');
            const text = document.getElementById('ws-status-text');

            if (dot && text) {
                if (connected) {
                    dot.classList.add('connected');
                    text.textContent = 'Connected';
                } else {
                    dot.classList.remove('connected');
                    text.textContent = 'Disconnected';
                }
            }
        }

        // Show/hide the live trade feed
        function showLiveTradeFeed(show) {
            const feed = document.getElementById('live-trade-feed');
            if (feed) {
                if (show) {
                    feed.classList.add('active');
                } else {
                    feed.classList.remove('active');
                }
            }
        }

        // Render live trades in the feed
        function renderLiveTrades(newOnly = null) {
            const container = document.getElementById('live-trade-list');
            if (!container) return;

            // If no trades, show waiting message
            if (liveTrades.length === 0) {
                container.innerHTML = '<div class="no-trades-message">Waiting for trades...</div>';
                return;
            }

            // If rendering new trades only, prepend them
            if (newOnly && newOnly.length > 0) {
                const fragment = document.createDocumentFragment();
                newOnly.forEach(trade => {
                    const item = createTradeItem(trade);
                    fragment.appendChild(item);
                });
                // Remove "waiting" message if present
                const waiting = container.querySelector('.no-trades-message');
                if (waiting) waiting.remove();
                // Prepend new trades (most recent at top)
                container.insertBefore(fragment, container.firstChild);
            } else {
                // Full render - show most recent first
                container.innerHTML = '';
                const tradesReversed = [...liveTrades].reverse();
                tradesReversed.slice(0, 50).forEach(trade => {
                    const item = createTradeItem(trade);
                    container.appendChild(item);
                });
            }
        }

        // Create a trade item element
        function createTradeItem(trade) {
            const item = document.createElement('div');
            const side = trade.side || 'long';
            item.className = `live-trade-item ${side}`;

            const time = new Date(trade.timestamp_unix * 1000).toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            const sideLabel = side === 'long' ? ' LONG' : ' SHORT';
            const sideClass = side === 'long' ? 'long' : 'short';

            item.innerHTML = `
                <div class="live-trade-info">
                    <span class="live-trade-side ${sideClass}">${sideLabel}</span>
                    <span class="live-trade-price">$${trade.price?.toFixed(1) || '0.0'}</span>
                </div>
                <span class="live-trade-time">${time}</span>
            `;

            return item;
        }

        // Initialize WebSocket on page load
        function initWebSocket() {
            // Small delay to let the page initialize
            setTimeout(() => {
                connectTradeWebSocket();
            }, 1000);
        }

        // ==========================================
        // END WEBSOCKET
        // ==========================================

        // Load backtest data from Control API (no static fallback)
        async function loadBacktestData(botName = 'DivergeBot') {
            try {
                // Try Control API first
                console.log(`[loadBacktestData] Trying Control API for ${botName}...`);
                let data = null;
                try {
                    const apiResponse = await fetch(`${CONTROL_API_URL}/session/backtest`, {
                        headers: { 'x-api-key': CONTROL_API_KEY }
                    });
                    if (apiResponse.ok) {
                        data = await apiResponse.json();
                        if (data.success) {
                            console.log(`[loadBacktestData] Loaded ${data.trades?.length || 0} trades from Control API`);
                        } else {
                            data = null;
                        }
                    }
                } catch (apiErr) {
                    console.log(`[loadBacktestData] Control API not available: ${apiErr.message}`);
                }

                // If no data from API, return empty dataset
                if (!data) {
                    console.log(`[loadBacktestData] No data available, returning empty dataset`);
                    data = {
                        success: true,
                        metadata: {
                            bot_name: botName,
                            exchange: 'bitmex',
                            pair: 'BTC/USD',
                            session_type: 'backtest',
                            start_time: Math.floor(Date.now() / 1000) - 3600,
                            end_time: Math.floor(Date.now() / 1000)
                        },
                        metrics: {
                            total_pnl: 0,
                            win_rate: 0,
                            sharpe_ratio: 0,
                            max_drawdown: 0,
                            profit_factor: 0,
                            total_trades: 0,
                            winning_trades: 0,
                            losing_trades: 0,
                            avg_win: 0,
                            avg_loss: 0,
                            largest_win: 0,
                            largest_loss: 0,
                            avg_trade_duration: 0
                        },
                        trades: [],
                        equity_curve: [],
                        candles: []
                    };
                }

                // Add defaults for missing metrics fields
                const metrics = data.metrics;
                metrics.initial_balance = metrics.initial_balance ?? 1.0;
                metrics.final_balance = metrics.final_balance ?? (metrics.initial_balance + (metrics.total_pnl / 100));
                metrics.total_return_percent = metrics.total_return_percent ?? metrics.total_pnl;
                metrics.max_drawdown_percent = metrics.max_drawdown_percent ?? metrics.max_drawdown;

                // Add defaults for missing metadata fields (used in renderConfig)
                const metadata = data.metadata || {};
                data.metadata = metadata;
                metadata.bot_name = metadata.bot_name ?? botName;
                metadata.exchange = metadata.exchange ?? 'bitmex';
                metadata.pair = metadata.pair ?? 'BTC/USD';
                metadata.second_pair = metadata.second_pair ?? 'ETH/USD';
                metadata.trade_size = metadata.trade_size ?? 0.01;
                metadata.leverage = metadata.leverage ?? 1;
                metadata.initial_balance = metadata.initial_balance ?? 1;
                metadata.divergence_threshold = metadata.divergence_threshold ?? 0.003;
                metadata.ema_period = metadata.ema_period ?? 100;
                // Use trade timestamps for session period if not provided
                const firstTrade = data.trades?.[0];
                const lastTrade = data.trades?.[data.trades.length - 1];
                metadata.start_timestamp_unix = metadata.start_timestamp_unix ?? metadata.start_time ?? firstTrade?.timestamp_unix ?? Math.floor(Date.now() / 1000);
                metadata.end_timestamp_unix = metadata.end_timestamp_unix ?? metadata.end_time ?? lastTrade?.exit_time_unix ?? lastTrade?.timestamp_unix ?? Math.floor(Date.now() / 1000);

                // If data lacks candles or has non-1m candles, generate 1m candles from trades
                if (data.candles && data.candles.length >= 2) {
                    // Check if candles are 1-minute (60 sec apart) or larger timeframe
                    const candleInterval = data.candles[1].time - data.candles[0].time;
                    if (candleInterval > 60) {
                        console.log(`[loadBacktestData] Candles are ${candleInterval}s intervals (not 1m), generating 1m candles from trades`);
                        data.candles = generateCandlesFromTrades(data);
                    }
                } else if (!data.candles || data.candles.length === 0) {
                    console.log(`[loadBacktestData] No candles found, generating from trades`);
                    data.candles = generateCandlesFromTrades(data);
                }

                return data;
            } catch (error) {
                console.error('Failed to load backtest data:', error);
                throw error;
            }
        }

        // Load session-specific data
        async function loadSessionData(sessionType) {
            try {
                // First try to load from Control API (for fresh test/backtest data)
                const apiEndpoint = sessionType === 'test' ? '/session/test' : '/session/backtest';
                console.log(`[loadSessionData] Trying Control API: ${CONTROL_API_URL}${apiEndpoint}`);

                let data = null;
                let apiSuccess = false;
                try {
                    const apiResponse = await fetch(`${CONTROL_API_URL}${apiEndpoint}`, {
                        headers: { 'x-api-key': CONTROL_API_KEY }
                    });
                    if (apiResponse.ok) {
                        data = await apiResponse.json();
                        if (data.success) {
                            apiSuccess = true;
                            console.log(`[loadSessionData] Loaded ${data.trades?.length || 0} trades from Control API`);
                        }
                    }
                } catch (apiErr) {
                    console.log(`[loadSessionData] Control API not available: ${apiErr.message}`);
                }

                // If no data from API, return empty dataset (no static fallback)
                if (!apiSuccess) {
                    console.log(`[loadSessionData] No data available from API, returning empty dataset`);
                    data = {
                        success: true,
                        metadata: {
                            bot_name: 'Unknown',
                            exchange: 'bitmex',
                            pair: 'BTC/USD',
                            session_type: sessionType,
                            start_time: Math.floor(Date.now() / 1000) - 3600,
                            end_time: Math.floor(Date.now() / 1000)
                        },
                        metrics: {
                            total_pnl: 0,
                            win_rate: 0,
                            sharpe_ratio: 0,
                            max_drawdown: 0,
                            profit_factor: 0,
                            total_trades: 0,
                            winning_trades: 0,
                            losing_trades: 0,
                            avg_win: 0,
                            avg_loss: 0,
                            largest_win: 0,
                            largest_loss: 0,
                            avg_trade_duration: 0
                        },
                        trades: [],
                        equity_curve: [],
                        candles: []
                    };
                }

                // Add defaults for missing metrics fields
                const metrics = data.metrics;
                metrics.initial_balance = metrics.initial_balance ?? 1.0;
                metrics.final_balance = metrics.final_balance ?? (metrics.initial_balance + (metrics.total_pnl / 100));
                metrics.total_return_percent = metrics.total_return_percent ?? metrics.total_pnl;
                metrics.max_drawdown_percent = metrics.max_drawdown_percent ?? metrics.max_drawdown ?? 0;
                // Additional defaults for metrics used in rendering
                metrics.sharpe_ratio = metrics.sharpe_ratio ?? 0;
                metrics.profit_factor = metrics.profit_factor ?? (metrics.winning_trades > 0 ? 1 : 0);
                metrics.avg_win = metrics.avg_win ?? (metrics.winning_trades > 0 ? metrics.total_pnl / metrics.winning_trades : 0);
                metrics.avg_loss = metrics.avg_loss ?? 0;
                metrics.max_drawdown = metrics.max_drawdown ?? 0;

                // Add defaults for missing metadata fields (used in renderConfig)
                const metadata = data.metadata;
                metadata.divergence_threshold = metadata.divergence_threshold ?? 0.003;
                metadata.ema_period = metadata.ema_period ?? 100;
                metadata.trade_size = metadata.trade_size ?? 0.01;
                metadata.leverage = metadata.leverage ?? 1;
                metadata.second_pair = metadata.second_pair ?? 'ETH/USD';
                metadata.initial_balance = metadata.initial_balance ?? 1;
                // Use trade timestamps for session period if not provided
                // Support both start_timestamp_unix and start_time field names
                const firstTrade = data.trades?.[0];
                const lastTrade = data.trades?.[data.trades.length - 1];
                metadata.start_timestamp_unix = metadata.start_timestamp_unix ?? metadata.start_time ?? firstTrade?.timestamp_unix ?? Math.floor(Date.now() / 1000);
                metadata.end_timestamp_unix = metadata.end_timestamp_unix ?? metadata.end_time ?? lastTrade?.exit_time_unix ?? lastTrade?.timestamp_unix ?? Math.floor(Date.now() / 1000);

                // Ensure equity_curve exists
                data.equity_curve = data.equity_curve || [];
                // Ensure trades array exists
                data.trades = data.trades || [];

                // If session data lacks candles or has non-1m candles, generate 1m candles from trades
                if (data.candles && data.candles.length >= 2) {
                    const candleInterval = data.candles[1].time - data.candles[0].time;
                    if (candleInterval > 60) {
                        console.log(`[loadSessionData] Candles are ${candleInterval}s intervals, generating 1m candles from ${data.trades?.length || 0} trades`);
                        data.candles = generateCandlesFromTrades(data);
                    }
                } else if (!data.candles || data.candles.length === 0) {
                    console.log(`[loadSessionData] No candles found, generating from ${data.trades?.length || 0} trades`);
                    data.candles = generateCandlesFromTrades(data);
                }
                console.log(`[loadSessionData] Final candle count: ${data.candles?.length || 0}`);

                return data;
            } catch (error) {
                console.error(`Failed to load ${sessionType} session data:`, error);
                throw error;
            }
        }

        // Load both sessions for comparison
        async function loadBothSessions() {
            const [testData, backtestData] = await Promise.all([
                loadSessionData('test'),
                loadSessionData('backtest')
            ]);
            return { testData, backtestData };
        }

        // Compare two metric values with tolerance
        function metricsMatch(val1, val2, tolerance = 0.01) {
            if (typeof val1 === 'number' && typeof val2 === 'number') {
                if (val1 === 0 && val2 === 0) return true;
                const diff = Math.abs(val1 - val2);
                const maxVal = Math.max(Math.abs(val1), Math.abs(val2), 1);
                return (diff / maxVal) <= tolerance;
            }
            return val1 === val2;
        }

        // Format trade time for display
        function formatTradeTime(timestamp) {
            return new Date(timestamp * 1000).toLocaleString('en-US', {
                month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
        }

        // Render a single trade log item
        function renderTradeLogItem(trade, divergenceType = null) {
            const entryTime = formatTradeTime(trade.timestamp_unix);
            const sideClass = trade.side === 'long' ? 'side-long' : 'side-short';
            const sideIcon = trade.side === 'long' ? '' : '';
            const sideLabel = trade.side === 'long' ? 'Long' : 'Short';

            let exitHtml = '';
            if (trade.exit_time_unix && trade.exit_price) {
                const exitTime = formatTradeTime(trade.exit_time_unix);
                const pnlClass = (trade.pnl ?? 0) >= 0 ? 'pnl-positive' : 'pnl-negative';
                const pnlSign = (trade.pnl ?? 0) >= 0 ? '+' : '';
                exitHtml = `
                    <div class="trade-log-action">
                        <span class="exit"> Exit @ $${(trade.exit_price ?? 0).toFixed(1)}</span>
                        <span class="${pnlClass}">${pnlSign}$${(trade.pnl ?? 0).toFixed(2)}</span>
                    </div>
                    <div class="trade-log-time">${exitTime}</div>
                `;
            }

            const divergenceClass = divergenceType === 'divergent' ? 'divergent' :
                                    divergenceType === 'matching' ? 'matching' : '';

            return `
                <div class="trade-log-item ${divergenceClass}" data-divergence="${divergenceType || 'none'}">
                    <div class="trade-log-time">${entryTime}</div>
                    <div class="trade-log-action">
                        <span class="${sideClass}">${sideIcon} ${sideLabel} Entry</span>
                        <span>@ $${(trade.price ?? 0).toFixed(1)}</span>
                        <span style="color: #8892b0;">qty: ${trade.quantity ?? 0}</span>
                    </div>
                    ${exitHtml}
                </div>
            `;
        }

        // Compare trades between test and backtest to find divergences
        function findTradeDivergences(testTrades, backtestTrades) {
            const tolerance = 60; // 60 seconds tolerance for matching trades
            const priceTolerance = 0.001; // 0.1% price tolerance

            const testWithStatus = testTrades.map(t => ({ ...t, matched: false, divergenceType: 'divergent' }));
            const backtestWithStatus = backtestTrades.map(t => ({ ...t, matched: false, divergenceType: 'divergent' }));

            // Try to match trades
            testWithStatus.forEach(testTrade => {
                const matchingBacktest = backtestWithStatus.find(btTrade => {
                    if (btTrade.matched) return false;

                    const timeDiff = Math.abs(testTrade.timestamp_unix - btTrade.timestamp_unix);
                    const sideMatch = testTrade.side === btTrade.side;
                    const priceMatch = Math.abs(testTrade.price - btTrade.price) / testTrade.price < priceTolerance;

                    return timeDiff <= tolerance && sideMatch && priceMatch;
                });

                if (matchingBacktest) {
                    testTrade.matched = true;
                    testTrade.divergenceType = 'matching';
                    matchingBacktest.matched = true;
                    matchingBacktest.divergenceType = 'matching';
                }
            });

            return {
                testTrades: testWithStatus,
                backtestTrades: backtestWithStatus,
                divergenceCount: testWithStatus.filter(t => !t.matched).length +
                                 backtestWithStatus.filter(t => !t.matched).length
            };
        }

        // Render side-by-side trade logs comparison
        function renderTradeLogsComparison(testData, backtestData) {
            const testTrades = testData.trades || [];
            const backtestTrades = backtestData.trades || [];

            // Find divergences
            const { testTrades: testWithStatus, backtestTrades: backtestWithStatus, divergenceCount } =
                findTradeDivergences(testTrades, backtestTrades);

            // Update counts
            document.getElementById('test-trades-count').textContent = `${testTrades.length} trades`;
            document.getElementById('backtest-trades-count').textContent = `${backtestTrades.length} trades`;

            // Update divergence indicator
            const divergenceIndicator = document.getElementById('divergence-count');
            if (divergenceCount > 0) {
                divergenceIndicator.textContent = `${divergenceCount} divergence${divergenceCount > 1 ? 's' : ''}`;
                divergenceIndicator.style.display = 'inline-flex';
            } else {
                divergenceIndicator.style.display = 'none';
            }

            // Render test trades
            const testLogEl = document.getElementById('test-trades-log');
            if (testWithStatus.length === 0) {
                testLogEl.innerHTML = '<div class="no-trades-msg">No trades in test session</div>';
            } else {
                testLogEl.innerHTML = testWithStatus.map(t => renderTradeLogItem(t, t.divergenceType)).join('');
            }

            // Render backtest trades
            const backtestLogEl = document.getElementById('backtest-trades-log');
            if (backtestWithStatus.length === 0) {
                backtestLogEl.innerHTML = '<div class="no-trades-msg">No trades in backtest session</div>';
            } else {
                backtestLogEl.innerHTML = backtestWithStatus.map(t => renderTradeLogItem(t, t.divergenceType)).join('');
            }

            // Setup filter buttons
            setupTradeLogFilters();
        }

        // Setup filter button handlers for trade logs
        function setupTradeLogFilters() {
            const filterBtns = document.querySelectorAll('.trade-logs-filters .filter-btn');
            filterBtns.forEach(btn => {
                btn.onclick = () => {
                    // Update active state
                    filterBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    const filter = btn.dataset.filter;

                    // Filter both columns
                    document.querySelectorAll('.trade-log-item').forEach(item => {
                        const divergence = item.dataset.divergence;
                        if (filter === 'all') {
                            item.style.display = '';
                        } else if (filter === 'divergent') {
                            item.style.display = divergence === 'divergent' ? '' : 'none';
                        } else if (filter === 'matching') {
                            item.style.display = divergence === 'matching' ? '' : 'none';
                        }
                    });
                };
            });
        }

        // Render comparison view
        function renderComparisonView(testData, backtestData) {
            const testMetrics = testData.metrics;
            const backtestMetrics = backtestData.metrics;

            const metricsToCompare = [
                { key: 'total_trades', label: 'Total Trades', format: v => v },
                { key: 'winning_trades', label: 'Winning Trades', format: v => v },
                { key: 'losing_trades', label: 'Losing Trades', format: v => v },
                { key: 'total_pnl', label: 'Total P&L', format: v => formatPnL(v) },
                { key: 'win_rate', label: 'Win Rate', format: v => formatPercent(v) },
                { key: 'final_balance', label: 'Final Balance', format: v => (v ?? 0).toFixed(4) + ' BTC' }
            ];

            let matchCount = 0;
            let totalCount = metricsToCompare.length;

            // Render test metrics
            const testMetricsHtml = metricsToCompare.map(m => {
                const testVal = testMetrics[m.key];
                const backtestVal = backtestMetrics[m.key];
                const isMatch = metricsMatch(testVal, backtestVal);
                if (isMatch) matchCount++;

                return `
                    <div class="comparison-metric">
                        <span class="label">${m.label}</span>
                        <span class="value ${isMatch ? 'match' : 'mismatch'}">${m.format(testVal)}</span>
                    </div>
                `;
            }).join('');

            // Render backtest metrics
            const backtestMetricsHtml = metricsToCompare.map(m => {
                const testVal = testMetrics[m.key];
                const backtestVal = backtestMetrics[m.key];
                const isMatch = metricsMatch(testVal, backtestVal);

                return `
                    <div class="comparison-metric">
                        <span class="label">${m.label}</span>
                        <span class="value ${isMatch ? 'match' : 'mismatch'}">
                            ${m.format(backtestVal)}
                            <span class="match-indicator ${isMatch ? 'match' : 'mismatch'}">
                                ${isMatch ? ' Match' : ' Differs'}
                            </span>
                        </span>
                    </div>
                `;
            }).join('');

            document.getElementById('test-metrics').innerHTML = testMetricsHtml;
            document.getElementById('backtest-metrics').innerHTML = backtestMetricsHtml;

            // Update summary
            const parityPercent = Math.round((matchCount / totalCount) * 100);
            document.getElementById('matching-count').textContent = matchCount;
            document.getElementById('matching-count').className = 'number ' + (matchCount > 0 ? 'positive' : 'negative');
            document.getElementById('different-count').textContent = totalCount - matchCount;
            document.getElementById('different-count').className = 'number ' + (totalCount - matchCount > 0 ? 'negative' : 'positive');
            document.getElementById('parity-percent').textContent = parityPercent + '%';
            document.getElementById('parity-percent').className = 'number ' + (parityPercent >= 80 ? 'positive' : 'negative');

            // Update parity badge
            const parityStatus = document.getElementById('parity-status');
            if (parityPercent === 100) {
                parityStatus.textContent = ' PARITY ACHIEVED';
                parityStatus.className = 'parity-badge match';
            } else if (parityPercent >= 80) {
                parityStatus.textContent = '~ PARTIAL MATCH';
                parityStatus.className = 'parity-badge match';
            } else {
                parityStatus.textContent = ' MISMATCH';
                parityStatus.className = 'parity-badge mismatch';
            }

            // Render side-by-side trade logs comparison
            renderTradeLogsComparison(testData, backtestData);
        }

        // Handle session change
        async function handleSessionChange(session) {
            console.log(`[handleSessionChange] Called with session: ${session}`);
            currentSession = session;
            const loadingEl = document.getElementById('loading-state');
            const contentEl = document.getElementById('dashboard-content');
            const comparisonEl = document.getElementById('comparison-container');

            try {
                console.log(`[handleSessionChange] Starting to load session: ${session}`);
                loadingEl.style.display = 'block';
                loadingEl.innerHTML = '<div class="loading">Loading session data...</div>';
                contentEl.style.display = 'none';
                comparisonEl.classList.remove('active');

                if (session === 'compare') {
                    // Load both and show comparison view
                    const { testData, backtestData } = await loadBothSessions();
                    testSessionData = testData;
                    backtestSessionData = backtestData;

                    loadingEl.style.display = 'none';
                    comparisonEl.classList.add('active');
                    contentEl.style.display = 'none';

                    renderComparisonView(testData, backtestData);

                    document.getElementById('timestamp').textContent =
                        `Last updated: ${new Date().toLocaleString()} | Comparing TEST vs BACKTEST sessions`;
                } else {
                    // Load single session and show normal dashboard
                    const data = await loadSessionData(session);
                    currentData = filterDataByPeriod(data, currentPeriod);

                    loadingEl.style.display = 'none';
                    contentEl.style.display = 'block';
                    comparisonEl.classList.remove('active');

                    // Update status indicators
                    document.getElementById('json-status').textContent = 'Loaded successfully';
                    document.getElementById('metrics-status').textContent = '14 metrics calculated';
                    document.getElementById('equity-status').textContent = currentData.equity_curve.length + ' data points';

                    // Render all components
                    renderMetrics(currentData.metrics);
                    renderConfig(currentData.metadata);
                    renderCharts(currentData);
                    renderTrades(currentData.trades);

                    // Update titles and badges
                    const sessionLabel = session === 'test' ? 'TEST' : 'BACKTEST';
                    const candlePeriodLabel = currentCandlePeriod === '1m' ? '1m' : currentCandlePeriod;
                    document.getElementById('chart-title').textContent =
                        `${currentData.metadata.pair} Price (${candlePeriodLabel}) & ${currentData.metadata.bot_name} P&L (${sessionLabel})`;
                    document.getElementById('bot-name-title').textContent =
                        `${currentData.metadata.bot_name} Configuration`;
                    document.getElementById('bot-badge').textContent = sessionLabel;
                    const exitCount = currentData.trades.filter(t => t.exit_time_unix && t.exit_price).length;
                    document.getElementById('trades-badge').textContent = `${currentData.trades.length} entries / ${exitCount} exits`;

                    document.getElementById('timestamp').textContent =
                        `Last updated: ${new Date().toLocaleString()} | ${sessionLabel} Session - ${currentData.metadata.bot_name}`;

                    animateCards();
                }
            } catch (error) {
                loadingEl.innerHTML = `
                    <div class="error-message">
                        <h3>Failed to load session data</h3>
                        <p>${error.message}</p>
                        <p style="margin-top: 10px; font-size: 0.9rem;">
                            Make sure test_session.json and backtest_session.json exist.
                        </p>
                    </div>
                `;
                loadingEl.style.display = 'block';
                contentEl.style.display = 'none';
                comparisonEl.classList.remove('active');
            }
        }

        // Filter data by date range
        function filterDataByPeriod(data, period) {
            if (period === 'all' || !data.trades || data.trades.length === 0) {
                return data;
            }

            const timestamps = data.trades.map(t => t.timestamp_unix);
            const minTime = Math.min(...timestamps);
            const maxTime = Math.max(...timestamps);
            const dayLength = 86400; // seconds in a day

            let startTime, endTime;
            switch (period) {
                case 'day1':
                    startTime = minTime;
                    endTime = minTime + dayLength;
                    break;
                case 'day2':
                    startTime = minTime + dayLength;
                    endTime = minTime + dayLength * 2;
                    break;
                case 'recent':
                    startTime = maxTime - dayLength;
                    endTime = maxTime + 1;
                    break;
                default:
                    return data;
            }

            // Filter trades
            const filteredTrades = data.trades.filter(t =>
                t.timestamp_unix >= startTime && t.timestamp_unix < endTime
            );

            // Filter candles
            const filteredCandles = data.candles ? data.candles.filter(c =>
                c.time >= startTime && c.time < endTime
            ) : [];

            // Filter equity curve
            const filteredEquity = data.equity_curve ? data.equity_curve.filter(e =>
                e.timestamp_unix >= startTime && e.timestamp_unix < endTime
            ) : [];

            // Recalculate metrics for filtered data
            const recalculatedMetrics = recalculateMetrics(filteredTrades, data.metrics);

            return {
                ...data,
                trades: filteredTrades,
                candles: filteredCandles,
                equity_curve: filteredEquity,
                metrics: recalculatedMetrics
            };
        }

        // Recalculate metrics for filtered trades
        function recalculateMetrics(trades, originalMetrics) {
            if (trades.length === 0) {
                return {
                    ...originalMetrics,
                    total_trades: 0,
                    winning_trades: 0,
                    losing_trades: 0,
                    total_pnl: 0,
                    win_rate: 0
                };
            }

            const winningTrades = trades.filter(t => t.pnl > 0);
            const losingTrades = trades.filter(t => t.pnl <= 0);
            const totalPnl = trades.reduce((sum, t) => sum + t.pnl, 0);

            return {
                ...originalMetrics,
                total_trades: trades.length,
                winning_trades: winningTrades.length,
                losing_trades: losingTrades.length,
                total_pnl: totalPnl,
                win_rate: (winningTrades.length / trades.length) * 100,
                avg_win: winningTrades.length > 0
                    ? winningTrades.reduce((s, t) => s + t.pnl, 0) / winningTrades.length
                    : 0,
                avg_loss: losingTrades.length > 0
                    ? losingTrades.reduce((s, t) => s + t.pnl, 0) / losingTrades.length
                    : 0
            };
        }

        // Format number with sign
        function formatPnL(value, decimals = 2) {
            const v = value ?? 0;
            const sign = v >= 0 ? '+' : '';
            return sign + '$' + v.toFixed(decimals);
        }

        // Format percentage
        function formatPercent(value, decimals = 2) {
            return (value ?? 0).toFixed(decimals) + '%';
        }

        // Export trades to CSV (with entry/exit breakdown)
        function exportToCSV(data) {
            if (!data || !data.trades || data.trades.length === 0) {
                alert('No trade data to export');
                return;
            }

            const headers = ['Timestamp', 'Type', 'Side', 'Price', 'Quantity', 'PnL', 'Cumulative PnL'];
            const rows = [];

            data.trades.forEach(t => {
                // Entry row
                rows.push([
                    t.timestamp,
                    'Entry',
                    t.side,
                    t.price,
                    t.quantity,
                    '',
                    ''
                ]);

                // Exit row (if exists)
                if (t.exit_time_unix && t.exit_price) {
                    const exitTimestamp = new Date(t.exit_time_unix * 1000).toISOString().replace('T', ' ').replace('Z', '');
                    rows.push([
                        exitTimestamp,
                        'Exit',
                        t.side,
                        t.exit_price,
                        t.quantity,
                        t.pnl,
                        t.cumulative_pnl
                    ]);
                }
            });

            const csvContent = [
                headers.join(','),
                ...rows.map(row => row.join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${currentBot}_backtest_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
        }

        // Export chart as image
        function exportChartAsImage() {
            const chartContainer = document.getElementById('chart-container');
            const canvas = chartContainer.querySelector('canvas');

            if (!canvas) {
                alert('Chart not ready for export');
                return;
            }

            // Create a temporary canvas with background
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const ctx = tempCanvas.getContext('2d');

            // Fill background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Draw the chart
            ctx.drawImage(canvas, 0, 0);

            // Download
            const link = document.createElement('a');
            link.download = `${currentBot}_chart_${new Date().toISOString().split('T')[0]}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }

        // Initialize dashboard
        async function initDashboard(botName = 'DivergeBot', period = 'all') {
            const loadingEl = document.getElementById('loading-state');
            const contentEl = document.getElementById('dashboard-content');

            try {
                if (loadingEl) {
                    loadingEl.style.display = 'block';
                    loadingEl.innerHTML = '<div class="loading">Loading backtest data...</div>';
                }
                if (contentEl) contentEl.style.display = 'none';

                let data = await loadBacktestData(botName);
                data = filterDataByPeriod(data, period);
                currentData = data;

                // Hide loading, show content
                if (loadingEl) loadingEl.style.display = 'none';
                if (contentEl) contentEl.style.display = 'block';

                // Update status indicators (with null checks)
                const jsonStatus = document.getElementById('json-status');
                const metricsStatus = document.getElementById('metrics-status');
                const equityStatus = document.getElementById('equity-status');
                if (jsonStatus) jsonStatus.textContent = 'Loaded successfully';
                if (metricsStatus) metricsStatus.textContent = '14 metrics calculated';
                if (equityStatus) equityStatus.textContent = data.equity_curve.length + ' data points';

                // Render all components
                renderMetrics(data.metrics);
                renderConfig(data.metadata);
                renderCharts(data);
                renderTrades(data.trades);

                // Update titles and badges (with null checks)
                const candlePeriodLabel = currentCandlePeriod === '1m' ? '1m' : currentCandlePeriod;
                const chartTitle = document.getElementById('chart-title');
                const botNameTitle = document.getElementById('bot-name-title');
                const botBadge = document.getElementById('bot-badge');
                const tradesBadge = document.getElementById('trades-badge');
                const timestamp = document.getElementById('timestamp');

                if (chartTitle) chartTitle.textContent =
                    `${data.metadata.pair} Price (${candlePeriodLabel}) & ${data.metadata.bot_name} P&L`;
                if (botNameTitle) botNameTitle.textContent =
                    `${data.metadata.bot_name} Configuration`;
                if (botBadge) botBadge.textContent = data.metadata.exchange.toUpperCase();
                const exitCount = data.trades.filter(t => t.exit_time_unix && t.exit_price).length;
                if (tradesBadge) tradesBadge.textContent = `${data.trades.length} entries / ${exitCount} exits`;
                if (timestamp) timestamp.textContent =
                    `Last updated: ${new Date().toLocaleString()} | Data: ${data.metadata.bot_name} on ${data.metadata.exchange} ${data.metadata.pair}`;

                // Update active bot card
                updateActiveBotCard(botName);

                // Animate cards
                animateCards();

            } catch (error) {
                if (loadingEl) {
                    loadingEl.innerHTML = `
                        <div class="error-message">
                            <h3>Failed to load backtest data</h3>
                            <p>${error.message}</p>
                            <p style="margin-top: 10px; font-size: 0.9rem;">
                                Make sure backtest_results.json exists and the page is served via HTTP server.
                            </p>
                        </div>
                    `;
                    loadingEl.style.display = 'block';
                }
                if (contentEl) contentEl.style.display = 'none';
            }
        }

        // Update active bot card styling
        function updateActiveBotCard(botName) {
            document.querySelectorAll('.bot-card').forEach(card => {
                card.classList.remove('active');
                if (card.dataset.bot === botName) {
                    card.classList.add('active');
                }
            });
        }

        // Render all 14 metrics
        function renderMetrics(metrics) {
            const grid = document.getElementById('metrics-grid');
            if (!grid) return; // Element not in DOM

            const metricsList = [
                { label: 'Total P&L', value: formatPnL(metrics.total_pnl), positive: metrics.total_pnl >= 0 },
                { label: 'Total Return', value: formatPercent(metrics.total_return_percent), positive: metrics.total_return_percent >= 0 },
                { label: 'Win Rate', value: formatPercent(metrics.win_rate), positive: metrics.win_rate >= 50 },
                { label: 'Sharpe Ratio', value: (metrics.sharpe_ratio ?? 0).toFixed(2), positive: (metrics.sharpe_ratio ?? 0) >= 1 },
                { label: 'Max Drawdown', value: '$' + (metrics.max_drawdown ?? 0).toFixed(2), positive: false },
                { label: 'Max DD %', value: formatPercent(metrics.max_drawdown_percent), positive: false },
                { label: 'Total Trades', value: metrics.total_trades ?? 0, positive: true },
                { label: 'Winning Trades', value: metrics.winning_trades ?? 0, positive: true },
                { label: 'Losing Trades', value: metrics.losing_trades ?? 0, positive: false },
                { label: 'Avg Win', value: formatPnL(metrics.avg_win), positive: true },
                { label: 'Avg Loss', value: formatPnL(metrics.avg_loss), positive: false },
                { label: 'Profit Factor', value: (metrics.profit_factor ?? 0).toFixed(2), positive: (metrics.profit_factor ?? 0) >= 1.5 },
                { label: 'Initial Balance', value: (metrics.initial_balance ?? 0).toFixed(4) + ' BTC', positive: true },
                { label: 'Final Balance', value: (metrics.final_balance ?? 0).toFixed(4) + ' BTC', positive: (metrics.final_balance ?? 0) >= (metrics.initial_balance ?? 0) }
            ];

            grid.innerHTML = metricsList.map(m => `
                <div class="stat stat-sm">
                    <div class="stat-label stat-label-sm">${m.label}</div>
                    <div class="stat-value stat-value-sm ${m.positive ? 'positive' : 'negative'}">${m.value}</div>
                </div>
            `).join('');
        }

        // Render bot configuration
        function renderConfig(metadata) {
            const section = document.getElementById('config-section');
            if (!section) return; // Element not in DOM

            const startDate = new Date(metadata.start_timestamp_unix * 1000).toLocaleDateString('en-US', {
                year: 'numeric', month: 'short', day: 'numeric'
            });
            const endDate = new Date(metadata.end_timestamp_unix * 1000).toLocaleDateString('en-US', {
                year: 'numeric', month: 'short', day: 'numeric'
            });

            section.innerHTML = `
                <div style="margin-bottom: 15px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <div class="stat-label">Backtest Period</div>
                    <div style="color: #fff; margin-top: 5px;">${startDate} - ${endDate}</div>
                </div>
                <div class="config-grid">
                    <div class="config-item">
                        <div class="config-label">Exchange</div>
                        <div class="config-value">${metadata.exchange.toUpperCase()}</div>
                    </div>
                    <div class="config-item">
                        <div class="config-label">Trading Pair</div>
                        <div class="config-value">${metadata.pair}</div>
                    </div>
                    ${metadata.second_pair ? `
                    <div class="config-item">
                        <div class="config-label">Second Pair</div>
                        <div class="config-value">${metadata.second_pair}</div>
                    </div>
                    ` : ''}
                    <div class="config-item">
                        <div class="config-label">Trade Size</div>
                        <div class="config-value">${metadata.trade_size} BTC</div>
                    </div>
                    <div class="config-item">
                        <div class="config-label">Leverage</div>
                        <div class="config-value">${metadata.leverage}x</div>
                    </div>
                    <div class="config-item">
                        <div class="config-label">Initial Balance</div>
                        <div class="config-value">${metadata.initial_balance} BTC</div>
                    </div>
                    ${metadata.ema_period ? `
                    <div class="config-item">
                        <div class="config-label">EMA Period</div>
                        <div class="config-value">${metadata.ema_period}</div>
                    </div>
                    ` : ''}
                    ${metadata.divergence_threshold ? `
                    <div class="config-item">
                        <div class="config-label">Divergence</div>
                        <div class="config-value">${(metadata.divergence_threshold * 100).toFixed(2)}%</div>
                    </div>
                    ` : ''}
                </div>
            `;
        }

        // Generate 1-minute candles from trade data (when session lacks candle data)
        function generateCandlesFromTrades(data) {
            if (!data.trades || data.trades.length === 0) return [];

            // Collect all price points with timestamps
            const pricePoints = [];
            data.trades.forEach(trade => {
                pricePoints.push({ time: trade.timestamp_unix, price: trade.price });
                if (trade.exit_time_unix && trade.exit_price) {
                    pricePoints.push({ time: trade.exit_time_unix, price: trade.exit_price });
                }
            });

            // Add equity curve points if available
            if (data.equity_curve && data.equity_curve.length > 0) {
                // Use first trade price as reference
                const refPrice = pricePoints.length > 0 ? pricePoints[0].price : 0;
                // Note: equity curve doesn't have price, just use trade prices
            }

            if (pricePoints.length === 0) return [];

            // Sort by time
            pricePoints.sort((a, b) => a.time - b.time);

            // Find time range
            const minTime = pricePoints[0].time;
            const maxTime = pricePoints[pricePoints.length - 1].time;

            // Group into 1-minute buckets
            const candles = [];
            const bucketSize = 60; // 1 minute in seconds

            // Round start time down to minute boundary
            let currentBucket = Math.floor(minTime / bucketSize) * bucketSize;
            const endBucket = Math.floor(maxTime / bucketSize) * bucketSize;

            let lastPrice = pricePoints[0].price;
            let priceIdx = 0;

            while (currentBucket <= endBucket) {
                const bucketEnd = currentBucket + bucketSize;

                // Find all prices in this bucket
                const bucketPrices = [];
                while (priceIdx < pricePoints.length && pricePoints[priceIdx].time < bucketEnd) {
                    bucketPrices.push(pricePoints[priceIdx].price);
                    priceIdx++;
                }

                if (bucketPrices.length > 0) {
                    candles.push({
                        time: currentBucket,
                        open: lastPrice,
                        high: Math.max(lastPrice, ...bucketPrices),
                        low: Math.min(lastPrice, ...bucketPrices),
                        close: bucketPrices[bucketPrices.length - 1]
                    });
                    lastPrice = bucketPrices[bucketPrices.length - 1];
                } else {
                    // No trades in this minute - create flat candle
                    candles.push({
                        time: currentBucket,
                        open: lastPrice,
                        high: lastPrice,
                        low: lastPrice,
                        close: lastPrice
                    });
                }

                currentBucket += bucketSize;
            }

            console.log(`Generated ${candles.length} 1m candles from ${pricePoints.length} price points`);
            return candles;
        }

        // Aggregate 1m candles into larger timeframes
        function aggregateCandles(candles, period) {
            console.log(`[aggregateCandles] Input: ${candles?.length || 0} candles, period: ${period}`);
            if (!candles || candles.length === 0) return [];
            if (period === '1m') {
                console.log(`[aggregateCandles] Returning ${candles.length} raw 1m candles`);
                return candles;
            }

            // Period in seconds
            const periodSeconds = {
                '1m': 60,
                '5m': 300,
                '15m': 900,
                '1h': 3600,
                '1d': 86400
            };

            const periodSecs = periodSeconds[period] || 60;

            // Group candles by period
            const groups = {};
            candles.forEach(candle => {
                // Floor timestamp to period boundary
                const periodStart = Math.floor(candle.time / periodSecs) * periodSecs;

                if (!groups[periodStart]) {
                    groups[periodStart] = [];
                }
                groups[periodStart].push(candle);
            });

            // Aggregate each group into a single candle
            const aggregated = Object.keys(groups)
                .map(key => parseInt(key))
                .sort((a, b) => a - b)
                .map(periodStart => {
                    const group = groups[periodStart];
                    // Sort by time to ensure correct order
                    group.sort((a, b) => a.time - b.time);

                    const open = group[0].open;
                    const close = group[group.length - 1].close;
                    const high = Math.max(...group.map(c => c.high));
                    const low = Math.min(...group.map(c => c.low));
                    const volume = group.reduce((sum, c) => sum + (c.volume || 0), 0);

                    return {
                        time: periodStart,
                        open: open,
                        high: high,
                        low: low,
                        close: close,
                        volume: volume
                    };
                });

            console.log(`[aggregateCandles] Output: ${aggregated.length} candles after ${period} aggregation`);
            return aggregated;
        }

        // Render TradingView charts
        function renderCharts(data) {
            // Clear existing charts
            const chartContainer = document.getElementById('chart-container');
            const equityContainer = document.getElementById('equity-chart-container');
            chartContainer.innerHTML = '';
            equityContainer.innerHTML = '';

            // Get container dimensions
            const containerWidth = chartContainer.offsetWidth || chartContainer.clientWidth || 800;
            const containerHeight = chartContainer.offsetHeight || 400;

            mainChart = LightweightCharts.createChart(chartContainer, {
                width: containerWidth,
                height: containerHeight,
                layout: {
                    background: { type: 'solid', color: 'transparent' },
                    textColor: '#8892b0',
                },
                grid: {
                    vertLines: { color: 'rgba(255,255,255,0.05)' },
                    horzLines: { color: 'rgba(255,255,255,0.05)' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: 'rgba(255,255,255,0.1)',
                    autoScale: true,
                },
                timeScale: {
                    borderColor: 'rgba(255,255,255,0.1)',
                    timeVisible: true,
                    fixLeftEdge: false,
                    fixRightEdge: false,
                },
                handleScroll: {
                    mouseWheel: true,
                    pressedMouseMove: true,
                    horzTouchDrag: true,
                    vertTouchDrag: true,
                },
                handleScale: {
                    axisPressedMouseMove: true,
                    mouseWheel: true,
                    pinch: true,
                },
            });

            // Store raw candles for aggregation
            if (data.candles && data.candles.length > 0) {
                rawCandles = data.candles;
            }

            // Add candlestick series with aggregated candles
            if (data.candles && data.candles.length > 0) {
                const candleSeries = mainChart.addCandlestickSeries({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderDownColor: '#ef5350',
                    borderUpColor: '#26a69a',
                    wickDownColor: '#ef5350',
                    wickUpColor: '#26a69a',
                });

                // Apply aggregation based on current period
                const displayCandles = aggregateCandles(data.candles, currentCandlePeriod);
                candleSeries.setData(displayCandles);

                // Add trade markers - both entry AND exit markers
                if (data.trades && data.trades.length > 0) {
                    const markers = [];

                    // Helper to find closest candle to a timestamp
                    const findClosestCandle = (timestamp) => {
                        return data.candles.reduce((prev, curr) => {
                            return Math.abs(curr.time - timestamp) < Math.abs(prev.time - timestamp) ? curr : prev;
                        });
                    };

                    data.trades.forEach(trade => {
                        // ENTRY marker - arrow shape
                        const entryCandle = findClosestCandle(trade.timestamp_unix);
                        markers.push({
                            time: entryCandle.time,
                            position: trade.side === 'long' ? 'belowBar' : 'aboveBar',
                            color: trade.side === 'long' ? '#2196F3' : '#FF9800', // Blue for long entry, orange for short entry
                            shape: trade.side === 'long' ? 'arrowUp' : 'arrowDown',
                            text: '', // No text to prevent overlap on clustered trades
                        });

                        // EXIT marker - circle shape (if exit data exists)
                        if (trade.exit_time_unix && trade.exit_price) {
                            const exitCandle = findClosestCandle(trade.exit_time_unix);
                            markers.push({
                                time: exitCandle.time,
                                position: trade.side === 'long' ? 'aboveBar' : 'belowBar', // Opposite of entry
                                color: trade.pnl >= 0 ? '#00c853' : '#ff5252', // Green for profit, red for loss
                                shape: 'circle',
                                text: '', // No text to prevent overlap
                            });
                        }
                    });

                    // Sort markers by time (required by Lightweight Charts)
                    markers.sort((a, b) => a.time - b.time);
                    candleSeries.setMarkers(markers);
                }
            }

            mainChart.timeScale().fitContent();
            // Ensure price scale auto-fits the data range
            mainChart.priceScale('right').applyOptions({ autoScale: true });

            // Equity curve chart
            const equityWidth = equityContainer.offsetWidth || equityContainer.clientWidth || 800;
            const equityHeight = equityContainer.offsetHeight || 250;

            equityChart = LightweightCharts.createChart(equityContainer, {
                width: equityWidth,
                height: equityHeight,
                layout: {
                    background: { type: 'solid', color: 'transparent' },
                    textColor: '#8892b0',
                },
                grid: {
                    vertLines: { color: 'rgba(255,255,255,0.05)' },
                    horzLines: { color: 'rgba(255,255,255,0.05)' },
                },
                rightPriceScale: {
                    borderColor: 'rgba(255,255,255,0.1)',
                },
                timeScale: {
                    borderColor: 'rgba(255,255,255,0.1)',
                    timeVisible: true,
                },
                handleScroll: {
                    mouseWheel: true,
                    pressedMouseMove: true,
                    horzTouchDrag: true,
                    vertTouchDrag: true,
                },
                handleScale: {
                    axisPressedMouseMove: true,
                    mouseWheel: true,
                    pinch: true,
                },
            });

            // Equity line
            const equitySeries = equityChart.addLineSeries({
                color: '#00d4ff',
                lineWidth: 2,
            });

            const equityData = data.equity_curve.map(p => ({
                time: Math.floor(p.timestamp_unix),
                value: p.equity
            }));

            if (equityData.length > 0) {
                equitySeries.setData(equityData);
            }

            // Drawdown area
            const drawdownSeries = equityChart.addAreaSeries({
                topColor: 'rgba(255,82,82,0.4)',
                bottomColor: 'rgba(255,82,82,0.0)',
                lineColor: '#ff5252',
                lineWidth: 1,
                priceScaleId: 'drawdown',
            });

            const drawdownData = data.equity_curve.map(p => ({
                time: Math.floor(p.timestamp_unix),
                value: -p.drawdown
            }));

            if (drawdownData.length > 0) {
                drawdownSeries.setData(drawdownData);
            }

            equityChart.priceScale('drawdown').applyOptions({
                scaleMargins: { top: 0.8, bottom: 0 },
            });

            equityChart.timeScale().fitContent();

            // Handle resize
            const handleResize = () => {
                const chartWidth = chartContainer.offsetWidth || chartContainer.clientWidth;
                const eqWidth = equityContainer.offsetWidth || equityContainer.clientWidth;
                if (chartWidth > 0 && mainChart) {
                    mainChart.applyOptions({ width: chartWidth });
                }
                if (eqWidth > 0 && equityChart) {
                    equityChart.applyOptions({ width: eqWidth });
                }
            };

            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 250);
        }

        // Render trades table with entry and exit rows
        function renderTrades(trades) {
            const tradesTable = document.getElementById('trades-table');
            if (!tradesTable) return; // Element not in DOM
            const tbody = tradesTable.querySelector('tbody');
            if (!tbody) return;

            if (!trades || trades.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #8892b0;">No trades in selected period</td></tr>';
                return;
            }

            // Create rows for both entries and exits
            const rows = [];
            trades.forEach((trade, index) => {
                // Entry row
                const entryTime = new Date(trade.timestamp_unix * 1000).toLocaleString('en-US', {
                    month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                });
                const entryType = trade.side === 'long' ? 'Long Entry' : 'Short Entry';
                const entryColor = trade.side === 'long' ? '#2196F3' : '#FF9800';

                rows.push({
                    timestamp: trade.timestamp_unix,
                    html: `
                        <tr style="border-left: 3px solid ${entryColor};">
                            <td>${entryTime}</td>
                            <td style="color: ${entryColor}; font-weight: 500;">
                                ${trade.side === 'long' ? '&#x25B2;' : '&#x25BC;'} ${entryType}
                            </td>
                            <td>$${(trade.price ?? 0).toFixed(1)}</td>
                            <td>${trade.quantity ?? 0}</td>
                            <td style="color: #8892b0;">-</td>
                            <td style="color: #8892b0;">-</td>
                        </tr>
                    `
                });

                // Exit row (if exit data exists)
                if (trade.exit_time_unix && trade.exit_price) {
                    const exitTime = new Date(trade.exit_time_unix * 1000).toLocaleString('en-US', {
                        month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                    });
                    const exitType = trade.side === 'long' ? 'Close Long' : 'Close Short';
                    const exitColor = trade.pnl >= 0 ? '#00c853' : '#ff5252';
                    const profitSign = trade.pnl >= 0 ? '+' : '';

                    rows.push({
                        timestamp: trade.exit_time_unix,
                        html: `
                            <tr style="border-left: 3px solid ${exitColor};">
                                <td>${exitTime}</td>
                                <td style="color: ${exitColor}; font-weight: 500;">
                                    &#x25CF; ${exitType}
                                </td>
                                <td>$${(trade.exit_price ?? 0).toFixed(1)}</td>
                                <td>${trade.quantity ?? 0}</td>
                                <td class="${(trade.pnl ?? 0) >= 0 ? 'positive' : 'negative'}">${profitSign}$${(trade.pnl ?? 0).toFixed(2)}</td>
                                <td class="${(trade.cumulative_pnl ?? 0) >= 0 ? 'positive' : 'negative'}">${(trade.cumulative_pnl ?? 0) >= 0 ? '+' : ''}$${(trade.cumulative_pnl ?? 0).toFixed(2)}</td>
                            </tr>
                        `
                    });
                }
            });

            // Sort rows by timestamp
            rows.sort((a, b) => a.timestamp - b.timestamp);
            tbody.innerHTML = rows.map(r => r.html).join('');
        }

        // Animate cards on load
        function animateCards() {
            document.querySelectorAll('.card').forEach((card, i) => {
                card.style.opacity = '0';
                card.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    card.style.transition = 'opacity 0.5s, transform 0.5s';
                    card.style.opacity = '1';
                    card.style.transform = 'translateY(0)';
                }, i * 100);
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            console.log('[setupEventListeners] Setting up event listeners');

            // Live Test Control buttons (with null checks)
            const startBtn = document.getElementById('btn-start-test');
            console.log('[setupEventListeners] Start button found:', !!startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', (e) => {
                    console.log('[btn-start-test] CLICK EVENT FIRED');
                    e.preventDefault();
                    startLiveTest();
                });
            }
            const stopBtn = document.getElementById('btn-stop-backtest');
            if (stopBtn) stopBtn.addEventListener('click', stopAndBacktest);

            // Session selector dropdown
            const sessionSelector = document.getElementById('session-selector');
            if (sessionSelector) {
                sessionSelector.addEventListener('change', (e) => {
                    console.log(`[session-selector] Change event fired, value: ${e.target.value}`);
                    handleSessionChange(e.target.value);
                });
            }

            // Bot selector dropdown
            const botSelector = document.getElementById('bot-selector');
            if (botSelector) {
                botSelector.addEventListener('change', (e) => {
                    currentBot = e.target.value;
                    if (currentSession === 'compare') {
                        handleSessionChange('compare');
                    } else {
                        initDashboard(currentBot, currentPeriod);
                    }
                });
            }

            // Strategy selector for live test - drives dashboard mode
            const strategySelector = document.getElementById('strategy-selector');
            if (strategySelector) strategySelector.addEventListener('change', async (e) => {
                currentStrategy = e.target.value;

                // Switch dashboard mode based on strategy selection
                if (currentStrategy === 'none') {
                    // Mode A: Live market only
                    document.getElementById('live-strategy').textContent = 'None';
                    document.getElementById('btn-start-test').disabled = true;
                    document.getElementById('btn-start-test').classList.add('disabled');
                    updateStrategyDescription('none');
                    clearIndicators();
                    await switchDashboardMode('market');
                } else {
                    // Mode B: Strategy selected - show trade overlays + equity curve
                    document.getElementById('live-strategy').textContent = currentStrategy;
                    document.getElementById('btn-start-test').disabled = false;
                    document.getElementById('btn-start-test').classList.remove('disabled');
                    updateStrategyDescription(currentStrategy);
                    updateChartIndicators(currentStrategy);
                    await switchDashboardMode('strategy');
                }

                // Update chart title if we have data loaded
                if (currentData && currentData.metadata) {
                    const candlePeriodLabel = currentCandlePeriod;
                    const sessionLabel = currentSession === 'test' ? ' (TEST)' : '';
                    const strategyLabel = currentStrategy === 'none' ? '' : ` & ${currentStrategy} P&L`;
                    document.getElementById('chart-title').textContent =
                        `${currentData.metadata.pair} Price (${candlePeriodLabel})${strategyLabel}${sessionLabel}`;
                }
                console.log(`[strategy-selector] Strategy changed to: ${currentStrategy}, mode: ${currentStrategy === 'none' ? 'market' : 'strategy'}`);
            });

            // Date range selector
            const dateSelector = document.getElementById('date-selector');
            if (dateSelector) {
                dateSelector.addEventListener('change', (e) => {
                    currentPeriod = e.target.value;
                    if (currentSession !== 'compare') {
                        initDashboard(currentBot, currentPeriod);
                    }
                });
            }

            // Candle period selector
            const candlePeriodSelector = document.getElementById('candle-period-selector');
            if (candlePeriodSelector) {
                candlePeriodSelector.addEventListener('change', (e) => {
                    currentCandlePeriod = e.target.value;
                    console.log(`[Period Change] Selected: ${currentCandlePeriod}, has data: ${!!currentData}, candles: ${currentData?.candles?.length || 0}`);
                    if (currentSession !== 'compare' && currentData) {
                        renderCharts(currentData);
                        // Update chart title with new period - use currentStrategy if test is running
                        const candlePeriodLabel = currentCandlePeriod;
                        const sessionLabel = currentSession === 'test' ? ' (TEST)' : '';
                        const botName = (liveTestRunning && currentStrategy && currentStrategy !== 'none')
                            ? currentStrategy
                            : currentData.metadata.bot_name;
                        const chartTitle = document.getElementById('chart-title');
                        if (chartTitle) {
                            chartTitle.textContent =
                                `${currentData.metadata.pair} Price (${candlePeriodLabel}) & ${botName} P&L${sessionLabel}`;
                        }
                    }
                });
            }

            // Bot cards click
            document.querySelectorAll('.bot-card').forEach(card => {
                card.addEventListener('click', () => {
                    const botName = card.dataset.bot;
                    const botSelectorEl = document.getElementById('bot-selector');
                    if (botSelectorEl) botSelectorEl.value = botName;
                    currentBot = botName;
                    initDashboard(currentBot, currentPeriod);
                });
            });

            // Export CSV button
            const exportCsvBtn = document.getElementById('export-csv-btn');
            if (exportCsvBtn) {
                exportCsvBtn.addEventListener('click', () => {
                    exportToCSV(currentData);
                });
            }

            // Export Chart button
            const exportChartBtn = document.getElementById('export-chart-btn');
            if (exportChartBtn) {
                exportChartBtn.addEventListener('click', () => {
                    exportChartAsImage();
                });
            }
        }

        // Initialize on page load
        console.log('[INIT] Starting initialization sequence...');
        setupEventListeners();
        console.log('[INIT] setupEventListeners done');
        initDashboard();
        console.log('[INIT] initDashboard done');
        initViewToggle(); // Enable view toggle between Backtest and Live Market
        console.log('[INIT] initViewToggle done');
        initLiveMarketControls(); // Setup live market data controls
        console.log('[INIT] initLiveMarketControls done');
        initPeriodDropdown(); // Setup professional period dropdown
        console.log('[INIT] initPeriodDropdown done');
        initChartPeriodBar(); // Setup bottom time range buttons
        console.log('[INIT] initChartPeriodBar done');
        initTabBar(); // Setup bottom tab bar navigation
        console.log('[INIT] initTabBar done');
        initProBotControls(); // Setup pro bot controls
        console.log('[INIT] initProBotControls done - ALL INIT COMPLETE');

        // Tab bar navigation
        function initTabBar() {
            document.querySelectorAll('.tab-item').forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active from all tabs and contents
                    document.querySelectorAll('.tab-item').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    // Activate clicked tab and its content
                    tab.classList.add('active');
                    const tabId = 'tab-' + tab.dataset.tab;
                    const content = document.getElementById(tabId);
                    if (content) content.classList.add('active');
                });
            });
        }

        // Pro bot controls initialization
        function initProBotControls() {
            console.log('[initProBotControls] >>> FUNCTION CALLED <<<');
            const strategyPro = document.getElementById('strategy-selector-pro');
            const startPro = document.getElementById('btn-start-test-pro');
            const stopPro = document.getElementById('btn-stop-backtest-pro');
            console.log(`[initProBotControls] Elements found - strategyPro: ${!!strategyPro}, startPro: ${!!startPro}, stopPro: ${!!stopPro}`);

            if (strategyPro) {
                console.log('[initProBotControls] Adding change listener to strategy-selector-pro');
                // Add both change and input listeners for debugging
                strategyPro.addEventListener('input', (e) => {
                    console.log(`[Pro Controls INPUT] Value: ${e.target.value}`);
                });
                strategyPro.addEventListener('change', async (e) => {
                    console.log('[CHANGE] ========== HANDLER ENTERED ==========');
                    const strategy = e.target.value;
                    console.log(`[CHANGE] Step 1: strategy value = "${strategy}"`);

                    // Sync with legacy selector
                    const legacySelector = document.getElementById('strategy-selector');
                    if (legacySelector) legacySelector.value = strategy;
                    console.log('[CHANGE] Step 2: synced legacy selector');

                    // Enable/disable start button
                    if (startPro) {
                        startPro.disabled = (strategy === 'none');
                        console.log(`[CHANGE] Step 3: button disabled = ${strategy === 'none'}`);
                    }

                    // Update current strategy
                    currentStrategy = strategy;
                    console.log(`[CHANGE] Step 4: currentStrategy set to "${currentStrategy}"`);

                    // Load trade overlays and metrics if strategy selected
                    console.log(`[CHANGE] Step 5: checking if strategy !== 'none': ${strategy !== 'none'}`);
                    if (strategy !== 'none') {
                        console.log('[CHANGE] Step 6: INSIDE if block - will call functions');
                        try {
                            console.log('[CHANGE] Step 7: calling updateChartIndicators...');
                            updateChartIndicators(strategy);
                            console.log('[CHANGE] Step 8: updateChartIndicators done');

                            console.log('[CHANGE] Step 9: calling loadProMetrics...');
                            loadProMetrics(strategy);
                            console.log('[CHANGE] Step 10: loadProMetrics started (async)');

                            console.log('[CHANGE] Step 11: calling loadTradeOverlays...');
                            await loadTradeOverlays();
                            console.log('[CHANGE] Step 12: loadTradeOverlays DONE');

                            console.log('[CHANGE] Step 13: calling loadBotsTabTradeLogs...');
                            await loadBotsTabTradeLogs();
                            console.log('[CHANGE] Step 14: loadBotsTabTradeLogs DONE');
                        } catch (err) {
                            console.error('[CHANGE] ERROR in handler:', err);
                        }
                    } else {
                        console.log('[CHANGE] Step 6b: strategy is none, clearing overlays');
                        clearTradeOverlays();
                    }
                    console.log('[CHANGE] ========== HANDLER COMPLETE ==========');
                });
            }

            if (startPro) {
                startPro.addEventListener('click', () => {
                    if (typeof startLiveTest === 'function') {
                        startLiveTest();
                        document.getElementById('test-stats-pro').style.display = 'flex';
                    }
                });
            }

            if (stopPro) {
                stopPro.addEventListener('click', () => {
                    if (typeof stopAndBacktest === 'function') {
                        stopAndBacktest();
                    }
                });
            }
        }

        // Load metrics for pro panel
        async function loadProMetrics(strategy) {
            try {
                const data = await loadBacktestData(strategy);
                if (data && data.metrics) {
                    const m = data.metrics;
                    const setMetric = (id, val) => {
                        const el = document.getElementById(id);
                        if (el) el.textContent = val;
                    };
                    setMetric('metric-winrate', (m.win_rate || 0).toFixed(1) + '%');
                    setMetric('metric-pf', (m.profit_factor || 0).toFixed(2));
                    setMetric('metric-pnl', '$' + (m.total_pnl || 0).toFixed(2));
                    setMetric('metric-trades', m.total_trades || 0);
                    setMetric('metric-avgtrade', '$' + ((m.total_pnl || 0) / (m.total_trades || 1)).toFixed(2));
                    setMetric('metric-dd', (m.max_drawdown_percent || 0).toFixed(1) + '%');
                }
            } catch (err) {
                console.error('[loadProMetrics] Error:', err);
            }
        }

        // Load trade logs for the Your Bots tab
        async function loadBotsTabTradeLogs() {
            console.log('[loadBotsTabTradeLogs] >>> CALLED <<<');
            try {
                // Try backtest session first
                console.log(`[loadBotsTabTradeLogs] Fetching from: ${CONTROL_API_URL}/session/backtest`);
                const response = await fetch(`${CONTROL_API_URL}/session/backtest`, {
                    headers: { 'x-api-key': CONTROL_API_KEY }
                });

                console.log(`[loadBotsTabTradeLogs] Response status: ${response.status}`);
                if (!response.ok) {
                    if (response.status === 401) {
                        console.warn('[loadBotsTabTradeLogs] 401 - API key may be invalid or expired');
                    }
                    console.log('[loadBotsTabTradeLogs] ABORT: No backtest data available');
                    return;
                }

                const data = await response.json();
                console.log(`[loadBotsTabTradeLogs] Data received - success: ${data.success}, trades: ${data.trades?.length || 0}`);

                // Update the backtest trade log in Your Bots tab
                const backtestLogEl = document.getElementById('backtest-trades-log');
                const backtestCountEl = document.getElementById('backtest-trades-count');
                console.log(`[loadBotsTabTradeLogs] DOM elements - backtestLogEl: ${!!backtestLogEl}, backtestCountEl: ${!!backtestCountEl}`);

                // Handle no session data - show helpful message
                if (!data.success || !data.trades || data.trades.length === 0) {
                    console.log('[loadBotsTabTradeLogs] No active session data');
                    if (backtestCountEl) {
                        backtestCountEl.textContent = 'No session';
                        backtestCountEl.style.color = '#8b949e';
                    }
                    if (backtestLogEl) {
                        backtestLogEl.innerHTML = '<div class="no-session-msg" style="color: #8b949e; padding: 12px; text-align: center; font-size: 11px;">No active session<br><span style="color: #58a6ff;">Run a backtest to see trade data</span></div>';
                    }
                    return;
                }

                const trades = data.trades;
                console.log(`[loadBotsTabTradeLogs] Processing ${trades.length} trades`);

                if (backtestCountEl) {
                    backtestCountEl.textContent = `${trades.length} trades`;
                    backtestCountEl.style.color = '#3fb950';
                    console.log(`[loadBotsTabTradeLogs] Updated count to: ${trades.length} trades`);
                }

                if (backtestLogEl) {
                    // Render each trade
                    backtestLogEl.innerHTML = trades.map(trade => {
                        const entryTime = new Date(trade.timestamp_unix * 1000).toLocaleTimeString();
                        const exitTime = trade.exit_time_unix ? new Date(trade.exit_time_unix * 1000).toLocaleTimeString() : '--';
                        const pnl = trade.pnl || 0;
                        const pnlClass = pnl >= 0 ? 'pnl-positive' : 'pnl-negative';
                        const sideClass = trade.side === 'long' ? 'side-long' : 'side-short';

                        return `
                            <div class="trade-log-item">
                                <div class="trade-log-time">${entryTime}</div>
                                <div class="trade-log-action">
                                    <span class="${sideClass}">${trade.side?.toUpperCase() || 'UNKNOWN'}</span>
                                    @ ${trade.entry_price?.toFixed(1) || '--'}
                                </div>
                                <div class="trade-log-details">
                                    <span class="${pnlClass}">$${pnl.toFixed(2)}</span>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            } catch (err) {
                console.error('[loadBotsTabTradeLogs] Error:', err);
            }
        }

        // Default to Market mode (no strategy selected)
        (async function initLiveMarketView() {
            // Set initial strategy to 'none'
            currentStrategy = 'none';

            // Disable start button initially (no strategy selected)
            const startBtn = document.getElementById('btn-start-test');
            if (startBtn) {
                startBtn.disabled = true;
                startBtn.classList.add('disabled');
            }

            // Update strategy display
            const liveStrategyEl = document.getElementById('live-strategy');
            if (liveStrategyEl) liveStrategyEl.textContent = 'None';
            updateStrategyDescription('none');

            // Hide backtest controls (but keep live-test-panel visible)
            document.querySelectorAll('.control-group').forEach(el => el.style.display = 'none');
            const exportButtons = document.querySelector('.export-buttons');
            if (exportButtons) exportButtons.style.display = 'none';
            const liveTradeFeed = document.getElementById('live-trade-feed');
            if (liveTradeFeed) liveTradeFeed.style.display = 'none';

            // Hide equity curve container (market mode)
            const equityCurveContainer = document.getElementById('equity-curve-container');
            if (equityCurveContainer) equityCurveContainer.style.display = 'none';

            // Hide backtest content
            const dashboardContent = document.getElementById('dashboard-content');
            if (dashboardContent) dashboardContent.style.display = 'none';

            // Initialize chart and load data
            initLiveMarketChart();
            await loadLiveMarketData();

            // Start auto-refresh (fallback, WebSocket is primary)
            liveMarketRefreshInterval = setInterval(loadLiveMarketData, 300000);
            // Connect WebSocket for real-time updates
            connectLiveMarketWebSocket();
        })();

        checkInitialTestStatus(); // Check if a live test is already running
        initWebSocket(); // Connect to WebSocket for real-time trade streaming
    </script>
</body>
</html>
